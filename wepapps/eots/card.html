<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>태양의 제국 에라스무스 카드 앱</title>
    <style>
        body {
            font-family: 'Noto Serif KR', serif;
            background-color: #2b2b2b;
            color: #d4c4a1;
            margin: 0;
            overflow: auto;
        }
        #start-game-container, #control-buttons {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }
        #language-toggle {
            padding: 10px 20px;
            background: #6b6e70;
            color: #d4c4a1;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            text-transform: uppercase;
            transition: background 0.2s, transform 0.1s;
        }
        #language-toggle:hover {
            background: #8b8e90;
        }
        #language-toggle:active {
            background: #5b5e60;
            transform: scale(0.95);
        }
        #main-screen {
            display: flex;
            flex-direction: row;
            height: 100vh;
            width: 100%;
        }
        #main-image {
            height: 100vh;
            width: auto;
            overflow: hidden;
        }
        #main-image img {
            height: 100%;
            width: auto;
            object-fit: contain;
            object-position: left;
            display: block;
            z-index: 0;
            user-select: none;
            -webkit-user-drag: none;
        }
        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #2b2b2b;
            text-align: center;
        }
        #main-content h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 3px;
            white-space: pre-line;
            line-height: 1.2;
        }
        #start-game {
            padding: 10px 20px;
            background: #6b6e70;
            color: #d4c4a1;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            text-transform: uppercase;
            transition: background 0.2s, transform 0.1s;
        }
        #start-game:hover {
            background: #8b8e90;
        }
        #start-game:active {
            background: #5b5e60;
            transform: scale(0.95);
        }
        #game-container {
            max-width: 1400px;
            margin: auto;
            background: #1c2526;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            position: relative;
            display: none;
            min-height: 100vh;
        }
        #tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            background: #6b6e70;
            color: #d4c4a1;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            text-transform: uppercase;
            transition: background 0.2s, transform 0.1s;
            min-width: 100px;
            box-sizing: border-box;
        }
        #allied-tab {
            background: #1e90ff;
            color: #ffffff;
        }
        #allied-tab:hover:not(.active) {
            background: #4aa8ff;
        }
        #allied-tab:active:not(.active) {
            background: #1873cc;
            transform: scale(0.95);
        }
        #japanese-tab {
            background: #ff2a2a;
            color: #ffffff;
        }
        #japanese-tab:hover:not(.active) {
            background: #ff4c4c;
        }
        #japanese-tab:active:not(.active) {
            background: #cc2222;
            transform: scale(0.95);
        }
        .tab.active {
            background: #d4c4a1;
            color: #2b2b2b;
        }
        .tab:active:not(.active) {
            background: #5b5e60;
            transform: scale(0.95);
        }
        #turn-display {
            font-size: 28px;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #pass-display {
            font-size: 18px;
            text-align: center;
            margin-bottom: 15px;
        }
        #inputs, #allied-inputs {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            background: #3c3f41;
            padding: 10px;
            border-radius: 5px;
        }
        #inputs label, #allied-inputs label {
            font-size: 16px;
        }
        #inputs input[type="number"], #allied-inputs input[type="number"] {
            width: 50px;
            font-size: 18px;
            padding: 4px;
            background: #4b4e50;
            color: #d4c4a1;
            border: 1px solid #6b6e70;
            border-radius: 3px;
        }
        #inputs input[type="checkbox"], #allied-inputs input[type="checkbox"] {
            transform: scale(1.5);
        }
        #allied-inputs .surrender-checkbox {
            display: inline-block;
            margin-right: 10px;
        }
        #hand {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
        }
        .card {
            width: 200px;
            height: 300px;
            margin: 5px;
            cursor: pointer;
            border: 2px solid #6b6e70;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
            position: relative;
        }
        .card:hover {
            transform: scale(1.05);
        }
        .card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 3px;
            display: none;
            user-select: none;
            -webkit-user-drag: none;
        }
        .card img.loaded {
            display: block;
        }
        .enlarged {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 600px;
            z-index: 30;
            border: 3px solid #d4c4a1;
            border-radius: 8px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.7);
            transition: none;
        }
        .enlarged img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 5px;
            display: none;
            user-select: none;
            -webkit-user-drag: none;
        }
        .enlarged img.loaded {
            display: block;
        }
        .enlarged-buttons {
            position: absolute;
            bottom: -60px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        button {
            padding: 10px 20px;
            background: #6b6e70;
            color: #d4c4a1;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            /* text-transform: uppercase; */
            transition: background 0.2s, transform 0.1s;
            /* min-width: 100px; */
            box-sizing: border-box;
            text-align: center; /* 텍스트 가운데 정렬 명시 */
        }
        button:active:not(:disabled) {
            background: #5b5e60;
            transform: scale(0.95);
        }
        button:hover:not(:disabled) {
            background: #8b8e90;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #next-turn, #undo-button, #restart-button {
            margin: 5px;
        }
        #deck-remaining {
            margin-top: 30px;
            font-size: 20px;
            text-align: center;
        }
        #discard-pile, #removed-pile {
            margin-top: 10px;
            font-size: 20px;
            text-align: center;
            cursor: pointer;
            transition: color 0.2s;
        }
        #discard-pile:hover, #removed-pile:hover {
            color: #ffffff;
        }
        #discard-hand {
            display: none;
        }
        #discard-modal, #removed-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 20;
            width: 80%;
            max-width: 1000px;
            max-height: 80vh;
            text-align: center;
        }
        #discard-modal-content, #removed-modal-content {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            max-height: 60vh;
            overflow-y: auto;
            padding: 10px;
            background: #2f3537;
            border-radius: 5px;
        }
        #discard-modal-close, #removed-modal-close {
            margin-top: 10px;
            padding: 10px 20px;
            background: #ff6b6b;
            color: #ffffff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }
        #discard-modal-close:hover, #removed-modal-close:hover {
            background: #ff8b8b;
        }
        #discard-modal-close:active, #removed-modal-close:active {
            background: #e55b5b;
            transform: scale(0.95);
        }
        #future-offensive {
            margin-top: 20px;
            font-size: 20px;
            text-align: center;
            text-transform: uppercase;
        }
        #future-hand {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        #message {
            color: #ff6b6b;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }
        #turn-modal, #game-over-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #d4c4a1;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            z-index: 20;
            text-align: center;
            animation: fadeOut 3s forwards;
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; display: none; }
        }
        .placeholder {
            width: 100%;
            height: 100%;
            background: #4b4e50;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #d4c4a1;
            font-size: 16px;
            text-align: center;
            border-radius: 3px;
        }
        @media (max-width: 768px) {
        #main-screen {
            flex-direction: column;
            height: auto;
        }
        #main-image {
            width: 100%;
            height: auto;
        }
        #main-image img {
            width: 100%;
            height: auto;
            object-fit: contain;
            object-position: center;
        }
        #main-content {
            width: 100%;
            padding: 20px;
        }
        #main-content h1 {
            font-size: 32px;
            margin: 10px 0;
        }
        #start-game {
            font-size: 16px;
            padding: 8px 16px;
        }
        #game-container {
            padding: 10px;
        }
        #control-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        #tabs {
            flex-direction: column;
            align-items: center;
        }
        .tab {
            font-size: 16px;
            padding: 8px 16px;
            width: 100%;
            max-width: 200px;
        }
        #inputs, #allied-inputs {
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        #inputs button, #allied-inputs button {
            font-size: 14px;
            padding: 8px 16px;
            width: 100%;
            max-width: 200px;
        }
        #next-turn, #undo-button, #restart-button {
            font-size: 14px;
            padding: 8px 16px;
            width: 100%;
            max-width: 200px;
        }
        #discard-modal, #removed-modal {
            width: 90%;
            max-width: 600px;
        }
        #discard-modal-close, #removed-modal-close {
            font-size: 14px;
            padding: 8px 16px;
            width: 100%;
            max-width: 200px;
        }
        .enlarged {
            width: 80%;
            height: auto;
            max-height: 70vh;
        }
        .enlarged img {
            width: 100%;
            height: auto;
            object-fit: contain;
        }
        .enlarged-buttons {
            bottom: -50px;
            gap: 8px;
        }
        .enlarged-buttons button {
            font-size: 14px;
            padding: 8px 12px;
            min-width: 80px;
        }
        .card {
            width: 150px;
            height: 225px;
        }
        #start-game-container, #control-buttons {
            flex-direction: column;
            gap: 8px;
        }
        #language-toggle {
            font-size: 14px;
            padding: 8px 16px;
        }
        .sortable {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
        }

        .dragging {
            opacity: 0.5; /* 드래그 중 카드 투명도 조정 */
            transform: scale(1.05); /* 드래그 중 카드 확대 */
            border: 2px solid #ff6b6b; /* 드래그 중 테두리 강조 */
        }
        #save-game {
            padding: 10px 20px;
            background: #6b6e70;
            color: #d4c4a1;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            text-transform: uppercase;
            transition: background 0.2s, transform 0.1s;
            min-width: 100px;
            box-sizing: border-box;
            text-align: center;
        }
        #save-game:hover {
            background: #8b8e90;
        }
        #save-game:active {
            background: #5b5e60;
            transform: scale(0.95);
        }
        #load-game-input {
            display: none; /* 숨겨진 파일 입력 */
        }

        #load-game:hover {
            background: #8b8e90;
        }
        #load-game:active {
            background: #5b5e60;
            transform: scale(0.95);
        }
        @media (max-width: 768px) {
            #save-game, #load-game {
                font-size: 14px;
                padding: 8px 16px;
                width: 100%;
                max-width: 200px;
            }
        }
        .arcadia-modal-buttons, .historical-modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        #arcadia-yes, #arcadia-no {
            padding: 10px 20px;
            background: #6b6e70;
            color: #d4c4a1;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.2s, transform 0.1s;
        }
        #arcadia-yes:hover, #arcadia-no:hover {
            background: #8b8e90;
        }
        #arcadia-yes:active, #arcadia-no:active {
            background: #5b5e60;
            transform: scale(0.95);
        }
        #logistics-score {
            margin-left: 20px;
            font-size: 18px;
            font-weight: bold;
        }
        #pass-section {
            display: flex;
            align-items: center;
        }
        #pass-display, #logistics-score {
            margin-left: 20px;
            font-size: 18px;
            font-weight: bold;
            display: inline-block;
            visibility: visible;
        }
        #faction-content {
            display: block;
        }
        #pass-section {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
            font-size: 18px;
        }
        #pass-display, #allied-logistics-score, #japanese-logistics-score {
            background: #3c3f41;
            padding: 5px 10px;
            border-radius: 5px;
            color: #d4c4a1;
            display: inline-block;
            visibility: visible;
        }
        #allied-logistics-score.hidden, #japanese-logistics-score.hidden {
            display: none;
        }
        #historical-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
        }
        #historical-modal-content {
            background: #fff;
            padding: 20px;
            border-radius: 5px;
            max-width: 80%;
            max-height: 80%;
            overflow: auto;
        }
        #historical-modal-yes, #historical-modal-no {
            display: inline-block;
            padding: 10px 20px;
            margin-top: 10px;
            background: #3c3f41;
            color: #d4c4a1;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            visibility: visible;
            opacity: 1;
        }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;700&display=swap" rel="stylesheet">
    
</head>
<body>
    <div id="main-screen">
        <div id="main-image">
            <img src="card_image/eots.jpg" alt="태양의 제국 이미지">
        </div>
        <div id="main-content">
            <h1 id="main-title">태양의 제국<br>에라스무스 카드 앱</h1>
            <div id="start-game-container">
                <button id="start-game">게임 시작</button>
                <button id="language-toggle">ENG</button>
            </div>
        </div>
    </div>
    <div id="game-container">
        <div id="control-buttons">
            <button id="restart-button" style="display: none;">다시 시작</button>
            <button id="undo-button" style="display: none;" disabled>이전</button>
            <button id="next-turn" style="display: none;" disabled>다음 턴</button>
            <button id="save-game" style="display: none;">저장</button>
            <button id="load-game" style="display: none;">불러오기</button>
            <input type="file" id="load-game-input" style="display: none;" accept=".json">
        </div>
        <div id="tabs">
            <button id="allied-tab" class="tab">연합군</button>
            <button id="japanese-tab" class="tab active">일본군</button>
        </div>
        <div id="faction-content">
            <div id="turn-display" style="display: none;">턴: 1</div>
            <div id="pass-display" style="display: none;">패스: 0</div>
            <div id="pass-section">
                <span id="pass-display" style="display: none;">패스: 0</span>
            </div>
            <div id="message"></div>
            <div id="inputs" style="display: none;">
                <label for="resource-hexes">자원 헥스: <input type="number" id="resource-hexes" min="0" max="14" value="14"></label>
                <label for="submarine-success">잠수함전 성공: <input type="checkbox" id="submarine-success"></label>
                <label for="bombing-successes">전략 폭격 성공 횟수: <input type="number" id="bombing-successes" min="0" max="2" value="0"></label>
                <button id="japanese-draw-cards"></button>
                <button id="japanese-use-pass" disabled>패스 사용</button>
                <span id="japanese-logistics-score"></span>
            </div>
            <div id="allied-inputs" style="display: none;">
                <label for="wie-level">WIE: </label>
                <input type="number" id="wie-level" min="0" max="4" value="0">
                <div class="surrender-checkbox">
                    <label for="china-surrender">중국 항복: </label>
                    <input type="checkbox" id="china-surrender">
                </div>
                <div class="surrender-checkbox">
                    <label for="india-surrender">인도 항복: </label>
                    <input type="checkbox" id="india-surrender">
                </div>
                <div class="surrender-checkbox">
                    <label for="australia-surrender">호주 항복: </label>
                    <input type="checkbox" id="australia-surrender">
                </div>
                <button id="allied-draw-cards"></button>
                <button id="allied-use-pass" disabled>패스 사용</button>
                <span id="allied-logistics-score"></span>
            </div>
            <div id="hand" class="sortable"></div>
            <div id="future-offensive">미래 공세:</div>
            <div id="future-hand"></div>
            <div id="deck-remaining">남은 카드 더미: 계산 중...</div>
            <div id="discard-pile">버린 카드 더미:</div>
            <div id="removed-pile">제거된 카드 더미:</div>
            <div id="discard-hand"></div>
            <div id="turn-modal"></div>
            <div id="game-over-modal"></div>
            <div id="discard-modal">
                <div id="discard-modal-content"></div>
                <button id="discard-modal-close">닫기</button>
            </div>
            <div id="removed-modal">
                <div id="removed-modal-content"></div>
                <button id="removed-modal-close">닫기</button>
            </div>
            <div id="arcadia-modal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.8); color: #d4c4a1; padding: 20px 40px; border-radius: 10px; font-size: 24px; z-index: 20; text-align: center;">
                <div id="arcadia-modal-content"></div>
                <div class="arcadia-modal-buttons">
                    <button id="arcadia-yes">예</button>
                    <button id="arcadia-no">아니오</button>
                </div>
            </div>
            <div id="historical-modal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.8); color: #d4c4a1; padding: 20px 40px; border-radius: 10px; font-size: 24px; z-index: 20; text-align: center;">
                <div id="historical-modal-content"></div>
                <div class="historical-modal-buttons">
                    <button id="historical-modal-yes">예</button>
                    <button id="historical-modal-no">아니오</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let isGameStarted = false;
        

        document.addEventListener('DOMContentLoaded', () => {
            const numCardsAllied = 84;
            const numCardsJapanese = 86;
            const placeholderImage = 'card_image/placeholder.png';
            let isEnglish = false;
            let isHistoricalOpening = false;

            const languageData = {
            ko: {
                mainTitle: '태양의 제국\n에라스무스 카드 앱',
                startGame: '게임 시작',
                restartButton: '다시 시작',
                undoButton: '이전',
                nextTurnButton: '다음 턴',
                alliedTab: '연합군',
                japaneseTab: '일본군',
                turnDisplay: '턴: ',
                passDisplay: '패스: ',
                resourceHexes: '자원 헥스: ',
                submarineSuccess: '잠수함전 성공: ',
                bombingSuccesses: '전략 폭격 성공 횟수: ',
                wieLevel: 'WIE: ',
                chinaSurrender: '중국 항복: ',
                indiaSurrender: '인도 항복: ',
                australiaSurrender: '호주 항복: ',
                // japaneseDrawCards: '카드 뽑기',
                japaneseUsePass: '패스 사용',
                // alliedDrawCards: '카드 뽑기',
                alliedUsePass: '패스 사용',
                futureOffensive: '미래 공세:',
                deckRemaining: '남은 카드 더미: ',
                discardPile: '버린 카드 더미:',
                removedPile: '제거된 카드 더미:',
                discardModalClose: '닫기',
                removedModalClose: '닫기',
                ocButton: 'OC/버리기 (1)',
                eventButton: '이벤트 (3)',
                futureButton: '미래 공세 (2)',
                returnButton: '카드 덱으로 다시 가져오기 (4)',
                alliedTurn1Message: '연합군은 1턴에 카드를 뽑지 않습니다',
                undoMessage: '작업이 취소되었습니다!',
                discardMessage: '카드가 버린 카드 더미로 이동했습니다!',
                removedMessage: '카드가 게임에서 제거되었습니다!',
                futureMessage: '카드가 미래 공세로 설정되었습니다!',
                returnMessage: '카드가 핸드에 추가되었습니다!',
                passMessage: '패스를 사용했습니다!',
                reshuffleMessage: '제거된 카드를 제외한 모든 카드를 섞었습니다!',
                gameOverMessage: '게임이 종료되었습니다!',
                saveGame: '저장',
                loadGame: '불러오기',
                saveSuccessMessage: '게임 상태를 저장했습니다!',
                loadSuccessMessage: '게임 상태를 불러왔습니다!',
                loadErrorMessage: '유효하지 않은 파일입니다. JSON 파일을 선택해주세요.',
                arcadiaModalMessage: '아카디아 회담[4번] 카드를 뽑으시겠습니까?',
                arcadiaYes: '예',
                arcadiaNo: '아니오',
                yes: "예",
                no: '아니오',
                logisticsScore: '병참 평가: ',
                historicalModal: "역사적 변형 규칙을 적용하시겠습니까?(#3, #47, #59)",
                alliedDrawMessage: (cards, turn, base, wie, china, india, australia, reductions, passes) =>
                    `연합군 - 뽑을 카드: ${cards} (턴: ${turn}, 기본: ${base}, WIE 레벨: ${wie}, 중국: ${china ? '항복' : '미항복'}, 인도: ${india ? '항복' : '미항복'}, 호주: ${australia ? '항복' : '미항복'}, 감소: ${reductions}, 패스: ${passes})`,
                japaneseDrawMessage: (cards, turn, base, submarine, bombing, reductions, passes) =>
                    `일본군 - 뽑을 카드: ${cards} (턴: ${turn}, 기본: ${base}, 잠수함전: ${submarine ? '성공' : '실패'}, 폭격: ${bombing}, 감소: ${reductions}, 패스: ${passes})`,
                eventDrawMessage: (count) => `이벤트로 추가 카드를 뽑았습니다! (현재: ${count}/3장)`,
                eventDrawFailMessage: (deck, discard, count) => `이벤트로 추가 카드를 뽑을 수 없습니다! (덱: ${deck}, 버린 더미: ${discard}, 뽑은 이벤트 카드: ${count}/3)`,
                eventDrawLimitMessage: (count) => `이 턴에 더 이상 이벤트로 카드를 뽑을 수 없습니다! (현재: ${count}/3장)`,
                noCardsMessage: (needed) => `뽑을 카드가 없습니다! (필요: ${needed}장)`,
                shuffleMessage: '버린 카드 더미를 섞는 중...',
                turnModalMessage: (turn) => `턴 ${turn}로 넘어갑니다!`
            },
            en: {
                mainTitle: 'Empire of the Sun\nErasmus Card App',
                startGame: 'Start Game',
                restartButton: 'Restart',
                undoButton: 'Undo',
                nextTurnButton: 'Next Turn',
                alliedTab: 'Allied',
                japaneseTab: 'Japanese',
                turnDisplay: 'Turn: ',
                passDisplay: 'Passes: ',
                resourceHexes: 'Resource Hex: ',
                submarineSuccess: 'Submarine Warfare Success: ',
                bombingSuccesses: 'Strategic Bombing Success: ',
                wieLevel: 'WIE: ',
                chinaSurrender: 'China Surrender: ',
                indiaSurrender: 'India Surrender: ',
                australiaSurrender: 'Australia Surrender: ',
                // japaneseDrawCards: 'Draw Cards',
                japaneseUsePass: 'Use Pass',
                // alliedDrawCards: 'Draw Cards',
                alliedUsePass: 'Use Pass',
                futureOffensive: 'Future Offensive:',
                deckRemaining: 'Remaining Deck: ',
                discardPile: 'Discard Pile:',
                removedPile: 'Removed Cards:',
                discardModalClose: 'Close',
                removedModalClose: 'Close',
                ocButton: 'OC/Discard (1)',
                eventButton: 'Event (3)',
                futureButton: 'Future Offensive (2)',
                returnButton: 'Return to Hand (4)',
                alliedTurn1Message: 'Allied do not draw cards on Turn 1',
                undoMessage: 'Action undone!',
                discardMessage: 'Card moved to discard pile!',
                removedMessage: 'Card removed from the game!',
                futureMessage: 'Card set as Future Offensive!',
                returnMessage: 'Card added to hand!',
                passMessage: 'Pass used!',
                reshuffleMessage: 'All cards except removed ones have been shuffled!',
                gameOverMessage: 'Game Over!',
                saveGame: 'Save',
                loadGame: 'Load',
                saveSuccessMessage: 'Game state saved successfully!',
                loadSuccessMessage: 'Game state loaded successfully!',
                loadErrorMessage: 'Invalid file. Please select a valid JSON file.',
                arcadiaModalMessage: 'Would you like to draw the Arcadia Conference [Card 4]?',
                arcadiaYes: 'Yes',
                arcadiaNo: 'No',
                yes: "Yes",
                no: 'No',
                historicalModal: "Want to start with 'Historical Opening' setting?: start with cards #3, #47, #59",
                logisticsScore: 'Logistics Score: ',
                alliedDrawMessage: (cards, turn, base, wie, china, india, australia, reductions, passes) =>
                    `Allies - Cards to draw: ${cards} (Turn: ${turn}, Base: ${base}, WIE: ${wie}, China: ${china ? 'Surrendered' : 'Not Surrendered'}, India: ${india ? 'Surrendered' : 'Not Surrendered'}, Australia: ${australia ? 'Surrendered' : 'Not Surrendered'}, Reductions: ${reductions}, Passes: ${passes})`,
                japaneseDrawMessage: (cards, turn, base, submarine, bombing, reductions, passes) =>
                    `Japanese - Cards to draw: ${cards} (Turn: ${turn}, Base: ${base}, Submarine Warfare: ${submarine ? 'Success' : 'Failure'}, Strategic Bombing: ${bombing}, Reductions: ${reductions}, Passes: ${passes})`,
                eventDrawMessage: (count) => `Drew an additional card via event! (Current: ${count}/3)`,
                eventDrawFailMessage: (deck, discard, count) => `Cannot draw additional card via event! (Deck: ${deck}, Discard: ${discard}, Event Cards Drawn: ${count}/3)`,
                eventDrawLimitMessage: (count) => `Cannot draw more event cards this turn! (Current: ${count}/3)`,
                noCardsMessage: (needed) => `No cards left to draw! (Needed: ${needed})`,
                shuffleMessage: 'Shuffling discard pile...',
                turnModalMessage: (turn) => `Advancing to Turn ${turn}!`
            }
        };

            const alliedCardProperties = Array(numCardsAllied).fill().map((_, i) => {
                const patterns = ['3100001','3100010','5100001',
                                  '3100001','2203100','3300001',
                                  '1204101','2100111','1312100',
                                  '3100001','3200001','2200001',
                                  '1305100','3200001','5200000',
                                  '5100001','5200001','5100001',
                                  '1203100','1104101','1306000',
                                  '2200001','5200011','2200011',
                                  '1103100','2200001','5100001',
                                  '1203000','1204000','1204101',
                                  '1306100','1307000','1203100',
                                  '1204100','1202100','1305100',
                                  '1306100','1204100','3200001',
                                  '1305000','3200001','3200001',
                                  '3100010','1202100','1305100',
                                  '1201000','3200001','1204100',
                                  '3100001','1204000','1204101',
                                  '3100001','1306000','1205100',
                                  '1306000','1204000','1205100',
                                  '1204100','2100010','5300001',
                                  '2100011','1308101','1306000',
                                  '1204000','1308101','3200001',
                                  '5300001','2100011','1308000',
                                  '1206101','1206000','1208000',
                                  '3200001','1308100','1308100',
                                  '1205100','3200001','2100011',
                                  '3300001','5100011','3200000',
                                  '3200000','3200000','1300100'];
                return patterns[i % patterns.length];
            });
            const japaneseCardProperties = Array(numCardsJapanese).fill().map((_, i) => {
                const patterns = ['1300001','1326001','1203100',
                                  '2100010','5200001','3200001',
                                  '3200010','1304100','1306100',
                                  '1306000','3200010','1308100',
                                  '2200101','1305100','3300001',
                                  '1304100','2203110','3100001',
                                  '2200001','1205000','2300011',
                                  '2200001','1203000','2100010',
                                  '1304000','3200001','2100010',
                                  '1304100','1304100','5300001',
                                  '5300001','1304100','3200000',
                                  '3200010','5300000','2100010',
                                  '1302001','1302001','5200001',
                                  '1304100','3300001','3300001',
                                  '3100001','1304000','2305101',
                                  '2305001','1307000','1305100',
                                  '2100010','1306100','3300001',
                                  '3300001','3300001','3300001',
                                  '3300001','3300001','3300001',
                                  '1305000','1305000','1305000',
                                  '2200011','2200011','2200011',
                                  '2200011','2101101','2200011',
                                  '3200000','3200000','2100010',
                                  '2100010','5300001','5300001',
                                  '1203001','3100001','2100010',
                                  '1201101','5300000','5100001',
                                  '1201101','5200011','2200011',
                                  '3300000','1204000','2100010',
                                  '2203101','2100010'];
                // return patterns[i % patterns.length];
                return patterns[i] || '0000000'; // 문자열 유지
            });
            
            let factions = {
                allied: { deck: [], hand: [], futureOffensive: null, discardPile: [], removedCards: [], currentTurn: 1, passes: 0, stateHistory: [], logisticsScore: 0, needReshuffle: false, eventCardsDrawnThisTurn: 0 },
                japanese: { deck: [], hand: [], futureOffensive: null, discardPile: [], removedCards: [], currentTurn: 1, passes: 0, stateHistory: [], logisticsScore: 0,needReshuffle: false, cardsPlayedTurn1: [], eventCardsDrawnThisTurn: 0 }
            };
            let currentFaction = 'japanese';
            let enlargedCard = null;
            let drawArcadia = false;

            const mainScreen = document.getElementById('main-screen');
            const startGameButton = document.getElementById('start-game');
            const gameContainer = document.getElementById('game-container');
            const alliedTab = document.getElementById('allied-tab');
            const japaneseTab = document.getElementById('japanese-tab');
            const turnDisplay = document.getElementById('turn-display');
            const passDisplay = document.getElementById('pass-display');
            const inputsDiv = document.getElementById('inputs');
            const alliedInputs = document.getElementById('allied-inputs');
            const alliedDrawButton = document.getElementById('allied-draw-cards');
            const japaneseDrawButton = document.getElementById('japanese-draw-cards');
            const alliedUsePassButton = document.getElementById('allied-use-pass');
            const japaneseUsePassButton = document.getElementById('japanese-use-pass');
            const handDiv = document.getElementById('hand');
            const futureDiv = document.getElementById('future-offensive');
            const futureHandDiv = document.getElementById('future-hand');
            const deckRemainingDiv = document.getElementById('deck-remaining');
            const discardPileDiv = document.getElementById('discard-pile');
            const removedPileDiv = document.getElementById('removed-pile');
            const discardHandDiv = document.getElementById('discard-hand');
            const messageDiv = document.getElementById('message');
            const turnModal = document.getElementById('turn-modal');
            const gameOverModal = document.getElementById('game-over-modal');
            const discardModal = document.getElementById('discard-modal');
            const discardModalContent = document.getElementById('discard-modal-content');
            const discardModalClose = document.getElementById('discard-modal-close');
            const removedModal = document.getElementById('removed-modal');
            const removedModalContent = document.getElementById('removed-modal-content');
            const removedModalClose = document.getElementById('removed-modal-close');
            const nextTurnButton = document.getElementById('next-turn');
            const undoButton = document.getElementById('undo-button');
            const restartButton = document.getElementById('restart-button');
            const languageToggleButton = document.getElementById('language-toggle');
            const saveGameButton = document.getElementById('save-game');
            const loadGameButton = document.getElementById('load-game');
            const loadGameInput = document.getElementById('load-game-input');
            const historicalModal = document.getElementById('historical-modal');
            const historicalModalContent = document.getElementById('historical-modal-content');
            const historicalModalYes = document.getElementById('historical-modal-yes');
            const historicalModalNo = document.getElementById('historical-modal-no');

            updateLanguage();

            document.querySelector('#main-image img').addEventListener('contextmenu', (e) => e.preventDefault());
            document.getElementById('start-game').addEventListener('click', () => {
                isGameStarted = true;
                const titleScreen = document.getElementById('title-screen');
                const gameScreen = document.getElementById('game-screen');
                if (titleScreen) titleScreen.style.display = 'none';
                if (gameScreen) gameScreen.style.display = 'block';
                factions.allied.deck = initializeDeck('allied');
                factions.japanese.deck = initializeDeck('japanese');
                updateLanguage();
                updateHandDisplay();
                updateDeckRemainingDisplay();
                if (alliedDrawButton) alliedDrawButton.disabled = true;
                if (japaneseDrawButton) japaneseDrawButton.disabled = false;
                updateTurnDisplay();
                if (saveGameButton) {
                    saveGameButton.addEventListener('click', () => {
                        saveGame();
                    });
                } else {
                    console.error('save-game button not found');
                }
                
                if (loadGameButton && loadGameInput) {
                    loadGameButton.addEventListener('click', () => {
                        loadGameInput.click();
                    });
                    loadGameInput.addEventListener('change', loadGame);
                } else {
                    console.error('load-game or load-game-input not found');
                }
                
            });     

            function updateTurnDisplay() {
                const turnDisplay = document.getElementById('turn-display');
                const lang = isEnglish ? languageData.en : languageData.ko;
                if (turnDisplay) {
                    turnDisplay.textContent = `${lang.turnDisplay}${factions[currentFaction].currentTurn}`;
                } else {
                    console.warn('turn-display not found');
                }
            }
            
            function getValidImagePath(faction, cardNumber, isLarge = false) {
                const lang = isEnglish ? '_eng' : '';
                const extension = isEnglish ? '.gif' : '.png';
                const basePath = `card_image/${faction === 'allied' ? 'al' : 'jp'}${lang}`; // 'al'로 직접 비교
                const path = `${basePath}/${cardNumber}${isLarge ? '_large' : ''}${extension}`;
                console.log(`getValidImagePath: faction=${faction}, cardNumber=${cardNumber}, isLarge=${isLarge}, path=${path}`);
                return path;
            }


            function initializeDeck(factionType) {
                const properties = factionType === 'allied' ? alliedCardProperties : japaneseCardProperties;
                const prefix = factionType === 'allied' ? 'AL Card' : 'JP Card';
                const deck = [];

                properties.forEach((prop, index) => {
                    if (typeof prop !== 'string' || prop.length !== 7) {
                        console.error(`Invalid property format for card ${index + 1}: ${prop}`);
                        return;
                    }
                    const card = {
                        id: `${prefix} ${index + 1}`,
                        type: parseInt(prop[0], 10), // 카드 종류 (1~5)
                        oc: parseInt(prop[1], 10), // OC 수치 (1~3)
                        logistics: parseInt(prop.slice(2, 4), 10), // Logistics 수치 (00~99)
                        condition: parseInt(prop[4], 10), // 조건 여부 (0, 1)
                        drawStrategic: parseInt(prop[5], 10), // 전략카드 뽑기 (0, 1)
                        removeOnEvent: parseInt(prop[6], 10) // 이벤트 제거 여부 (0, 1)
                    };
                    console.log(`initializeDeck: cardId=${card.id}, properties=${prop}, condition=${card.condition}, drawStrategic=${card.drawStrategic}, removeOnEvent=${card.removeOnEvent}`);
                    deck.push(card);
                });

                shuffle(deck);
                return deck;
            }

            function updateLanguage() {
                const lang = isEnglish ? languageData.en : languageData.ko;
                console.log(`updateLanguage: isEnglish=${isEnglish}, lang.historicalModal=${lang.historicalModal}`);

                // 초기 화면 요소
                const mainTitle = document.getElementById('main-title');
                if (mainTitle) mainTitle.textContent = lang.mainTitle;
                
                const startGame = document.getElementById('start-game');
                if (startGame) startGame.textContent = lang.startGame;

                const alliedLogisticsSpan = document.getElementById('allied-logistics-score');
                
                const japaneseLogisticsSpan = document.getElementById('japanese-logistics-score');
                if (alliedLogisticsSpan) {
                    alliedLogisticsSpan.textContent = `${lang.logisticsScore}${factions.allied.logisticsScore}`;
                    alliedLogisticsSpan.className = currentFaction === 'allied' ? '' : 'hidden';
                    console.log(`Updated allied logistics score: ${alliedLogisticsSpan.textContent}, display=${alliedLogisticsSpan.style.display}`);
                } else {
                    console.error('allied-logistics-score element not found in DOM');
                }
                if (japaneseLogisticsSpan) {
                    japaneseLogisticsSpan.textContent = `${lang.logisticsScore}${factions.japanese.logisticsScore}`;
                    japaneseLogisticsSpan.className = currentFaction === 'japanese' ? '' : 'hidden';
                    console.log(`Updated japanese logistics score: ${japaneseLogisticsSpan.textContent}, display=${japaneseLogisticsSpan.style.display}`);
                } else {
                    console.error('japanese-logistics-score element not found in DOM');
                }

                // 게임 화면 요소
                const restartButton = document.getElementById('restart-button');
                if (restartButton) restartButton.textContent = lang.restartButton;
                
                const undoButton = document.getElementById('undo-button');
                if (undoButton) undoButton.textContent = lang.undoButton;
                
                const nextTurn = document.getElementById('next-turn');
                if (nextTurn) nextTurn.textContent = lang.nextTurnButton;
                
                const alliedTab = document.getElementById('allied-tab');
                if (alliedTab) alliedTab.textContent = lang.alliedTab;
                
                const japaneseTab = document.getElementById('japanese-tab');
                if (japaneseTab) japaneseTab.textContent = lang.japaneseTab;
                
                const turnDisplay = document.getElementById('turn-display');
                if (turnDisplay) turnDisplay.textContent = `${lang.turnDisplay}${factions[currentFaction].currentTurn}`;
                
                const passDisplay = document.getElementById('pass-display');
                if (passDisplay) passDisplay.textContent = `${lang.passDisplay}${factions[currentFaction].passes}`;
                
                const futureOffensive = document.getElementById('future-offensive');
                if (futureOffensive) futureOffensive.textContent = lang.futureOffensive;
                
                const deckRemaining = document.getElementById('deck-remaining');
                if (deckRemaining) deckRemaining.textContent = `${lang.deckRemaining}${factions[currentFaction].deck.length}${isEnglish ? '' : '장'}`;
                
                const discardPile = document.getElementById('discard-pile');
                if (discardPile) discardPile.textContent = lang.discardPile;
                
                const removedPile = document.getElementById('removed-pile');
                if (removedPile) removedPile.textContent = lang.removedPile;
                
                const discardModalClose = document.getElementById('discard-modal-close');
                if (discardModalClose) discardModalClose.textContent = lang.discardModalClose;
                
                const removedModalClose = document.getElementById('removed-modal-close');
                if (removedModalClose) removedModalClose.textContent = lang.removedModalClose;

                const historicalModalContent = document.getElementById('historical-modal-content');
                if (historicalModalContent) {
                    historicalModalContent.textContent = lang.historicalModal;
                    console.log('Set historicalModalContent:', historicalModalContent.textContent);
                } else {
                    console.warn('historical-modal-content not found in DOM');
                }

                const historicalModalYes = document.getElementById('historical-modal-yes');
                if (historicalModalYes) {
                    historicalModalYes.textContent = lang.yes;
                    console.log('Set historicalModalYes:', historicalModalYes.textContent);
                    // 덮어씯우기 방지: 지연 시간 증가 및 호출 스택 추적
                    setTimeout(() => {
                        if (historicalModalYes.textContent !== lang.yes) {
                            console.warn('historicalModalYes text overwritten:', historicalModalYes.textContent, new Error().stack);
                            historicalModalYes.textContent = lang.yes;
                        }
                    }, 200);
                } else {
                    console.warn('historical-modal-yes not found in DOM');
                }

                const historicalModalNo = document.getElementById('historical-modal-no');
                if (historicalModalNo) {
                    historicalModalNo.textContent = lang.no;
                    console.log('Set historicalModalNo:', historicalModalNo.textContent);
                    // 덮어씯우기 방지: 지연 시간 증가 및 호출 스택 추적
                    setTimeout(() => {
                        if (historicalModalNo.textContent !== lang.no) {
                            console.warn('historicalModalNo text overwritten:', historicalModalNo.textContent, new Error().stack);
                            historicalModalNo.textContent = lang.no;
                        }
                    }, 200);
                } else {
                    console.warn('historical-modal-no not found in DOM');
                }
                
                const japaneseUsePass = document.getElementById('japanese-use-pass');
                if (japaneseUsePass) japaneseUsePass.textContent = lang.japaneseUsePass;
                
                const alliedUsePass = document.getElementById('allied-use-pass');
                if (alliedUsePass) alliedUsePass.textContent = lang.alliedUsePass;

                // 입력 레이블 업데이트
                const inputsContainer = document.getElementById('inputs');
                if (inputsContainer) {
                    const resourceHexesLabel = inputsContainer.querySelector('label[for="resource-hexes"]');
                    if (resourceHexesLabel) resourceHexesLabel.firstChild.textContent = lang.resourceHexes;
                    
                    const submarineSuccessLabel = inputsContainer.querySelector('label[for="submarine-success"]');
                    if (submarineSuccessLabel) submarineSuccessLabel.firstChild.textContent = lang.submarineSuccess;
                    
                    const bombingSuccessesLabel = inputsContainer.querySelector('label[for="bombing-successes"]');
                    if (bombingSuccessesLabel) bombingSuccessesLabel.firstChild.textContent = lang.bombingSuccesses;
                }

                const alliedInputsContainer = document.getElementById('allied-inputs');
                if (alliedInputsContainer) {
                    const wieLevelLabel = alliedInputsContainer.querySelector('label[for="wie-level"]');
                    if (wieLevelLabel) wieLevelLabel.textContent = lang.wieLevel;

                    const chinaSurrenderLabel = alliedInputsContainer.querySelector('label[for="china-surrender"]');
                    if (chinaSurrenderLabel) chinaSurrenderLabel.textContent = lang.chinaSurrender;

                    const indiaSurrenderLabel = alliedInputsContainer.querySelector('label[for="india-surrender"]');
                    if (indiaSurrenderLabel) indiaSurrenderLabel.textContent = lang.indiaSurrender;

                    const australiaSurrenderLabel = alliedInputsContainer.querySelector('label[for="australia-surrender"]');
                    if (australiaSurrenderLabel) australiaSurrenderLabel.textContent = lang.australiaSurrender;
                }

                // 카드 이미지 경로 갱신
                ['allied', 'japanese'].forEach(faction => {
                    factions[faction].deck = factions[faction].deck.map(card => ({
                        ...card,
                        image: getValidImagePath(faction, parseInt(card.id.split(' ')[2]))
                    }));
                    factions[faction].hand = factions[faction].hand.map(card => ({
                        ...card,
                        image: getValidImagePath(faction, parseInt(card.id.split(' ')[2]))
                    }));
                    factions[faction].discardPile = factions[faction].discardPile.map(card => ({
                        ...card,
                        image: getValidImagePath(faction, parseInt(card.id.split(' ')[2]))
                    }));
                    factions[faction].removedCards = factions[faction].removedCards.map(card => ({
                        ...card,
                        image: getValidImagePath(faction, parseInt(card.id.split(' ')[2]))
                    }));
                    if (factions[faction].futureOffensive) {
                        factions[faction].futureOffensive = {
                            ...factions[faction].futureOffensive,
                            image: getValidImagePath(faction, parseInt(factions[faction].futureOffensive.id.split(' ')[2]))
                        };
                    }
                });

                const saveGameButton = document.getElementById('save-game');
                const loadGameButton = document.getElementById('load-game');
                if (saveGameButton) saveGameButton.textContent = isEnglish ? 'Save' : '저장';
                if (loadGameButton) loadGameButton.textContent = isEnglish ? 'Load' : '불러오기';

                // UI 갱신
                updateHandDisplay();
                updateFutureDisplay();
                updateDiscardModal();
                updateRemovedModal();
                updateDeckRemainingDisplay();
            }


            languageToggleButton.addEventListener('click', () => {
                isEnglish = !isEnglish;
                languageToggleButton.textContent = isEnglish ? 'KOR' : 'ENG';
                updateLanguage();
            });

            factions.allied.deck = initializeDeck('allied');
            factions.japanese.deck = initializeDeck('japanese');

            function shuffle(array) {
                if (!array || !Array.isArray(array)) {
                    console.error('Shuffle received invalid array:', array);
                    return [];
                }
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                console.log('Shuffled deck:', shuffled.map(card => card.id));
                return shuffled;
            }

            function saveState() {
                const faction = factions[currentFaction];
                faction.stateHistory.push({
                    deck: [...faction.deck],
                    hand: [...faction.hand],
                    discardPile: [...faction.discardPile],
                    removedCards: [...faction.removedCards],
                    futureOffensive: faction.futureOffensive ? { ...faction.futureOffensive } : null,
                    currentTurn: faction.currentTurn,
                    passes: faction.passes,
                    needReshuffle: faction.needReshuffle,
                    cardsPlayedTurn1: currentFaction === 'japanese' ? [...faction.cardsPlayedTurn1] : [],
                    eventCardsDrawnThisTurn: faction.eventCardsDrawnThisTurn
                });
                if (undoButton) undoButton.disabled = false;
            }

            function undo() {
                const faction = factions[currentFaction];
                if (faction.stateHistory.length === 0) return;

                const lastState = faction.stateHistory.pop();
                faction.deck = [...lastState.deck];
                faction.hand = [...lastState.hand];
                faction.discardPile = [...lastState.discardPile];
                faction.removedCards = [...lastState.removedCards];
                faction.futureOffensive = lastState.futureOffensive ? { ...lastState.futureOffensive } : null;
                faction.currentTurn = lastState.currentTurn;
                faction.passes = lastState.passes;
                faction.needReshuffle = lastState.needReshuffle;
                faction.eventCardsDrawnThisTurn = lastState.eventCardsDrawnThisTurn;
                if (currentFaction === 'japanese') {
                    faction.cardsPlayedTurn1 = [...lastState.cardsPlayedTurn1];
                }

                updateUI();
                messageDiv.textContent = isEnglish ? languageData.en.undoMessage : languageData.ko.undoMessage;
                setTimeout(() => { messageDiv.textContent = ''; }, 3000);
            }

            function resetGame() {
                factions.allied = { deck: initializeDeck('allied'), hand: [], futureOffensive: null, discardPile: [], removedCards: [], currentTurn: 1, passes: 0, stateHistory: [], needReshuffle: false, eventCardsDrawnThisTurn: 0 };
                factions.japanese = { deck: initializeDeck('japanese'), hand: [], futureOffensive: null, discardPile: [], removedCards: [], currentTurn: 1, passes: 0, stateHistory: [], needReshuffle: false, cardsPlayedTurn1: [], eventCardsDrawnThisTurn: 0 };
                isGameStarted = false; // 명시적으로 초기화
                isHistoricalOpening = false; // 수정: 역사적 변형 초기화
                currentFaction = 'japanese';
                updateUI(); // UI 즉시 갱신
                gameContainer.style.display = 'none';
                mainScreen.style.display = 'flex';
                discardModal.style.display = 'none';
                removedModal.style.display = 'none';
                console.log('Game reset, language-toggle should be in start-game-container');
            }

            startGameButton.addEventListener('click', () => {
                mainScreen.style.display = 'none';
                gameContainer.style.display = 'block';
                turnDisplay.style.display = 'block';
                passDisplay.style.display = 'block';
                inputsDiv.style.display = currentFaction === 'japanese' ? 'flex' : 'none';
                alliedInputs.style.display = currentFaction === 'allied' ? 'flex' : 'none';
                if (nextTurnButton) nextTurnButton.style.display = 'block';
                if (undoButton) undoButton.style.display = 'block';
                if (restartButton) restartButton.style.display = 'block';
                if (currentFaction === 'japanese' && factions.japanese.currentTurn === 1) {
                    drawCards('japanese');
                }
                updateUI();
            });

            alliedTab.addEventListener('click', () => switchFaction('allied'));
            japaneseTab.addEventListener('click', () => switchFaction('japanese'));

            function switchFaction(newFaction) {
                currentFaction = newFaction;
                const lang = isEnglish ? languageData.en : languageData.ko;
                console.log(`Switching to faction: ${newFaction}, lang.logisticsScore=${lang.logisticsScore}`);

                // 진영별 병참 평가 점수 갱신 및 표시/숨김
                const logisticsSpan = document.getElementById(`${newFaction}-logistics-score`);
                const otherFaction = newFaction === 'allied' ? 'japanese' : 'allied';
                const otherLogisticsSpan = document.getElementById(`${otherFaction}-logistics-score`);
                if (logisticsSpan) {
                    console.log(`Setting ${newFaction} logistics score: lang.logisticsScore=${lang.logisticsScore}, score=${factions[newFaction].logisticsScore}`);
                    logisticsSpan.textContent = `${lang.logisticsScore}${factions[newFaction].logisticsScore}`;
                    logisticsSpan.className = ''; // 표시
                } else {
                    console.error(`${newFaction}-logistics-score element not found in DOM`);
                }
                if (otherLogisticsSpan) {
                    otherLogisticsSpan.className = 'hidden'; // 상대 진영 숨김
                }

                updateUI();
            }

            function saveGame() {
                const gameState = {
                    factions: {
                        allied: {
                            deck: factions.allied.deck,
                            hand: factions.allied.hand,
                            futureOffensive: factions.allied.futureOffensive,
                            discardPile: factions.allied.discardPile,
                            removedCards: factions.allied.removedCards,
                            currentTurn: factions.allied.currentTurn,
                            passes: factions.allied.passes,
                            stateHistory: factions.allied.stateHistory,
                            needReshuffle: factions.allied.needReshuffle,
                            eventCardsDrawnThisTurn: factions.allied.eventCardsDrawnThisTurn
                        },
                        japanese: {
                            deck: factions.japanese.deck,
                            hand: factions.japanese.hand,
                            futureOffensive: factions.japanese.futureOffensive,
                            discardPile: factions.japanese.discardPile,
                            removedCards: factions.japanese.removedCards,
                            currentTurn: factions.japanese.currentTurn,
                            passes: factions.japanese.passes,
                            stateHistory: factions.japanese.stateHistory,
                            needReshuffle: factions.japanese.needReshuffle,
                            cardsPlayedTurn1: factions.japanese.cardsPlayedTurn1,
                            eventCardsDrawnThisTurn: factions.japanese.eventCardsDrawnThisTurn
                        }
                    },
                    currentFaction: currentFaction,
                    isGameStarted: isGameStarted,
                    isEnglish: isEnglish
                };
                
                const blob = new Blob([JSON.stringify(gameState, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `eots_game_state_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                messageDiv.textContent = isEnglish ? languageData.en.saveSuccessMessage : languageData.ko.saveSuccessMessage;
                setTimeout(() => { messageDiv.textContent = ''; }, 3000);
            }

            // loadGame 함수 추가
            function loadGame(event) {
                const file = event.target.files[0];
                if (!file || !file.name.endsWith('.json')) {
                    messageDiv.textContent = isEnglish ? languageData.en.loadErrorMessage : languageData.ko.loadErrorMessage;
                    setTimeout(() => { messageDiv.textContent = ''; }, 3000);
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const gameState = JSON.parse(e.target.result);
                        // 상태 복원
                        factions.allied = gameState.factions.allied;
                        factions.japanese = gameState.factions.japanese;
                        currentFaction = gameState.currentFaction;
                        isGameStarted = gameState.isGameStarted;
                        isEnglish = gameState.isEnglish;
                        
                        // 언어 및 UI 갱신
                        languageToggleButton.textContent = isEnglish ? 'KOR' : 'ENG';
                        updateLanguage();
                        updateUI();
                        
                        messageDiv.textContent = isEnglish ? languageData.en.loadSuccessMessage : languageData.ko.loadSuccessMessage;
                        setTimeout(() => { messageDiv.textContent = ''; }, 3000);
                    } catch (error) {
                        console.error('Failed to load game state:', error);
                        messageDiv.textContent = isEnglish ? languageData.en.loadErrorMessage : languageData.ko.loadErrorMessage;
                        setTimeout(() => { messageDiv.textContent = ''; }, 3000);
                    }
                };
                reader.readAsText(file);
                // input 초기화
                event.target.value = '';
            }
            
            function updateUI() {
                const faction = factions[currentFaction];
                const lang = isEnglish ? languageData.en : languageData.ko;
                const languageToggle = document.getElementById('language-toggle');
                const startGameContainer = document.getElementById('start-game-container');
                const controlButtons = document.getElementById('control-buttons');
                const saveGameButton = document.getElementById('save-game');
                const loadGameButton = document.getElementById('load-game');
                const loadGameInput = document.getElementById('load-game-input');
                const historicalModal = document.getElementById('historical-modal');


                turnDisplay.textContent = `${lang.turnDisplay}${faction.currentTurn}`;
                passDisplay.textContent = `${lang.passDisplay}${faction.passes}`;

                const historicalModalYes = document.getElementById('historical-modal-yes');
                const historicalModalNo = document.getElementById('historical-modal-no');


                const alliedLogisticsSpan = document.getElementById('allied-logistics-score');
                const japaneseLogisticsSpan = document.getElementById('japanese-logistics-score');
                if (alliedLogisticsSpan) {
                    alliedLogisticsSpan.textContent = `${lang.logisticsScore}${factions.allied.logisticsScore}`;
                    alliedLogisticsSpan.className = currentFaction === 'allied' ? '' : 'hidden';
                } else {
                    console.error('allied-logistics-score element not found in DOM');
                }
                if (japaneseLogisticsSpan) {
                    japaneseLogisticsSpan.textContent = `${lang.logisticsScore}${factions.japanese.logisticsScore}`;
                    japaneseLogisticsSpan.className = currentFaction === 'japanese' ? '' : 'hidden';
                } else {
                    console.error('japanese-logistics-score element not found in DOM');
                }
                document.getElementById('pass-section').style.display = 'flex';




                alliedUsePassButton.disabled = faction.passes === 0;
                japaneseUsePassButton.disabled = faction.passes === 0;
                if (nextTurnButton) nextTurnButton.disabled = faction.hand.length > 0;
                if (undoButton) undoButton.disabled = faction.stateHistory.length === 0;

                if (!saveGameButton || !loadGameButton || !loadGameInput) {
                    console.error('save-game, load-game, or load-game-input not found in DOM');
                    return;
                }

                if (isGameStarted) {
                    mainScreen.style.display = 'none';
                    gameContainer.style.display = 'block';
                    turnDisplay.style.display = 'block';
                    passDisplay.style.display = 'block';
                    inputsDiv.style.display = currentFaction === 'japanese' ? 'flex' : 'none';
                    alliedInputs.style.display = currentFaction === 'allied' ? 'flex' : 'none';
                    if (nextTurnButton) nextTurnButton.style.display = 'inline-block';
                    if (undoButton) undoButton.style.display = 'inline-block';
                    if (restartButton) restartButton.style.display = 'inline-block';
                    if (saveGameButton) saveGameButton.style.display = 'inline-block';
                    if (loadGameButton) loadGameButton.style.display = 'inline-block';
                    if (loadGameInput) loadGameInput.style.display = 'none';

                    // language-toggle을 control-buttons로 이동
                    if (languageToggle && startGameContainer.contains(languageToggle)) {
                        startGameContainer.removeChild(languageToggle);
                        controlButtons.appendChild(languageToggle);
                    } else if (!controlButtons.contains(languageToggle)) {
                        controlButtons.appendChild(languageToggle);
                    }
                } else {
                    mainScreen.style.display = 'flex';
                    gameContainer.style.display = 'none';
                    turnDisplay.style.display = 'none';
                    document.getElementById('pass-section').style.display = 'none';
                    passDisplay.style.display = 'none';
                    inputsDiv.style.display = 'none';
                    alliedInputs.style.display = 'none';
                    if (nextTurnButton) nextTurnButton.style.display = 'none';
                    if (undoButton) undoButton.style.display = 'none';
                    if (restartButton) restartButton.style.display = 'none';
                    if (saveGameButton) saveGameButton.style.display = 'none';
                    if (loadGameButton) loadGameButton.style.display = 'none';
                    if (loadGameInput) loadGameInput.style.display = 'none';

                    // language-toggle을 start-game-container로 이동
                    if (languageToggle && controlButtons.contains(languageToggle)) {
                        controlButtons.removeChild(languageToggle);
                        startGameContainer.appendChild(languageToggle);
                    } else if (!startGameContainer.contains(languageToggle)) {
                        startGameContainer.appendChild(languageToggle);
                    }
                }

                if (currentFaction === 'allied' && faction.currentTurn === 1) {
                    messageDiv.textContent = lang.alliedTurn1Message;
                } else {
                    messageDiv.textContent = '';
                }

                const isHistoricalModalVisible = historicalModal && historicalModal.style.display === 'block';
                console.log('Before updateHandDisplay:', historicalModalYes?.textContent, historicalModalNo?.textContent);
                updateHandDisplay();
                console.log('After updateHandDisplay:', historicalModalYes?.textContent, historicalModalNo?.textContent);
                console.log('Before updateFutureDisplay:', historicalModalYes?.textContent, historicalModalNo?.textContent);
                updateFutureDisplay();
                console.log('After updateFutureDisplay:', historicalModalYes?.textContent, historicalModalNo?.textContent);

                // 수정: historical-modal 표시 중에는 updateDiscardModal, updateRemovedModal 호출 제한
                if (!isHistoricalModalVisible) {
                    console.log('Before updateDiscardModal:', historicalModalYes?.textContent, historicalModalNo?.textContent);
                    updateDiscardModal();
                    console.log('After updateDiscardModal:', historicalModalYes?.textContent, historicalModalNo?.textContent);
                    console.log('Before updateRemovedModal:', historicalModalYes?.textContent, historicalModalNo?.textContent);
                    updateRemovedModal();
                    console.log('After updateRemovedModal:', historicalModalYes?.textContent, historicalModalNo?.textContent);
                } else {
                    console.log('Skipped updateDiscardModal and updateRemovedModal due to historical-modal visibility');
                }

                updateHandDisplay();
                updateFutureDisplay();
                updateDiscardModal();
                updateRemovedModal();
                updateDeckRemainingDisplay();
                discardModal.style.display = 'none';
                removedModal.style.display = 'none';
                if (historicalModalYes && historicalModalYes.textContent !== lang.yes) {
                    console.warn('historicalModalYes text overwritten in updateUI:', historicalModalYes.textContent, new Error().stack);
                    historicalModalYes.textContent = lang.yes;
                }
                if (historicalModalNo && historicalModalNo.textContent !== lang.no) {
                    console.warn('historicalModalNo text overwritten in updateUI:', historicalModalNo.textContent, new Error().stack);
                    historicalModalNo.textContent = lang.no;
                }
            }


            discardPileDiv.addEventListener('click', () => {
                discardModal.style.display = 'block';
                updateDiscardModal();
            });

            discardModalClose.addEventListener('click', () => {
                discardModal.style.display = 'none';
            });

            discardModal.addEventListener('click', (e) => {
                if (e.target === discardModal) {
                    discardModal.style.display = 'none';
                }
            });

            removedPileDiv.addEventListener('click', () => {
                removedModal.style.display = 'block';
                updateRemovedModal();
            });

            removedModalClose.addEventListener('click', () => {
                removedModal.style.display = 'none';
            });

            removedModal.addEventListener('click', (e) => {
                if (e.target === removedModal) {
                    removedModal.style.display = 'none';
                }
            });


            function toggleLanguage() {
                isEnglish = !isEnglish;
                const lang = isEnglish ? languageData.en : languageData.ko;
                console.log(`Language toggled: isEnglish=${isEnglish}, lang.logisticsScore=${lang.logisticsScore}`);

                // 즉시 병참 평가 및 패스 갱신
                const alliedLogisticsSpan = document.getElementById('allied-logistics-score');
                const japaneseLogisticsSpan = document.getElementById('japanese-logistics-score');
                const passDisplay = document.getElementById('pass-display');
                const turnDisplay = document.getElementById('turn-display');
                if (alliedLogisticsSpan) {
                    alliedLogisticsSpan.textContent = `${lang.logisticsScore}${factions.allied.logisticsScore}`;
                    alliedLogisticsSpan.className = currentFaction === 'allied' ? '' : 'hidden';
                    console.log(`Toggled allied logistics score: ${alliedLogisticsSpan.textContent}`);
                } else {
                    console.error('allied-logistics-score element not found in DOM');
                }
                if (japaneseLogisticsSpan) {
                    japaneseLogisticsSpan.textContent = `${lang.logisticsScore}${factions.japanese.logisticsScore}`;
                    japaneseLogisticsSpan.className = currentFaction === 'japanese' ? '' : 'hidden';
                    console.log(`Toggled japanese logistics score: ${japaneseLogisticsSpan.textContent}`);
                } else {
                    console.error('japanese-logistics-score element not found in DOM');
                }
                if (passDisplay) {
                    passDisplay.textContent = `${lang.passDisplay}${factions[currentFaction].passes}`;
                    console.log(`Toggled pass display: ${passDisplay.textContent}`);
                } else {
                    console.error('pass-display element not found in DOM');
                }
                if (turnDisplay) {
                    turnDisplay.textContent = `${lang.turnDisplay}${factions[currentFaction].currentTurn}`;
                    console.log(`Toggled turn display: ${turnDisplay.textContent}`);
                } else {
                    console.error('turn-display element not found in DOM');
                }

                // 버튼 및 기타 UI 요소 갱신
                if (saveGameButton) saveGameButton.textContent = lang.saveGame;
                if (loadGameButton) loadGameButton.textContent = lang.loadGame;
                if (discardModalClose) discardModalClose.textContent = lang.close;
                if (removedModalClose) removedModalClose.textContent = lang.close;

                // 전체 UI 갱신
                setTimeout(() => {
                    updateUI();
                    updateHandDisplay();
                    updateFutureDisplay();
                    updateDiscardModal();
                    updateRemovedModal();
                    updateDeckRemainingDisplay();
                }, 0);
            }

            function calculateLogisticsScore(factionType) {
                const faction = factions[factionType];
                let score = 0;
                faction.hand.forEach(card => {
                    console.log(`Calculating logistics for ${factionType}: cardId=${card.id}, type=${card.type}, oc=${card.oc}, logistics=${card.logistics}, condition=${card.condition}`);
                    if (card.type !== 1) {
                        score += card.oc;
                    } else {
                        if (card.condition === 0) {
                            score += card.logistics;
                        } else {
                            const logisticsMinusOne = card.logistics - 1;
                            score += logisticsMinusOne < card.oc ? card.oc : logisticsMinusOne;
                        }
                    }
                });
                faction.logisticsScore = score;
                console.log(`${factionType} logistics score: ${score}`);
                return score;
            }


            function setLanguage(isEnglishMode) {
                isEnglish = isEnglishMode;
                const lang = isEnglish ? languageData.en : languageData.ko;
                console.log(`setLanguage: isEnglish=${isEnglish}, lang.logisticsScore=${lang.logisticsScore}`);
                
                // 패스 및 병참 평가 UI 갱신
                const faction = factions[currentFaction];
                passDisplay.textContent = `${lang.passDisplay}${faction.passes || 0}`;
                const logisticsScore = calculateLogisticsScore(faction.hand || []);
                document.getElementById('logistics-score').textContent = `${lang.logisticsScore}${logisticsScore}`;
                
                // 손패 UI 갱신
                updateHandDisplay();
            }


            function drawCards(factionType) {
                saveState();
                const faction = factions[factionType];
                const lang = isEnglish ? languageData.en : languageData.ko;
                let baseCards = 0;
                let finalCardsToDraw = 0;
                let basePasses = 0;
                let reductions = 0;
                let additionalPasses = 0;

                if (factionType === 'allied') {
                    if (faction.currentTurn === 1) {
                        baseCards = 0;
                        basePasses = 0;
                    } else if (faction.currentTurn === 2) {
                        baseCards = 5;
                        basePasses = 2;
                    } else if (faction.currentTurn === 3) {
                        baseCards = 6;
                        basePasses = 1;
                    } else {
                        baseCards = 7;
                        basePasses = 0;
                    }

                    const wieLevel = parseInt(document.getElementById('wie-level').value) || 0;
                    const chinaSurrender = document.getElementById('china-surrender').checked;
                    const indiaSurrender = document.getElementById('india-surrender').checked;
                    const australiaSurrender = document.getElementById('australia-surrender').checked;
                    reductions = (wieLevel === 4 ? 1 : 0) + (chinaSurrender ? 1 : 0) + (indiaSurrender ? 1 : 0) + (australiaSurrender ? 1 : 0);
                    finalCardsToDraw = Math.max(4, baseCards - reductions);
                    additionalPasses = reductions;
                    faction.passes = Math.min(2, basePasses + additionalPasses);

                    messageDiv.textContent = lang.alliedDrawMessage(finalCardsToDraw, faction.currentTurn, baseCards, wieLevel, chinaSurrender, indiaSurrender, australiaSurrender, reductions, faction.passes);
                    setTimeout(() => { messageDiv.textContent = ''; }, 5000);

                    let cardsDrawn = 0;
                    if (faction.currentTurn === 1) {
                        faction.hand = [];
                        cardsDrawn = 0;
                    } else {
                        if (faction.currentTurn === 2 && drawArcadia) {
                            const arcadiaCard = faction.deck.find(card => card.id === 'AL Card 4');
                            if (arcadiaCard) {
                                faction.hand.push(arcadiaCard);
                                faction.deck = faction.deck.filter(card => card.id !== 'AL Card 4');
                                cardsDrawn++;
                            }
                        }
                        faction.deck = shuffle(faction.deck); // 추가된 코드: 랜덤성을 위해 덱 셔플
                        while (cardsDrawn < finalCardsToDraw) {
                            if (faction.deck.length === 0) {
                                if (faction.discardPile.length === 0) {
                                    messageDiv.textContent = lang.noCardsMessage(finalCardsToDraw - cardsDrawn);
                                    break;
                                }
                                faction.deck = faction.discardPile.slice();
                                faction.discardPile = [];
                                shuffle(faction.deck);
                                messageDiv.textContent = lang.shuffleMessage;
                                setTimeout(() => { messageDiv.textContent = ''; }, 5000);
                                updateDiscardModal();
                            }
                            faction.hand.push(faction.deck.pop());
                            cardsDrawn++;
                        }
                        // 카드 종류(1,2,5,3) 순, 같은 종류 내에서 OC 내림차순 정렬
                        faction.hand.sort((a, b) => {
                            const typeOrder = { '1': 1, '2': 2, '5': 3, '3': 4 };
                            if (typeOrder[a.type] !== typeOrder[b.type]) {
                                return typeOrder[a.type] - typeOrder[b.type];
                            }
                            return b.oc - a.oc;
                        });
                    }
                } else {
                    const resourceHexes = Math.min(14, parseInt(document.getElementById('resource-hexes').value) || 0);
                    const submarineSuccess = document.getElementById('submarine-success').checked;
                    const bombingSuccesses = parseInt(document.getElementById('bombing-successes').value) || 0;
                    reductions = (submarineSuccess ? 1 : 0) + Math.min(2, bombingSuccesses);

                    if (faction.currentTurn === 1) {
                        baseCards = 2;
                        finalCardsToDraw = 2;
                    } else if (faction.currentTurn >= 2 && faction.currentTurn <= 4) {
                        baseCards = 7;
                        finalCardsToDraw = Math.max(4, baseCards - reductions);
                    } else {
                        baseCards = Math.max(4, Math.ceil(resourceHexes / 2));
                        finalCardsToDraw = Math.max(4, baseCards - reductions);
                    }

                    faction.passes = faction.currentTurn === 1 ? 0 : finalCardsToDraw === 6 ? 1 : finalCardsToDraw <= 5 ? 2 : 0;

                    messageDiv.textContent = lang.japaneseDrawMessage(finalCardsToDraw, faction.currentTurn, baseCards, submarineSuccess, bombingSuccesses, reductions, faction.passes);
                    setTimeout(() => { messageDiv.textContent = ''; }, 5000);

                    let cardsDrawn = 0;
                    if (faction.currentTurn === 1 && factionType === 'japanese') {
                        const prefix = 'JP Card';
                        faction.hand = faction.deck.filter(card => card.id === `${prefix} 1` || card.id === `${prefix} 2`);
                        faction.deck = faction.deck.filter(card => card.id !== `${prefix} 1` && card.id !== `${prefix} 2`);
                        cardsDrawn = faction.hand.length;
                    } else {
                        faction.deck = shuffle(faction.deck); // 추가된 코드: 랜덤성을 위해 덱 셔플
                        while (cardsDrawn < finalCardsToDraw) {
                            if (faction.deck.length === 0) {
                                if (faction.discardPile.length === 0) {
                                    messageDiv.textContent = lang.noCardsMessage(finalCardsToDraw - cardsDrawn);
                                    break;
                                }
                                faction.deck = faction.discardPile.slice();
                                faction.discardPile = [];
                                shuffle(faction.deck);
                                messageDiv.textContent = lang.shuffleMessage;
                                setTimeout(() => { messageDiv.textContent = ''; }, 5000);
                                updateDiscardModal();
                            }
                            faction.hand.push(faction.deck.pop());
                            cardsDrawn++;
                        }
                        // 카드 종류(1,2,5,3) 순, 같은 종류 내에서 OC 내림차순 정렬
                        faction.hand.sort((a, b) => {
                            const typeOrder = { '1': 1, '2': 2, '5': 3, '3': 4 };
                            if (typeOrder[a.type] !== typeOrder[b.type]) {
                                return typeOrder[a.type] - typeOrder[b.type];
                            }
                            return b.oc - a.oc;
                        });
                    }
                }

                passDisplay.textContent = `${lang.passDisplay}${faction.passes}`;
                calculateLogisticsScore(factionType);
                const logisticsSpan = document.getElementById(`${factionType}-logistics-score`);
                if (logisticsSpan) {
                    console.log(`Setting ${factionType} logistics score: lang.logisticsScore=${lang.logisticsScore}, score=${faction.logisticsScore}`);
                    logisticsSpan.textContent = `${lang.logisticsScore}${faction.logisticsScore}`;
                } else {
                    console.error(`${factionType}-logistics-score element not found in DOM`);
                }
                alliedUsePassButton.disabled = faction.passes === 0;
                japaneseUsePassButton.disabled = faction.passes === 0;

                updateHandDisplay();
                updateDeckRemainingDisplay();
                alliedDrawButton.disabled = faction.hand.length > 0 || (factionType === 'allied' && faction.currentTurn === 1);
                japaneseDrawButton.disabled = (faction.hand.length > 0 && factionType === 'japanese') || 
                                            (factionType === 'japanese' && faction.currentTurn === 1 && faction.cardsPlayedTurn1 && faction.cardsPlayedTurn1.length > 0);
                checkNextTurn();
            }






            function handleArcadiaModal(choice) {
                const arcadiaModal = document.getElementById('arcadia-modal');
                drawArcadia = choice;
                arcadiaModal.style.display = 'none';
                drawCards('allied');
            }


            alliedDrawButton.addEventListener('click', () => drawCards('allied'));
            japaneseDrawButton.addEventListener('click', () => drawCards('japanese'));

            alliedUsePassButton.addEventListener('click', () => usePass('allied'));
            japaneseUsePassButton.addEventListener('click', () => usePass('japanese'));

            function usePass(factionType) {
                const faction = factions[factionType];
                const lang = isEnglish ? languageData.en : languageData.ko;
                if (faction.passes > 0) {
                    saveState();
                    faction.passes--;
                    passDisplay.textContent = `${lang.passDisplay}${faction.passes}`;
                    alliedUsePassButton.disabled = faction.passes === 0;
                    japaneseUsePassButton.disabled = faction.passes === 0;
                    messageDiv.textContent = lang.passMessage;
                    setTimeout(() => { messageDiv.textContent = ''; }, 3000);
                }
            }

            if (nextTurnButton) {
                nextTurnButton.addEventListener('click', () => {
                    const faction = factions[currentFaction];
                    const lang = isEnglish ? languageData.en : languageData.ko;
                    if (faction.hand.length === 0) {
                        saveState();
                        nextTurnButton.style.background = '#5b5e60';
                        nextTurnButton.style.transform = 'scale(0.95)';
                        setTimeout(() => {
                            nextTurnButton.style.background = '#6b6e70';
                            nextTurnButton.style.transform = 'scale(1)';
                        }, 200);

                        if (faction.needReshuffle) {
                            faction.deck = faction.deck.concat(faction.discardPile);
                            faction.discardPile = [];
                            shuffle(faction.deck);
                            faction.needReshuffle = false;
                            messageDiv.textContent = lang.reshuffleMessage;
                            setTimeout(() => { messageDiv.textContent = ''; }, 3000);
                            updateDiscardModal();
                            updateDeckRemainingDisplay();
                        }

                        if (faction.currentTurn === 12) {
                            gameOverModal.textContent = lang.gameOverMessage;
                            gameOverModal.style.display = 'block';
                            setTimeout(() => {
                                gameOverModal.style.display = 'none';
                                resetGame();
                            }, 3000);
                        } else {
                            window.scrollTo(0, 0);
                            faction.currentTurn++;
                            faction.eventCardsDrawnThisTurn = 0;
                            if (currentFaction === 'japanese') {
                                faction.cardsPlayedTurn1 = [];
                            }
                            turnDisplay.textContent = `${lang.turnDisplay}${faction.currentTurn}`;
                            alliedDrawButton.disabled = currentFaction === 'allied' && (faction.hand.length > 0 || faction.currentTurn === 1);
                            japaneseDrawButton.disabled = currentFaction === 'japanese' && faction.hand.length > 0;
                            faction.hand = [];
                            updateHandDisplay();
                            updateDeckRemainingDisplay();

                            if (currentFaction === 'japanese' && faction.currentTurn === 2 && !isHistoricalOpening) {
                                const historicalModalYes = document.getElementById('historical-modal-yes');
                                const historicalModalNo = document.getElementById('historical-modal-no');
                                historicalModal.style.display = 'block';
                                // 수정: 모달 표시 시 텍스트 즉시 설정
                                historicalModalContent.textContent = lang.historicalModal;
                                if (historicalModalYes) {
                                    historicalModalYes.textContent = lang.yes;
                                    console.log('Set historicalModalYes (nextTurn):', historicalModalYes.textContent);
                                } else {
                                    console.warn('historical-modal-yes not found in DOM (nextTurn)');
                                }
                                if (historicalModalNo) {
                                    historicalModalNo.textContent = lang.no;
                                    console.log('Set historicalModalNo (nextTurn):', historicalModalNo.textContent);
                                } else {
                                    console.warn('historical-modal-no not found in DOM (nextTurn)');
                                }
                                // 덮어씯우기 방지: 지연 텍스트 재설정
                                setTimeout(() => {
                                    if (historicalModalYes && historicalModalYes.textContent !== lang.yes) {
                                        console.warn('historicalModalYes text overwritten (nextTurn):', historicalModalYes.textContent, new Error().stack);
                                        historicalModalYes.textContent = lang.yes;
                                    }
                                    if (historicalModalNo && historicalModalNo.textContent !== lang.no) {
                                        console.warn('historicalModalNo text overwritten (nextTurn):', historicalModalNo.textContent, new Error().stack);
                                        historicalModalNo.textContent = lang.no;
                                    }
                                }, 200);
                            } else if (currentFaction === 'allied' && faction.currentTurn === 2) {
                                const arcadiaModal = document.getElementById('arcadia-modal');
                                const arcadiaModalContent = document.getElementById('arcadia-modal-content');
                                const arcadiaYes = document.getElementById('arcadia-yes');
                                const arcadiaNo = document.getElementById('arcadia-no');
                                arcadiaModalContent.textContent = lang.arcadiaModalMessage;
                                arcadiaYes.textContent = lang.arcadiaYes;
                                arcadiaNo.textContent = lang.arcadiaNo;
                                arcadiaModal.style.display = 'block';
                                arcadiaYes.onclick = () => handleArcadiaModal(true);
                                arcadiaNo.onclick = () => handleArcadiaModal(false);
                            } else {
                                turnModal.textContent = lang.turnModalMessage(faction.currentTurn);
                                turnModal.style.display = 'block';
                                setTimeout(() => {
                                    turnModal.style.display = 'none';
                                }, 2000);
                                if (!(currentFaction === 'allied' && faction.currentTurn === 1)) {
                                    drawCards(currentFaction);
                                }
                            }
                            updateUI();
                        }
                    }
                });
            }

            if (historicalModalYes) {
                historicalModalYes.addEventListener('click', () => {
                    isHistoricalOpening = true;
                    historicalModal.style.display = 'none';
                    drawHistoricalOpeningCards('japanese');
                    updateHandDisplay();
                    updateDeckRemainingDisplay();
                });
            }
            if (historicalModalNo) {
                historicalModalNo.addEventListener('click', () => {
                    isHistoricalOpening = false;
                    historicalModal.style.display = 'none';
                    drawCards('japanese', 7);
                    updateHandDisplay();
                    updateDeckRemainingDisplay();
                });
            }

            if (undoButton) {
                undoButton.addEventListener('click', () => {
                    undoButton.style.background = '#5b5e60';
                    undoButton.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        undoButton.style.background = '#6b6e70';
                        undoButton.style.transform = 'scale(1)';
                    }, 200);
                    undo();
                });
            }

            if (restartButton) {
                restartButton.addEventListener('click', () => {
                    restartButton.style.background = '#5b5e60';
                    restartButton.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        restartButton.style.background = '#6b6e70';
                        restartButton.style.transform = 'scale(1)';
                    }, 200);
                    resetGame();
                });
            }

            function drawHistoricalOpeningCards(faction) {
                const deck = factions[faction].deck;
                const hand = [];
                const historicalCards = ['JP Card 3', 'JP Card 47', 'JP Card 59']; // 카드 ID 수정

                // 디버깅: 덱 상태 확인
                console.log(`Deck for ${faction}:`, deck ? deck.map(card => card.id) : 'undefined');
                
                // 덱 유효성 확인
                if (!deck || !Array.isArray(deck)) {
                    console.error(`Deck for ${faction} is undefined or not an array`);
                    return;
                }

                // #3, #47, #59 카드 선택
                historicalCards.forEach(cardId => {
                    const index = deck.findIndex(card => card.id === cardId);
                    if (index !== -1) {
                        hand.push(deck[index]);
                        deck.splice(index, 1);
                    } else {
                        console.error(`Card ${cardId} not found in deck`);
                    }
                });

                // 나머지 4장 랜덤 뽑기
                const shuffledDeck = shuffle(deck);
                if (shuffledDeck && Array.isArray(shuffledDeck)) {
                    const remainingCards = shuffledDeck.slice(0, 4);
                    factions[faction].hand = hand.concat(remainingCards);
                    factions[faction].deck = deck.filter(card => !remainingCards.includes(card));
                } else {
                    console.error('Shuffled deck is undefined or not an array');
                }

                // 디버깅: 최종 손패 확인
                console.log(`Japanese hand after draw:`, factions[faction].hand.map(card => card.id));
            }

            function drawOneCard(faction) {
                if (!factions[faction].deck) {
                    console.error(`No deck for faction: ${faction}`);
                    return false;
                }

                // 덱이 비었을 때 discardPile을 셔플하여 덱으로 변환
                if (factions[faction].deck.length === 0) {
                    if (factions[faction].discardPile.length === 0) {
                        console.warn(`No cards in deck or discard pile for ${faction}`);
                        return false;
                    }
                    factions[faction].deck = [...factions[faction].discardPile];
                    factions[faction].discardPile = [];
                    // Fisher-Yates 셔플
                    for (let i = factions[faction].deck.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [factions[faction].deck[i], factions[faction].deck[j]] = [factions[faction].deck[j], factions[faction].deck[i]];
                    }
                    console.log(`Deck reshuffled for ${faction}:`, factions[faction].deck); // 디버깅 로그
                }

                // 플래그 동적 설정
                const isArcadiaModalActive = document.getElementById('arcadia-modal')?.style.display !== 'none'; // 아카디아 모달 표시 여부
                const isHistoricalVariant = window.gameSettings?.historicalVariant || false; // 실제 구현에 따라 수정 필요
                console.log(`isArcadiaModalActive: ${isArcadiaModalActive}, isHistoricalVariant: ${isHistoricalVariant}`); // 디버깅 로그
                let drawnCard;

                if (faction === 'allied' && isArcadiaModalActive) {
                    // 아카디아 회담 선택 시 AL Card 80 + 81~84번 중 하나
                    console.log(`Arcadia draw for allied`);
                    const arcadiaCards = factions[faction].deck.filter(card => {
                        const cardNumber = parseInt(card.id.split(' ')[2], 10);
                        return cardNumber >= 80 && cardNumber <= 84;
                    });
                    if (arcadiaCards.length > 0) {
                        const randomIndex = Math.floor(Math.random() * arcadiaCards.length);
                        drawnCard = arcadiaCards[randomIndex];
                        factions[faction].deck = factions[faction].deck.filter(c => c !== drawnCard);
                    } else {
                        // 아카디아 카드 없으면 랜덤 드로우
                        const randomIndex = Math.floor(Math.random() * factions[faction].deck.length);
                        drawnCard = factions[faction].deck.splice(randomIndex, 1)[0];
                    }
                } else if (faction === 'japanese' && isHistoricalVariant) {
                    // 역사적 변형 규칙 선택 시 JP Card 80~86번 중 하나
                    console.log(`Historical variant draw for japanese`);
                    const variantCards = factions[faction].deck.filter(card => {
                        const cardNumber = parseInt(card.id.split(' ')[2], 10);
                        return cardNumber >= 80 && cardNumber <= 86;
                    });
                    if (variantCards.length > 0) {
                        const randomIndex = Math.floor(Math.random() * variantCards.length);
                        drawnCard = variantCards[randomIndex];
                        factions[faction].deck = factions[faction].deck.filter(c => c !== drawnCard);
                    } else {
                        // 변형 카드 없으면 랜덤 드로우
                        const randomIndex = Math.floor(Math.random() * factions[faction].deck.length);
                        drawnCard = factions[faction].deck.splice(randomIndex, 1)[0];
                    }
                } else {
                    // 그 외 완전 랜덤 드로우
                    const randomIndex = Math.floor(Math.random() * factions[faction].deck.length);
                    drawnCard = factions[faction].deck.splice(randomIndex, 1)[0];
                    console.log(`Random card drawn for ${faction}:`, drawnCard); // 디버깅 로그
                }

                factions[faction].hand.push(drawnCard);
                console.log(`Hand after draw for ${faction}:`, factions[faction].hand); // 디버깅 로그
                updateHandDisplay();
                updateDeckRemainingDisplay();
                return true;
            }

            // function createCardElem(card, clickHandler) {
            //     const cardElem = document.createElement('div');
            //     cardElem.classList.add('card');
            //     const placeholder = document.createElement('div');
            //     placeholder.classList.add('placeholder');
            //     placeholder.textContent = isEnglish ? 'Loading image...' : '이미지 로드 중...';
            //     cardElem.appendChild(placeholder);

            //     const img = document.createElement('img');
            //     img.alt = card.id;
            //     img.src = card.image;
            //     console.log(`이미지 로드 시도: ${card.id}, 경로: ${img.src}`);
            //     img.onerror = () => {
            //         img.src = placeholderImage;
            //         console.log(`이미지 로드 실패, 플레이스홀더 사용: ${card.id}, 경로: ${img.src}`);
            //     };
            //     img.onload = () => {
            //         cardElem.removeChild(placeholder);
            //         img.classList.add('loaded');
            //         cardElem.appendChild(img);
            //     };
            //     img.addEventListener('contextmenu', (e) => e.preventDefault());
            //     if (clickHandler) {
            //         cardElem.addEventListener('click', clickHandler);
            //     }
            //     return cardElem;
            // }

            function createCardElem(card, clickHandler) {
                const cardElem = document.createElement('div');
                cardElem.classList.add('card');
                const placeholder = document.createElement('div');
                placeholder.classList.add('placeholder');
                placeholder.textContent = isEnglish ? 'Loading image...' : '이미지 로드 중...';
                cardElem.appendChild(placeholder);

                const img = document.createElement('img');
                img.alt = card.id;
                img.src = card.image;
                console.log(`이미지 로드 시도: ${card.id}, 경로: ${img.src}`);
                img.onerror = () => {
                    img.src = placeholderImage;
                    console.log(`이미지 로드 실패, 플레이스홀더 사용: ${card.id}, 경로: ${img.src}`);
                };
                img.onload = () => {
                    cardElem.removeChild(placeholder);
                    img.classList.add('loaded');
                    cardElem.appendChild(img);
                };
                img.addEventListener('contextmenu', (e) => e.preventDefault());

                let touchTimer;
                let isDragging = false;
                let startX, startY;

                // 터치 시작: 500ms 타이머 설정
                cardElem.addEventListener('touchstart', (e) => {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    touchTimer = setTimeout(() => {
                        isDragging = true;
                        console.log('Drag started:', card.id);
                        // 드래그 로직 시작 (필요 시 별도 handleDrag 함수 호출)
                        // 예: cardElem.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                    }, 500); // 500ms 지연
                });

                // 터치 이동: 드래그 활성화 시 처리
                cardElem.addEventListener('touchmove', (e) => {
                    if (isDragging) {
                        const deltaX = e.touches[0].clientX - startX;
                        const deltaY = e.touches[0].clientY - startY;
                        if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) { // 이동 거리 임계값
                            console.log('Dragging:', card.id, `dx=${deltaX}, dy=${deltaY}`);
                            // 드래그 로직 (기존 handleDrag가 있다면 호출)
                            // 예: cardElem.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        }
                    }
                });

                // 터치 종료: 클릭 또는 드래그 처리
                cardElem.addEventListener('touchend', (e) => {
                    clearTimeout(touchTimer);
                    if (!isDragging) {
                        console.log('Card clicked:', card.id);
                        if (clickHandler) clickHandler(); // 짧은 터치 → 클릭
                    }
                    isDragging = false;
                });

                // 데스크톱 클릭 유지
                if (clickHandler) {
                    cardElem.addEventListener('click', () => {
                        console.log('Card clicked (desktop):', card.id);
                        clickHandler();
                    });
                }

                return cardElem;
            }


            function updateHandDisplay() {
                const faction = factions[currentFaction];
                const lang = isEnglish ? languageData.en : languageData.ko;
                handDiv.innerHTML = '';

                const createCardElement = (card, index) => {
                    const cardDiv = document.createElement('div');
                    cardDiv.classList.add('card');
                    cardDiv.id = `card-${index}`;
                    const cardImg = document.createElement('img');
                    const factionPrefix = card.id.startsWith('AL') ? 'al' : 'jp';
                    cardImg.src = getValidImagePath(factionPrefix, card.id.split(' ')[2], false);
                    console.log(`updateHandDisplay: cardId=${card.id}, factionPrefix=${factionPrefix}, path=${cardImg.src}`);
                    cardImg.alt = card.id;
                    cardImg.addEventListener('click', () => {
                        enlargeCard(index);
                    });
                    cardImg.addEventListener('contextmenu', (e) => e.preventDefault());
                    cardImg.onerror = () => {
                        console.log(`Image load failure for ${card.id}, path: ${cardImg.src}`);
                        // 플레이스홀더 대신 빈 이미지 또는 기본 카드 이미지
                        cardImg.src = ''; // 빈 문자열로 설정해 에러 방지
                        cardImg.onerror = null; // 무한 루프 방지
                        console.warn(`Failed to load ${card.id}, check file: card_image/jp/47.png`);
                    };
                    cardDiv.appendChild(cardImg);
                    return cardDiv;
                };

                if (faction.hand.length > 0) {
                    faction.hand.forEach((card, index) => {
                        const cardDiv = createCardElement(card, index);
                        handDiv.appendChild(cardDiv);
                    });
                    const title = document.createElement('h2');
                    title.textContent = lang.hand;
                    handDiv.insertBefore(title, handDiv.firstChild);
                }

                // 진영별 병참 평가 점수 업데이트
                calculateLogisticsScore(currentFaction);
                const logisticsSpan = document.getElementById(`${currentFaction}-logistics-score`);
                const otherFaction = currentFaction === 'allied' ? 'japanese' : 'allied';
                const otherLogisticsSpan = document.getElementById(`${otherFaction}-logistics-score`);
                if (logisticsSpan) {
                    console.log(`Updating ${currentFaction} logistics score: lang.logisticsScore=${lang.logisticsScore}, score=${faction.logisticsScore}`);
                    logisticsSpan.textContent = `${lang.logisticsScore}${faction.logisticsScore}`;
                    logisticsSpan.className = ''; // 표시
                    
                } else {
                    console.error(`${currentFaction}-logistics-score element not found in DOM`);
                }
                if (otherLogisticsSpan) {
                    otherLogisticsSpan.className = 'hidden'; // 상대 진영 숨김
                }
            }


            function updateFutureDisplay() {
                futureHandDiv.innerHTML = '';
                const faction = factions[currentFaction];
                if (faction.futureOffensive) {
                    const cardElem = createCardElem(faction.futureOffensive, enlargeFutureCard);
                    futureHandDiv.appendChild(cardElem);
                }
            }

            function updateDeckRemainingDisplay() {
                const lang = isEnglish ? languageData.en : languageData.ko;
                deckRemainingDiv.textContent = `${lang.deckRemaining}${factions[currentFaction].deck.length}${isEnglish ? '' : '장'}`;
            }

            function updateDiscardModal() {
                discardModalContent.innerHTML = '';
                factions[currentFaction].discardPile.forEach((card, index) => {
                    const cardElem = createCardElem(card, () => enlargeDiscardCard(index));
                    discardModalContent.appendChild(cardElem);
                });
            }

            function updateRemovedModal() {
                removedModalContent.innerHTML = '';
                factions[currentFaction].removedCards.forEach((card, index) => {
                    const cardElem = createCardElem(card, () => enlargeRemovedCard(index));
                    removedModalContent.appendChild(cardElem);
                });
            }

            function enlargeCard(index) {
                if (enlargedCard) return;

                const faction = currentFaction;
                if (!factions[faction]) {
                    console.error(`Invalid faction: ${faction}`);
                    return;
                }
                const lang = isEnglish ? languageData.en : languageData.ko;
                const card = factions[faction].hand[index];
                if (!card) {
                    console.warn(`Card at index ${index} not found in ${faction} hand`);
                    return;
                }

                console.log(`Enlarging card: faction=${faction}, cardId=${card.id}, index=${index}, card=${JSON.stringify(card)}`);

                enlargedCard = document.createElement('div');
                enlargedCard.classList.add('enlarged');
                const placeholder = document.createElement('div');
                placeholder.classList.add('placeholder');
                placeholder.textContent = isEnglish ? 'Loading enlarged image...' : '확대 이미지 로드 중...';
                enlargedCard.appendChild(placeholder);

                const img = document.createElement('img');
                img.alt = card.id;
                const factionPrefix = card.id.startsWith('AL') ? 'allied' : 'jp';
                const cardNumber = parseInt(card.id.split(' ')[2], 10);
                img.src = getValidImagePath(factionPrefix, cardNumber, true);
                console.log(`확대 이미지 로드 시도: ${card.id}, 경로: ${img.src}`);

                img.onerror = () => {
                    img.src = getValidImagePath(factionPrefix, cardNumber, false);
                    console.log(`확대 이미지 로드 실패, 원본 사용: ${card.id}, 경로: ${img.src}`);
                };
                
                img.onload = () => {
                    enlargedCard.removeChild(placeholder);
                    img.classList.add('loaded');
                    enlargedCard.appendChild(img);
                    document.body.appendChild(enlargedCard);
                };
                img.addEventListener('contextmenu', (e) => e.preventDefault());

                const buttonDiv = document.createElement('div');
                buttonDiv.classList.add('enlarged-buttons');

                const isSpecialJapaneseCard = faction === 'japanese' && (card.id === 'JP Card 1' || card.id === 'JP Card 2');

                const ocButton = document.createElement('button');
                ocButton.textContent = lang.ocButton;
                ocButton.disabled = isSpecialJapaneseCard; // JP Card 1, 2에서는 OC 버튼 비활성화
                ocButton.addEventListener('click', () => {
                    saveState();
                    factions[faction].discardPile.push(factions[faction].hand.splice(index, 1)[0]);
                    updateDiscardModal();
                    closeEnlarged();
                    updateHandDisplay();
                    updateDeckRemainingDisplay();
                    checkNextTurn();
                    messageDiv.textContent = lang.discardMessage;
                    // setTimeout(() => { messageDiv.textContent = ''; }, 3000);
                    const cardNumber = parseInt(card.id.split(' ')[2], 10);
                    if ((faction === 'allied' && cardNumber === 79) || (faction === 'japanese' && cardNumber === 43)) {
                        factions[faction].needReshuffle = true;
                    }
                    if (faction === 'japanese' && factions[faction].currentTurn === 1) {
                        factions[faction].cardsPlayedTurn1.push(card.id);
                    }
                });

                const eventButton = document.createElement('button');
                eventButton.textContent = lang.eventButton;
                // 모든 카드에서 이벤트 버튼 활성화
                console.log(`eventButton: cardId=${card.id}, condition=${card.condition}, drawStrategic=${card.drawStrategic}, removeOnEvent=${card.removeOnEvent}, isSpecialJapaneseCard=${isSpecialJapaneseCard}`);
                eventButton.addEventListener('click', () => {
                    console.log(`eventButton clicked: cardId=${card.id}, condition=${card.condition}, drawStrategic=${card.drawStrategic}, removeOnEvent=${card.removeOnEvent}`);
                    saveState();
                    const drawAdditional = card.drawStrategic === 1;
                    const removeFromGame = card.removeOnEvent === 1;
                    if (drawAdditional && factions[faction].eventCardsDrawnThisTurn < 3) {
                        if (drawOneCard(faction)) {
                            messageDiv.textContent = lang.eventDrawMessage(factions[faction].eventCardsDrawnThisTurn);
                        } else {
                            messageDiv.textContent = lang.eventDrawFailMessage(
                                factions[faction].deck ? factions[faction].deck.length : 0,
                                factions[faction].discardPile ? factions[faction].discardPile.length : 0,
                                factions[faction].eventCardsDrawnThisTurn
                            );
                        }
                    } else if (drawAdditional) {
                        messageDiv.textContent = lang.eventDrawLimitMessage(factions[faction].eventCardsDrawnThisTurn);
                    }
                    if (removeFromGame) {
                        factions[faction].removedCards.push(factions[faction].hand.splice(index, 1)[0]);
                        updateRemovedModal();
                        messageDiv.textContent = messageDiv.textContent ? `${messageDiv.textContent} ${lang.removedMessage}` : lang.removedMessage;
                    } else {
                        factions[faction].discardPile.push(factions[faction].hand.splice(index, 1)[0]);
                        updateDiscardModal();
                        messageDiv.textContent = messageDiv.textContent ? `${messageDiv.textContent} ${lang.discardMessage}` : lang.discardMessage;
                    }
                    if (faction === 'japanese' && factions[faction].currentTurn === 1) {
                        factions[faction].cardsPlayedTurn1.push(card.id);
                    }
                    // setTimeout(() => { messageDiv.textContent = ''; }, 3000);
                    closeEnlarged();
                    updateHandDisplay();
                    updateDeckRemainingDisplay();
                    checkNextTurn();
                });

                const futureButton = document.createElement('button');
                futureButton.textContent = lang.futureButton;
                futureButton.disabled = isSpecialJapaneseCard || !!factions[faction].futureOffensive || 
                    (faction === 'allied' && [79].includes(cardNumber)) || 
                    (faction === 'japanese' && [43].includes(cardNumber));
                futureButton.addEventListener('click', () => {
                    if (!factions[faction].futureOffensive) {
                        saveState();
                        factions[faction].futureOffensive = factions[faction].hand.splice(index, 1)[0];
                        updateFutureDisplay();
                        closeEnlarged();
                        updateHandDisplay();
                        updateDeckRemainingDisplay();
                        checkNextTurn();
                        messageDiv.textContent = lang.futureMessage;
                        setTimeout(() => { messageDiv.textContent = ''; }, 3000);
                        if (faction === 'japanese' && factions[faction].currentTurn === 1) {
                            factions[faction].cardsPlayedTurn1.push(card.id);
                        }
                    }
                });

                // 수정: #47번으로 교체 버튼 조건 강화 (JP Card 1, 2 비활성화, 군사 공세 카드 존재 시 비활성화)
                let hasOffensiveCard = false;
                let isCard47Available = true;
                if (faction === 'japanese') {
                    try {
                        hasOffensiveCard = factions[faction].hand.some(c => {
                            const cn = parseInt(c.id.split(' ')[2], 10) - 1;
                            const props = japaneseCardProperties[cn] || '0000000';
                            if (!props) {
                                console.warn(`japaneseCardProperties missing for cardId: ${c.id}, index: ${cn}`);
                                return false;
                            }
                            console.log(`Checking offensive for ${c.id}: props=${props}`);
                            return props[0] == '1' && props[2] != '0' && props[3] != '0';
                        });
                        isCard47Available = !(
                            factions.japanese.hand.some(c => c.id === 'JP Card 47') ||
                            factions.japanese.discardPile.some(c => c.id === 'JP Card 47') ||
                            factions.japanese.removedCards.some(c => c.id === 'JP Card 47')
                        );
                        console.log(`hasOffensiveCard: ${hasOffensiveCard}, isCard47Available: ${isCard47Available}`);
                    } catch (e) {
                        console.error(`Error in hasOffensiveCard: ${e.message}`, e.stack);
                        hasOffensiveCard = false;
                        isCard47Available = false;
                    }
                }

                buttonDiv.appendChild(ocButton);
                buttonDiv.appendChild(futureButton);
                buttonDiv.appendChild(eventButton);

                
                if (faction === 'japanese' && !hasOffensiveCard && isCard47Available && card.id !== 'JP Card 1' && card.id !== 'JP Card 2') {
                    const cardNumber = parseInt(card.id.split(' ')[2], 10);
                    const props = japaneseCardProperties[cardNumber - 1] || '0000000';
                    console.log(`Card props for ${card.id} (number ${cardNumber}):`, props, `logistics=${parseInt(props[2] || 0) + parseInt(props[3] || 0)}`);
                    const hasOC3Card = factions[faction].hand.some(c => {
                        const cn = parseInt(c.id.split(' ')[2], 10) - 1;
                        const p = japaneseCardProperties[cn] || '0000000';
                        console.log(`Checking OC for ${c.id} (number ${cn + 1}): oc=${p[1]}, type=${typeof p[1]}`);
                        return p[1] == '3';
                    });
                    const hasOffensiveCardWithNonZeroLogistics = factions[faction].hand.some(c => {
                        const cn = parseInt(c.id.split(' ')[2], 10) - 1;
                        const p = japaneseCardProperties[cn] || '0000000';
                        const logistics = parseInt(p[2] || 0) + parseInt(p[3] || 0);
                        console.log(`Checking logistics for ${c.id}: props=${p}, logistics=${logistics}`);
                        return p[0] == '1' && (p[2] != '0' || p[3] != '0');
                    });
                    const cardIsOffensiveWithNonZeroLogistics = props[0] == '1' && (props[2] != '0' || props[3] != '0');
                    console.log(`hasOC3Card: ${hasOC3Card}, hasOffensiveCardWithNonZeroLogistics: ${hasOffensiveCardWithNonZeroLogistics}, cardIsOffensiveWithNonZeroLogistics: ${cardIsOffensiveWithNonZeroLogistics}`);
                    if (!hasOffensiveCardWithNonZeroLogistics && !cardIsOffensiveWithNonZeroLogistics && (props[1] == '3' || (!hasOC3Card && (props[1] == '1' || props[1] == '2')))) {
                        const replaceWith47Button = document.createElement('button');
                        replaceWith47Button.textContent = isEnglish ? 'Replace with #47' : '#47번으로 교체';
                        replaceWith47Button.addEventListener('click', () => {
                            saveState();
                            factions[faction].hand.splice(index, 1);
                            factions[faction].hand.push({
                                id: 'JP Card 47',
                                condition: 0, // 임시
                                drawStrategic: 0, // 임시
                                removeOnEvent: 0, // 임시
                                image: getValidImagePath('jp', 47, false)
                            });
                            // 카드 정렬: 공세 카드 우선, 번호순
                            factions[faction].hand.sort((a, b) => {
                                const aCn = parseInt(a.id.split(' ')[2], 10) - 1;
                                const bCn = parseInt(b.id.split(' ')[2], 10) - 1;
                                const aProps = japaneseCardProperties[aCn] || '0000000';
                                const bProps = japaneseCardProperties[bCn] || '0000000';
                                const aIsOffensive = aProps[0] == '1' ? 0 : 1;
                                const bIsOffensive = bProps[0] == '1' ? 0 : 1;
                                if (aIsOffensive !== bIsOffensive) {
                                    return aIsOffensive - bIsOffensive;
                                }
                                return aCn - bCn;
                            });
                            console.log(`Hand after replace and sort:`, factions[faction].hand.map(c => ({
                                id: c.id,
                                isOffensive: (japaneseCardProperties[parseInt(c.id.split(' ')[2], 10) - 1] || '0000000')[0] == '1'
                            })));
                            // 병참 평가 업데이트
                            factions[faction].logisticsScore = calculateLogisticsScore(faction);
                            console.log(`Logistics score after replace: ${factions[faction].logisticsScore}`);
                            closeEnlarged();
                            updateHandDisplay();
                            updateDeckRemainingDisplay();
                            checkNextTurn();
                            messageDiv.textContent = isEnglish ? 'Replaced with #47' : '#47번으로 교체 완료';
                            setTimeout(() => { messageDiv.textContent = ''; }, 3000);
                        });
                        buttonDiv.appendChild(replaceWith47Button);
                    }
                }

                const handleKeyPress = (e) => {
                    if (e.key === '1' && !ocButton.disabled) {
                        ocButton.click();
                    } else if (e.key === '2' && !futureButton.disabled) {
                        futureButton.click();
                    } else if (e.key === '3') {
                        eventButton.click();
                    }
                };
                document.addEventListener('keydown', handleKeyPress);

                enlargedCard.close = () => {
                    document.removeEventListener('keydown', handleKeyPress);
                    document.removeEventListener('click', closeEnlargedOutside);
                    enlargedCard.remove();
                    enlargedCard = null;
                };

                enlargedCard.appendChild(buttonDiv);

                setTimeout(() => {
                    document.addEventListener('click', closeEnlargedOutside);
                }, 0);
            }

            function enlargeFutureCard() {
                if (enlargedCard) return;

                const faction = factions[currentFaction];
                const lang = isEnglish ? languageData.en : languageData.ko;
                const card = faction.futureOffensive;
                enlargedCard = document.createElement('div');
                enlargedCard.classList.add('enlarged');
                const placeholder = document.createElement('div');
                placeholder.classList.add('placeholder');
                placeholder.textContent = isEnglish ? 'Loading enlarged image...' : '확대 이미지 로드 중...';
                enlargedCard.appendChild(placeholder);

                const img = document.createElement('img');
                img.alt = card.id;
                const factionPrefix = card.id.startsWith('AL') ? 'allied' : 'jp';
                const cardNumber = card.id.split(' ')[2];
                img.src = getValidImagePath(factionPrefix, cardNumber, true);
                console.log(`enlargeFutureCard: cardId=${card.id}, factionPrefix=${factionPrefix}, path=${img.src}`);
                img.onerror = () => {
                    img.src = getValidImagePath(factionPrefix, cardNumber, false);
                    console.log(`확대 이미지 로드 실패, 원본 사용: ${card.id}, 경로: ${img.src}`);
                };
                img.onload = () => {
                    enlargedCard.removeChild(placeholder);
                    img.classList.add('loaded');
                    enlargedCard.appendChild(img);
                    document.body.appendChild(enlargedCard);
                };
                img.addEventListener('contextmenu', (e) => e.preventDefault());

                const buttonDiv = document.createElement('div');
                buttonDiv.classList.add('enlarged-buttons');

                const ocButton = document.createElement('button');
                ocButton.textContent = lang.ocButton;
                ocButton.addEventListener('click', () => {
                    saveState();
                    faction.discardPile.push(faction.futureOffensive);
                    faction.futureOffensive = null;
                    updateFutureDisplay();
                    updateDiscardModal();
                    closeEnlarged();
                    updateDeckRemainingDisplay();
                    checkNextTurn();
                    messageDiv.textContent = lang.discardMessage;
                    setTimeout(() => { messageDiv.textContent = ''; }, 3000);
                    const cardNumber = parseInt(card.id.split(' ')[2]);
                    if ((currentFaction === 'allied' && cardNumber === 79) || (currentFaction === 'japanese' && cardNumber === 43)) {
                        faction.needReshuffle = true;
                    }
                    if (currentFaction === 'japanese' && faction.currentTurn === 1) {
                        faction.cardsPlayedTurn1.push(card.id);
                        japaneseDrawButton.disabled = true;
                    }
                });

                buttonDiv.appendChild(ocButton);
                enlargedCard.appendChild(buttonDiv);

                const handleKeyPress = (e) => {
                    if (e.key === '1') {
                        ocButton.click();
                    }
                };
                document.addEventListener('keydown', handleKeyPress);

                enlargedCard.close = () => {
                    document.removeEventListener('keydown', handleKeyPress);
                    document.removeEventListener('click', closeEnlargedOutside);
                    enlargedCard.remove();
                    enlargedCard = null;
                };

                setTimeout(() => {
                    document.addEventListener('click', closeEnlargedOutside);
                }, 0);
            }

            function enlargeDiscardCard(index) {
                if (enlargedCard) return;

                const faction = factions[currentFaction];
                const lang = isEnglish ? languageData.en : languageData.ko;
                const card = faction.discardPile[index];
                enlargedCard = document.createElement('div');
                enlargedCard.classList.add('enlarged');
                const placeholder = document.createElement('div');
                placeholder.classList.add('placeholder');
                placeholder.textContent = isEnglish ? 'Loading enlarged image...' : '확대 이미지 로드 중...';
                enlargedCard.appendChild(placeholder);

                const img = document.createElement('img');
                img.alt = card.id;
                const factionPrefix = card.id.startsWith('AL') ? 'allied' : 'jp';
                const cardNumber = card.id.split(' ')[2];
                img.src = getValidImagePath(factionPrefix, cardNumber, true);
                console.log(`enlargeDiscardCard: cardId=${card.id}, factionPrefix=${factionPrefix}, path=${img.src}`);
                img.onerror = () => {
                    img.src = getValidImagePath(factionPrefix, cardNumber, false);
                    console.log(`확대 이미지 로드 실패, 원본 사용: ${card.id}, 경로: ${img.src}`);
                };
                img.onload = () => {
                    enlargedCard.removeChild(placeholder);
                    img.classList.add('loaded');
                    enlargedCard.appendChild(img);
                    document.body.appendChild(enlargedCard);
                };
                img.addEventListener('contextmenu', (e) => e.preventDefault());

                const buttonDiv = document.createElement('div');
                buttonDiv.classList.add('enlarged-buttons');

                const returnButton = document.createElement('button');
                returnButton.textContent = lang.returnButton;
                returnButton.addEventListener('click', () => {
                    saveState();
                    faction.hand.push(faction.discardPile.splice(index, 1)[0]);
                    updateHandDisplay();
                    updateDiscardModal();
                    updateDeckRemainingDisplay();
                    closeEnlarged();
                    messageDiv.textContent = lang.returnMessage;
                    setTimeout(() => { messageDiv.textContent = ''; }, 3000);
                    if (currentFaction === 'japanese' && faction.currentTurn === 1) {
                        faction.cardsPlayedTurn1.push(card.id);
                        japaneseDrawButton.disabled = true;
                    }
                    faction.eventCardsDrawnThisTurn++;
                });

                buttonDiv.appendChild(returnButton);
                enlargedCard.appendChild(buttonDiv);

                const handleKeyPress = (e) => {
                    if (e.key === '4') {
                        returnButton.click();
                    }
                };
                document.addEventListener('keydown', handleKeyPress);

                enlargedCard.close = () => {
                    document.removeEventListener('keydown', handleKeyPress);
                    document.removeEventListener('click', closeEnlargedOutside);
                    enlargedCard.remove();
                    enlargedCard = null;
                };

                setTimeout(() => {
                    document.addEventListener('click', closeEnlargedOutside);
                }, 0);
            }

            function enlargeRemovedCard(index) {
                if (enlargedCard) return;

                const faction = factions[currentFaction];
                const lang = isEnglish ? languageData.en : languageData.ko;
                const card = faction.removedCards[index];
                enlargedCard = document.createElement('div');
                enlargedCard.classList.add('enlarged');
                const placeholder = document.createElement('div');
                placeholder.classList.add('placeholder');
                placeholder.textContent = isEnglish ? 'Loading enlarged image...' : '확대 이미지 로드 중...';
                enlargedCard.appendChild(placeholder);

                const img = document.createElement('img');
                img.alt = card.id;
                const factionPrefix = card.id.startsWith('AL') ? 'allied' : 'jp';
                const cardNumber = card.id.split(' ')[2];
                img.src = getValidImagePath(factionPrefix, cardNumber, true);
                console.log(`enlargeRemovedCard: cardId=${card.id}, factionPrefix=${factionPrefix}, path=${img.src}`);
                img.onerror = () => {
                    img.src = getValidImagePath(factionPrefix, cardNumber, false);
                    console.log(`확대 이미지 로드 실패, 원본 사용: ${card.id}, 경로: ${img.src}`);
                };
                img.onload = () => {
                    enlargedCard.removeChild(placeholder);
                    img.classList.add('loaded');
                    enlargedCard.appendChild(img);
                    document.body.appendChild(enlargedCard);
                };
                img.addEventListener('contextmenu', (e) => e.preventDefault());

                const buttonDiv = document.createElement('div');
                buttonDiv.classList.add('enlarged-buttons');

                const returnButton = document.createElement('button');
                returnButton.textContent = lang.returnButton;
                returnButton.addEventListener('click', () => {
                    saveState();
                    faction.hand.push(faction.removedCards.splice(index, 1)[0]);
                    updateHandDisplay();
                    updateRemovedModal();
                    updateDeckRemainingDisplay();
                    closeEnlarged();
                    messageDiv.textContent = lang.returnMessage;
                    setTimeout(() => { messageDiv.textContent = ''; }, 3000);
                    if (currentFaction === 'japanese' && faction.currentTurn === 1) {
                        faction.cardsPlayedTurn1.push(card.id);
                        japaneseDrawButton.disabled = true;
                    }
                    faction.eventCardsDrawnThisTurn++;
                });

                buttonDiv.appendChild(returnButton);
                enlargedCard.appendChild(buttonDiv);

                const handleKeyPress = (e) => {
                    if (e.key === '4') {
                        returnButton.click();
                    }
                };
                document.addEventListener('keydown', handleKeyPress);

                enlargedCard.close = () => {
                    document.removeEventListener('keydown', handleKeyPress);
                    document.removeEventListener('click', closeEnlargedOutside);
                    enlargedCard.remove();
                    enlargedCard = null;
                };

                setTimeout(() => {
                    document.addEventListener('click', closeEnlargedOutside);
                }, 0);
            }





            function closeEnlarged() {
                if (enlargedCard) {
                    enlargedCard.close();
                }
            }

            function closeEnlargedOutside(e) {
                if (!enlargedCard.contains(e.target)) {
                    closeEnlarged();
                }
            }

            function checkNextTurn() {
                if (nextTurnButton) {
                    nextTurnButton.disabled = factions[currentFaction].hand.length > 0;
                }
            }

            function updateHandDisplay() {
                handDiv.innerHTML = '';
                factions[currentFaction].hand.forEach((card, index) => {
                    const cardElem = createCardElem(card, () => enlargeCard(index));
                    cardElem.dataset.index = index; // 드래그 시 원본 인덱스 저장
                    handDiv.appendChild(cardElem);
                });

                // Sortable 초기화 (드래그 재정렬 활성화)
                if (Sortable.get(handDiv)) Sortable.get(handDiv).destroy(); // 기존 Sortable 제거
                new Sortable(handDiv, {
                    animation: 150,
                    ghostClass: 'dragging', // 드래그 중 클래스 적용
                    onEnd: (evt) => {
                        const oldIndex = evt.oldIndex;
                        const newIndex = evt.newIndex;
                        if (oldIndex !== newIndex) {
                            // 핸드 배열 재정렬
                            const card = factions[currentFaction].hand.splice(oldIndex, 1)[0];
                            factions[currentFaction].hand.splice(newIndex, 0, card);
                            console.log(`Card reordered: from ${oldIndex} to ${newIndex}`, factions[currentFaction].hand);
                            updateHandDisplay(); // 재렌더링
                        }
                    }
                });
            }

            updateUI();
        });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
</body>
</html>