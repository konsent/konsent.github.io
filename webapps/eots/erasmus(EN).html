<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Empire of the Sun - Japanese Erasmus</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#1f1f1f; --nav:#2a2a2a; --text:#e8e8e8; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--text); font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header { padding:14px 18px; background:var(--nav); border-bottom:1px solid #3a3a3a; }
    header h1 { margin:0; font-size:18px; }
    nav { display:flex; gap:8px; padding:10px 12px; background:#242424; border-bottom:1px solid #3a3a3a; flex-wrap:wrap; }
    nav button {
      padding:8px 12px; border:1px solid #3a3a3a; background:#303030; color:var(--text);
      border-radius:8px; cursor:pointer; font-size:14px;
    }
    nav button.active { background:#3d5a98; border-color:#3d5a98; }
    .viewport { height: calc(100vh - 112px); /* header+nav+footer 여유 */ }
    .frame { display:none; width:100%; height:100%; border:0; background:#111; }
    .frame.active { display:block; }
    footer { padding:8px 12px; background:#242424; border-top:1px solid #3a3a3a; font-size:12px; color:#bbb; }
    .impl-note {
            font-style: italic;
            font-size: 14px;
            color: #ffffff;
            line-height: 1.6;
            margin: 4px 0;
        }
    
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: #3c3c3c;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
    
        .header {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #4a4a4a;
            border-radius: 8px;
            color: #ffffff;
            border: 1px solid #5c5c5c;
        }
    
        .header h1 {
            margin: 0;
            font-size: 2rem;
            font-weight: 700;
        }
    
        .header p {
            margin: 8px 0 0 0;
            font-size: 1rem;
            font-weight: 400;
        }
    
        .progress-bar {
            background: #4a4a4a;
            border-radius: 5px;
            height: 6px;
            margin-bottom: 20px;
            overflow: hidden;
            border: 1px solid #5c5c5c;
        }
    
        .progress-fill {
            background: #4682b4;
            height: 100%;
            border-radius: 5px;
            transition: width 0.3s ease;
            width: 0%;
        }
    
        .step-section {
            background: #3c3c3c;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
            border: 1px solid #5c5c5c;
        }
    
        .step-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
    
        .step-number {
            background: #4682b4;
            color: #ffffff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1rem;
            margin-right: 15px;
        }
    
        .step-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #d8d8d8;
            margin: 0;
        }
    
        .condition-box {
            background: #4a4a4a;
            border-left: 4px solid #4682b4;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            font-size: 1rem;
            line-height: 1.5;
            color: #c8c8c8;
        }
    
        .condition-box strong {
            color: #4682b4;
            font-size: 1.1rem;
        }
    
        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
    
        .btn {
            padding: 10px 30px;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s ease;
            text-transform: uppercase;
            min-width: 100px;
            font-family: 'Georgia', 'Times New Roman', Times, serif;
        }
    
        .btn-yes {
            background: #2e8b57;
            color: #ffffff;
        }
    
        .btn-yes:hover {
            background: #257a4b;
            transform: translateY(-2px);
        }
    
        .btn-no {
            background: #696969;
            color: #ffffff;
        }
    
        .btn-no:hover {
            background: #585858;
            transform: translateY(-2px);
        }
    
        .btn-primary {
            background: #4682b4;
            color: #ffffff;
        }
    
        .btn-primary:hover {
            background: #3a6b9a;
            transform: translateY(-2px);
        }
    
        .btn-secondary {
            background: #5c5c5c;
            color: #ffffff;
        }
    
        .btn-secondary:hover {
            background: #4b4b4b;
            transform: translateY(-2px);
        }
    
        .btn-back {
            background: #5c5c5c;
            color: #ffffff;
        }
    
        .btn-back:hover {
            background: #4b4b4b;
            transform: translateY(-2px);
        }
    
        .path-history {
            background: #4a4a4a;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 3px solid #2e8b57;
        }
    
        .path-step {
            display: flex;
            align-items: center;
            margin: 8px 0;
            padding: 8px;
            background: #3c3c3c;
            border-radius: 5px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
    
        .path-step .step-icon {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
            font-size: 0.8rem;
        }
    
        .path-step.yes .step-icon {
            background: #2e8b57;
            color: #ffffff;
        }
    
        .path-step.no .step-icon {
            background: #696969;
            color: #ffffff;
        }
    
        .dice-section {
            background: #4a4a4a;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 15px 0;
            border: 1px solid #5c5c5c;
        }
    
        .dice-result {
            font-size: 3rem;
            font-weight: bold;
            color: #d8d8d8;
            margin: 15px 0;
        }
    
        .result-section {
            background: #2e8b57;
            color: #ffffff;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-top: 15px;
            border: 1px solid #3c3c3c;
        }
    
        .result-section h2 {
            margin: 0 0 15px 0;
            font-size: 2rem;
            display: none;
        }
    
        .result-section p {
            margin: 10px 0;
            font-size: 32px;
            white-space: pre-line;
            font-weight: bold;
            font-style: italic;
        }
    
        .strategy-details {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            padding: 15px;
            margin-top: 15px;
        }
    
        .strategy-list {
            text-align: left;
            margin: 15px 0;
            list-style: none;
            padding: 0;
        }
    
        .strategy-list li {
            margin: 8px 0;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            border-left: 3px solid rgba(255, 255, 255, 0.3);
        }
    
        .sub-priority-list {
            list-style: none;
            padding-left: 20px;
            margin-top: 5px;
        }
    
        .sub-priority-list li {
            margin: 5px 0;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            border-left: 2px solid rgba(255, 255, 255, 0.4);
            font-size: 0.9rem;
        }
    
        .hidden {
            display: none;
        }
    
        @media (max-width: 768px) {
            .container {
                padding: 15px;
                margin: 10px;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .button-group {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 100%;
                max-width: 180px;
            }
        }
    </style>
  </style>
</head>
<body>
  <header><h1>Empire of the Sun - Japanese Erasmus</h1></header>

  <nav id="tabs">
    <button data-target="early" class="active">Opening Phase</button>
    <button data-target="mid">Mid Phase</button>
    <button data-target="late">End Phase</button>
    <button data-target="card">Cards</button>
    <button data-target="task">Task Forces</button>
    <button data-target="resp">Reactions</button>
    <button data-target="pbm">PBM</button>
  </nav>

  <div class="viewport">
    <!-- 각 페이지를 격리할 iframe들 -->
    <iframe id="frame-early" class="frame active"></iframe>
    <iframe id="frame-mid"   class="frame"></iframe>
    <iframe id="frame-late"  class="frame"></iframe>
    <iframe id="frame-card"  class="frame"></iframe>
    <iframe id="frame-task"  class="frame"></iframe>
    <iframe id="frame-resp"  class="frame"></iframe>
    <iframe id="frame-pbm"   class="frame"></iframe>
  </div>

  <footer>Feedback</footer>

  <template id="tmpl-early">
    <!DOCTYPE html>
    <html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Opening Phase</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                background: #2e2e2e;
                min-height: 100vh;
                margin: 0;
                padding: 20px;
                box-sizing: border-box;
                color: #d8d8d8;
            }
        
            .impl-note {
                font-style: italic;
                font-size: 14px;
                color: #ffffff;
                line-height: 1.6;
                margin: 4px 0;
            }
        
            .container {
                max-width: 800px;
                margin: 0 auto;
                background: #3c3c3c;
                border-radius: 8px;
                padding: 20px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            }
        
            .header {
                text-align: center;
                margin-bottom: 20px;
                padding: 15px;
                background: #4a4a4a;
                border-radius: 8px;
                color: #ffffff;
                border: 1px solid #5c5c5c;
            }
        
            .header h1 {
                margin: 0;
                font-size: 2rem;
                font-weight: 700;
            }
        
            .header p {
                margin: 8px 0 0 0;
                font-size: 1rem;
                font-weight: 400;
            }
        
            .progress-bar {
                background: #4a4a4a;
                border-radius: 5px;
                height: 6px;
                margin-bottom: 20px;
                overflow: hidden;
                border: 1px solid #5c5c5c;
            }
        
            .progress-fill {
                background: #4682b4;
                height: 100%;
                border-radius: 5px;
                transition: width 0.3s ease;
                width: 0%;
            }
        
            .step-section {
                background: #3c3c3c;
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 15px;
                border: 1px solid #5c5c5c;
            }
        
            .step-header {
                display: flex;
                align-items: center;
                margin-bottom: 15px;
            }
        
            .step-number {
                background: #4682b4;
                color: #ffffff;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                font-size: 1rem;
                margin-right: 15px;
            }
        
            .step-title {
                font-size: 1.3rem;
                font-weight: 600;
                color: #d8d8d8;
                margin: 0;
            }
        
            .condition-box {
                background: #4a4a4a;
                border-left: 4px solid #4682b4;
                border-radius: 5px;
                padding: 15px;
                margin: 15px 0;
                font-size: 1rem;
                line-height: 1.5;
                color: #c8c8c8;
            }
        
            .condition-box strong {
                color: #4682b4;
                font-size: 1.1rem;
            }
        
            .button-group {
                display: flex;
                gap: 15px;
                justify-content: center;
                margin-top: 20px;
            }
        
            .btn {
                padding: 10px 30px;
                border: none;
                border-radius: 5px;
                font-size: 1rem;
                font-weight: 500;
                cursor: pointer;
                transition: background 0.2s ease, transform 0.1s ease;
                text-transform: uppercase;
                min-width: 100px;
                font-family: 'Georgia', 'Times New Roman', Times, serif;
            }
        
            .btn-yes {
                background: #2e8b57;
                color: #ffffff;
            }
        
            .btn-yes:hover {
                background: #257a4b;
                transform: translateY(-2px);
            }
        
            .btn-no {
                background: #696969;
                color: #ffffff;
            }
        
            .btn-no:hover {
                background: #585858;
                transform: translateY(-2px);
            }
        
            .btn-primary {
                background: #4682b4;
                color: #ffffff;
            }
        
            .btn-primary:hover {
                background: #3a6b9a;
                transform: translateY(-2px);
            }
        
            .btn-secondary {
                background: #5c5c5c;
                color: #ffffff;
            }
        
            .btn-secondary:hover {
                background: #4b4b4b;
                transform: translateY(-2px);
            }
        
            .btn-back {
                background: #5c5c5c;
                color: #ffffff;
            }
        
            .btn-back:hover {
                background: #4b4b4b;
                transform: translateY(-2px);
            }
        
            .path-history {
                background: #4a4a4a;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 15px;
                border-left: 3px solid #2e8b57;
            }
        
            .path-step {
                display: flex;
                align-items: center;
                margin: 8px 0;
                padding: 8px;
                background: #3c3c3c;
                border-radius: 5px;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            }
        
            .path-step .step-icon {
                width: 25px;
                height: 25px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                margin-right: 10px;
                font-size: 0.8rem;
            }
        
            .path-step.yes .step-icon {
                background: #2e8b57;
                color: #ffffff;
            }
        
            .path-step.no .step-icon {
                background: #696969;
                color: #ffffff;
            }
        
            .dice-section {
                background: #4a4a4a;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                margin: 15px 0;
                border: 1px solid #5c5c5c;
            }
        
            .dice-result {
                font-size: 3rem;
                font-weight: bold;
                color: #d8d8d8;
                margin: 15px 0;
            }
        
            .result-section {
                background: #2e8b57;
                color: #ffffff;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                margin-top: 15px;
                border: 1px solid #3c3c3c;
            }
        
            .result-section h2 {
                margin: 0 0 15px 0;
                font-size: 2rem;
                display: none;
            }
        
            .result-section p {
                margin: 10px 0;
                font-size: 32px;
                white-space: pre-line;
                font-weight: bold;
                font-style: italic;
            }
        
            .strategy-details {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 5px;
                padding: 15px;
                margin-top: 15px;
            }
        
            .strategy-list {
                text-align: left;
                margin: 15px 0;
                list-style: none;
                padding: 0;
            }
        
            .strategy-list li {
                margin: 8px 0;
                padding: 8px 10px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 5px;
                border-left: 3px solid rgba(255, 255, 255, 0.3);
            }
        
            .sub-priority-list {
                list-style: none;
                padding-left: 20px;
                margin-top: 5px;
            }
        
            .sub-priority-list li {
                margin: 5px 0;
                padding: 5px 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 5px;
                border-left: 2px solid rgba(255, 255, 255, 0.4);
                font-size: 0.9rem;
            }
        
            .hidden {
                display: none;
            }
        
            @media (max-width: 768px) {
                .container {
                    padding: 15px;
                    margin: 10px;
                }
                
                .header h1 {
                    font-size: 1.5rem;
                }
                
                .button-group {
                    flex-direction: column;
                    align-items: center;
                }
                
                .btn {
                    width: 100%;
                    max-width: 180px;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>Opening Phase</h1>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div id="pathHistory" class="path-history hidden">
                <h4 style="margin-top: 0; color: #ffffff;">Flow</h4>
                <div id="pathSteps"></div>
            </div>

            <div id="stepSection" class="step-section">
                <div class="step-header">
                    <div class="step-number" id="stepNumber">1</div>
                    <h2 class="step-title" id="stepTitle">Start</h2>
                </div>
                
                <div class="condition-box" id="conditionBox">
                    Follow the flowchart
                </div>
                
                <div class="button-group" id="buttonGroup">
                    <button class="btn btn-primary" onclick="startFlow()">Start</button>
                </div>
            </div>

            <div id="diceSection" class="dice-section hidden">
                <h3 style="margin: 0 0 20px 0; color: #2d3436;">Roll D10</h3>
                <div class="dice-result" id="diceResult">?</div>
                <div class="button-group">
                    <button class="btn btn-primary" onclick="rollDice()">Roll dice</button>
                </div>
            </div>

            <div id="resultSection" class="result-section hidden">
                <h2 id="strategyTitle">Strategy Result</h2>
                <p id="strategyName"></p>
                <div class="strategy-details" id="strategyDetails"></div>
                <div class="button-group" style="margin-top: 30px;">
                    <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                </div>
            </div>
        </div>
        <script>
            // Implementation notes
            const notes = {
                '[1]': '활성화 시, 연합군 HQ가 보급 상태가 되도록 해서는 안됩니다.',
                '[2]': '지정된 목표 지점에, 손실(소모전)을 견딜 수 있는 지상 유닛을 AA를 통해 상륙시킵니다.',
                '[3]': '카드와 조건이 충족될 경우, 전략에서 지시하는 순서대로 이벤트를 실행합니다.',
                '[4]': '가능하다면 PBM으로 공군 유닛을 사용하고, 그렇지 않다면 항공모함을 사용합니다.',
                '[5]': 'WiE > 0이고, WiE 자동 이벤트 전략을 사용할 수 있다면 그 전략을 사용합니다, 그렇지 않으면 지시에 따라 주사위를 굴립니다.',
                '[6]': '이미 점령한 항구라면, IJA 병력을 최대 3스텝만큼 증원합니다. 그렇지 않다면 무시합니다.',
                '[7]': '목표 지역(또는 특정 HQ)을 방어하는 적 AZOI 유닛을, 지정된 피해 수준 이상으로 제거할 수 있을 만큼의 화력을 동원해 공중/해상 공격을 수행합니다. 필요하다면 PBM 중에 HQ 위에 AZOI를 형성할 수 있도록 기지를 점령합니다.'
            };
        
            // 전략 정보 데이터
            const strategies = {
                'Aggressive Air Superiority': {
                    name: '공세적 제공권 전략',
                    details: [
                        '연합군 본부 무력화[7]<em style="font-size:0.9em;">Neutralize Allied HQs</em>',
                        'DEI 항복<em style="font-size:0.9em;">DEI Surrender</em>',
                        '말라야 항복<em style="font-size:0.9em;">Malaya Surrender</em>'
                    ]
                },
                'Conservative Air Superiority': {
                    name: '보수적 제공권 전략',
                    details: [
                        '연합군 본부 무력화[7]<em style="font-size:0.9em;">Neutralize Allied HQs</em>',
                        'DEI 무력화<em style="font-size:0.9em;">DEI Neutralization</em>'
                    ]
                },
                'Aggressive Southern Resource': {
                    name: '공세적 남방 자원 전략[1]',
                    details: [
                        'DEI 항복<em style="font-size:0.9em;">DEI Surrender</em>',
                        '말라야 항복<em style="font-size:0.9em;">Malaya Surrender</em>',
                        '필리핀 항복<em style="font-size:0.9em;">Philippines Surrender</em>',
                        'D10 주사위 하나 굴리기[5]'
                    ]
                },
                'Conservative Southern Resource': {
                    name: '보수적 남방 자원 전략[1]',
                    details: [
                        'DEI 무력화<em style="font-size:0.9em;">DEI Neutralization</em>',
                        '말라야 항복<em style="font-size:0.9em;">Malaya Surrender</em>',
                        '필리핀 항복<em style="font-size:0.9em;">Philippines Surrender</em>',
                        'D10 주사위 하나 굴리기[5]'
                    ]
                },
                'Defense Perimeter Strategy': {
                    name: '방어선 전략',
                    details: [
                        '호주 위임통치령<em style="font-size:0.9em;">Australian Mandates</em>',
                        '뉴기니<em style="font-size:0.9em;">New Guinea</em>'
                    ]
                },
                'CBI Strategy': {
                    name: 'CBI 전략',
                    details: [
                        '버마 항복<em style="font-size:0.9em;">Burma Surrender</em>',
                        '중국 항복<em style="font-size:0.9em;">China Surrender</em>'
                    ]
                },
                'Central Pacific Strategy': {
                    name: '중부 태평양 전략',
                    details: [
                        '뉴기니 북서부<em style="font-size:0.9em;">NW New Guinea</em>',
                        'Attu/Kiska[2]',
                        'Defend Marshalls',
                        'Midway[2]'
                    ]
                },
                'Event Strategy': {
                    name: '이벤트 전략[3]',
                    details: [
                        '연합군 WiE > 0이면 WiE, 그 외 FOQ',
                        '일본이 ISR이면 ISR 종료, 그 외 FOQ',
                        '연합군이 전략적 합의 상태면 ISR 생성, 그 외 FOQ.',
                        '도쿄 로즈를 FOQ로',
                        '병력 보충을 FOQ로',
                        '날씨 카드를 FOQ로',
                        '이벤트로 플레이했을 때 미국 PW가 0이 되지 않는 한, 도조 카드를 TOC로 플레이',
                        '기타: FOQ가 없다면 카드를 FOQ에 넣음'
                    ]
                }
            };
        
            // 하위 우선순위 목록
            const subPriorities = {
                '연합군 본부 무력화[7]<em style="font-size:0.9em;">Neutralize Allied HQs</em>': [
                    'Philippines (0.25x)',
                    'Singapore (0.5x)',
                    'ABDA (0.5x)'
                ],
                'DEI 무력화<em style="font-size:0.9em;">DEI Neutralization</em>': [
                    'Jolo[4]',
                    'Makassar[4]',
                    'Teleokbetung[4]',
                    'Bandjermasin[4]',
                    '[4]: 가능하다면 PBM으로 공군 유닛을 사용하고, 그렇지 않다면 항공모함을 사용한다.'
                ],
                'DEI 항복<em style="font-size:0.9em;">DEI Surrender</em>': [
                    'Balikpapan, Tarakan',
                    'Batavia(Java에 일본 지상 병력이 없다면 장악capture)[6]',
                    'Tjilatjap, Soerabaja',
                    'Bangka, Palembang, Medan'
                ],
                '말라야 항복<em style="font-size:0.9em;">Malaya Surrender</em>': [
                    'Kuantan',
                    'Singapore'
                ],
                '필리핀 항복<em style="font-size:0.9em;">Philippines Surrender</em>': [
                    'Manila',
                    'Davao'
                ],
                '호주 위임통치령<em style="font-size:0.9em;">Australian Mandates</em>': [
                    'Rabaul / Allied',
                    'Guadalcanal'
                ],
                '버마 항복<em style="font-size:0.9em;">Burma Surrender</em>': [
                    'Rangoon',
                    'Mandalay',
                    'Lashio',
                    'Myitkyina'
                ],
                '중국 항복<em style="font-size:0.9em;">China Surrender</em>': [
                    'Lashio',
                    '중국 공세<em style="font-size:0.9em;">China Offensive</em>',
                    'China Event'
                ],
                '뉴기니 북서부<em style="font-size:0.9em;">NW New Guinea</em>': [
                    'Hollandia',
                    'Lae',
                    'Buna',
                    'Biak',
                    'Wewak',
                    'Vogelkop',
                    'Gili-Gili',
                    'Port Moresby'
                ],
                'Defend Marshalls': [
                    'Wake',
                    'Tarawa'
                ],
                '뉴기니<em style="font-size:0.9em;">New Guinea</em>': [
                    'Sarong',
                    'Vogelkop',
                    'Biak'
                ]
            };
        
            // 정의
            const conditions = {
                'A': '필리핀, DEI, 말라야에 있는 연합군 본부가 OOS 상태입니까?',
                'B': 'DEI 항복 목표들에 점령되었습니까?',
                'C': '일본이 카드를 3장 이상 가지고 있습니까?',
                'D': '일본이 통제Control하는 자원 헥스가 13개 미만입니까?',
                'E': '일본이 통제Control하는 자원 헥스가 13개 이상입니까?',
                'F': '병참 평가 수치가 20 이상입니까?',
                'G': '지금 진행하는 게임 턴이 3턴 또는 그 이후 턴입니까?',
                'H': '병참 평가 수치가 19 이하입니까?',
                'I': '모든 DEI 항구가 일본군의 AZOI 영향권에 있습니까?',
                'J': '일본이 과달카날과 라바울을 통제Control합니까?',
                'K': '일본이 뉴기니 항구 6개 중 4개를 통제Control하거나 AZOI를 행사하고 있습니까?',
                'L': '말라야, 필리핀, DEI 중 한 곳이 정복Conquered되기 까지 딱 1 헥스가 부족한 상황입니까?',
                'M': '방어선 전략 목표Defense Perimeter Strategy #1을 달성했습니까?'
            };
        
            let currentStep = 'start';
            let pathHistory = [];
            let stepCount = 0;
            let evaluatedConditions = {};
        
            // Helper function to create missing DOM elements
            function createMissingElement(id, tag, parent, classes = []) {
                let element = document.getElementById(id);
                if (!element) {
                    console.warn(`Creating missing element: ${id}`);
                    element = document.createElement(tag);
                    element.id = id;
                    classes.forEach(cls => element.classList.add(cls));
                    if (parent && parent.appendChild) {
                        parent.appendChild(element);
                    } else {
                        document.body.appendChild(element);
                    }
                }
                return element;
            }
        
            function startFlow() {
                currentStep = 'A';
                stepCount = 1;
                pathHistory = [];
                evaluatedConditions = {};
                showStep('A');
            }
        
            function showStep(stepId) {
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const stepSection = createMissingElement('stepSection', 'div', document.body);
                const stepNumber = createMissingElement('stepNumber', 'div', stepSection);
                const stepTitle = createMissingElement('stepTitle', 'h2', stepSection);
                const conditionBox = createMissingElement('conditionBox', 'div', stepSection);
                const buttonGroup = createMissingElement('buttonGroup', 'div', stepSection);
        
                if (errorContainer) errorContainer.classList.add('hidden');
        
                stepNumber.textContent = stepCount;
        
                if (stepId === 'DICE') {
                    const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
                    const diceResult = createMissingElement('diceResult', 'div', diceSection);
                    stepSection.classList.add('hidden');
                    diceSection.classList.remove('hidden');
                    diceResult.textContent = '-';
                    buttonGroup.innerHTML = `
                        <button class="btn btn-primary" onclick="rollDice()">Roll dice</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                    return;
                }
        
                // 복합 조건들을 처리
                if (stepId.includes('_CHECK') || stepId.includes('_FOR_') || stepId.includes('_FINAL')) {
                    showComplexConditionStep(stepId);
                    return;
                }
        
                // 기본 조건들 처리
                if (conditions[stepId]) {
                    stepTitle.textContent = `${stepId} 확인`;
                    conditionBox.innerHTML = ` ${conditions[stepId]}`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-yes" onclick="selectChoice('${stepId}', true)">YES</button>
                        <button class="btn btn-no" onclick="selectChoice('${stepId}', false)">NO</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                } else if (stepId === 'start') {
                    stepTitle.textContent = '시작';
                    conditionBox.innerHTML = `전쟁 초기 페이즈`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-primary" onclick="startFlow()">시작하기</button>
                    `;
                }
        
                updateProgress();
                updatePathHistory();
            }
        
            function selectChoice(conditionId, choice) {
                evaluatedConditions[conditionId] = choice;
                pathHistory.push({ step: conditionId, choice: choice, stepNum: stepCount });
                stepCount++;
        
                const nextStep = getNextStep(conditionId, choice);
        
                if (nextStep.startsWith('STRATEGY_')) {
                    const strategy = nextStep.replace('STRATEGY_', '');
                    showResult(strategy);
                } else {
                    currentStep = nextStep;
                    showStep(nextStep);
                }
            }
        
            function getNextStep(conditionId, choice) {
                switch (conditionId) {
                    case 'A':
                        return choice ? 'B' : 'CD_CHECK';
                    case 'B':
                        return choice ? 'C_FOR_E_OR_HI' : 'G';
                    case 'C_FOR_E_OR_HI':
                        return choice ? 'E_OR_HI_CHECK' : 'CJE_BIK_CHECK';
                    case 'E_OR_HI_CHECK':
                        return choice ? 'STRATEGY_Defense Perimeter Strategy' : 'CJE_BIK_CHECK';
                    case 'CJE_BIK_CHECK':
                        return choice ? 'DICE' : 'CL_CHECK';
                    case 'CL_CHECK':
                        return choice ? 'STRATEGY_Aggressive Southern Resource' : 'M';
                    case 'G':
                        return choice ? 'STRATEGY_Aggressive Southern Resource' : 'ACD_CHECK';
                    case 'CD_CHECK':
                        return choice ? 'F_FOR_CD' : 'G';
                    case 'F_FOR_CD':
                        return choice ? 'STRATEGY_Aggressive Air Superiority' : 'STRATEGY_Conservative Air Superiority';
                    case 'ACD_CHECK':
                        return choice ? 'F_FOR_ACD' : 'C_FOR_E_OR_HI_FINAL';
                    case 'F_FOR_ACD':
                        return choice ? 'STRATEGY_Aggressive Southern Resource' : 'STRATEGY_Conservative Southern Resource';
                    case 'C_FOR_E_OR_HI_FINAL':
                        return choice ? 'E_OR_HI_CHECK_FINAL' : 'STRATEGY_Conservative Southern Resource';
                    case 'E_OR_HI_CHECK_FINAL':
                        return choice ? 'STRATEGY_Defense Perimeter Strategy' : 'STRATEGY_Conservative Southern Resource';
                    case 'M':
                        return choice ? 'STRATEGY_Defense Perimeter Strategy' : 'STRATEGY_Aggressive Southern Resource';
                    default:
                        return 'STRATEGY_Defense Perimeter Strategy';
                }
            }
        
            function rollDice() {
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
                const diceResult = createMissingElement('diceResult', 'div', diceSection);
                if (errorContainer) errorContainer.classList.add('hidden');
        
                const diceValue = Math.floor(Math.random() * 10); // 0-9
                diceResult.textContent = diceValue;
        
                let strategy;
                if (diceValue >= 0 && diceValue <= 2) {
                    strategy = 'Event Strategy';
                } else if (diceValue >= 3 && diceValue <= 6) {
                    strategy = 'CBI Strategy';
                } else if (diceValue >= 7 && diceValue <= 9) {
                    strategy = 'Central Pacific Strategy';
                }
        
                pathHistory.push({
                    step: 'DICE',
                    choice: diceValue,
                    stepNum: stepCount,
                    isResult: true,
                    result: strategy
                });
        
                setTimeout(() => showResult(strategy), 1000);
            }
        
            function showResult(strategyKey) {
                const strategy = strategies[strategyKey];
                if (!strategy) {
                    console.error('Strategy not found:', strategyKey);
                    return;
                }
        
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const stepSection = createMissingElement('stepSection', 'div', document.body);
                const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
                const resultSection = createMissingElement('resultSection', 'div', document.body, ['hidden']);
                const strategyName = createMissingElement('strategyName', 'h2', resultSection);
                const strategyDetails = createMissingElement('strategyDetails', 'div', resultSection);
                const buttonGroup = resultSection.querySelector('.button-group') || createMissingElement('button-group', 'div', resultSection, ['button-group']);
        
                if (errorContainer) errorContainer.classList.add('hidden');
        
                stepSection.classList.add('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.remove('hidden');
                strategyName.textContent = strategy.name;
        
                // Extract annotations from strategy name, details, and sub-priorities
                const annotationRegex = /\[\d+\]/g;
                const annotations = new Set();
                if (strategy.name.match(annotationRegex)) {
                    strategy.name.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                }
                strategy.details.forEach(detail => {
                    if (detail.match(annotationRegex)) {
                        detail.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                    }
                    if (subPriorities[detail]) {
                        subPriorities[detail].forEach(sub => {
                            if (sub.match(annotationRegex)) {
                                sub.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                            }
                        });
                    }
                });
        
                strategyDetails.innerHTML = `
                    <h4 style="margin-top: 0; color: #fff;">전략 우선순위:</h4>
                    <ul class="strategy-list">
                        ${strategy.details.map(detail => `
                            <li>
                                ${detail}
                                ${subPriorities[detail] ? `
                                    <ul class="sub-priority-list">
                                        ${subPriorities[detail].map(sub => `<li>${sub}</li>`).join('')}
                                    </ul>
                                ` : ''}
                            </li>
                        `).join('')}
                    </ul>
                    ${annotations.size > 0 ? `
                        <h4 style="margin-top: 20px; color: #fff;">주석:</h4>
                        <ul class="strategy-list">
                            ${Array.from(annotations).sort().map(annotation => `
                                <li class="impl-note">${annotation}: ${notes[annotation]}</li>
                            `).join('')}
                        </ul>
                    ` : ''}
                `;
        
                // Check if strategy details include "D10 주사위 하나 굴리기[5]"
                const hasDiceRoll = strategy.details.includes('D10 주사위 하나 굴리기[5]');
                buttonGroup.innerHTML = `
                    ${hasDiceRoll ? '<button class="btn btn-primary" onclick="rollDice()">Roll dice</button>' : ''}
                    <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                    ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                `;
        
                updateProgress();
                updatePathHistory();
            }
        
            function updateProgress() {
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const progressBar = createMissingElement('progress-bar', 'div', document.body, ['progress-bar']);
                const progressFill = createMissingElement('progressFill', 'div', progressBar, ['progress-fill']);
                if (errorContainer) errorContainer.classList.add('hidden');
        
                const totalSteps = 15; // 대략적인 최대 단계 수
                const progress = Math.min((stepCount / totalSteps) * 100, 100);
                progressFill.style.width = progress + '%';
            }
        
            function updatePathHistory() {
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const pathHistoryDiv = createMissingElement('pathHistory', 'div', document.body, ['hidden']);
                const pathStepsDiv = createMissingElement('pathSteps', 'div', pathHistoryDiv);
                if (errorContainer) errorContainer.classList.add('hidden');
        
                if (pathHistory.length === 0) {
                    pathHistoryDiv.classList.add('hidden');
                    return;
                }
        
                pathStepsDiv.innerHTML = '';
        
                pathHistory.forEach(step => {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = `path-step ${step.choice && step.step !== 'DICE' ? 'yes' : step.step !== 'DICE' ? 'no' : ''}`;
        
                    if (step.step === 'DICE') {
                        stepDiv.innerHTML = `
                            <div class="step-icon">${step.choice}</div>
                            <div>
                                <strong>Roll dice:</strong> ${step.choice} 
                                ${step.result ? `→ ${strategies[step.result].name}` : ''}
                            </div>
                        `;
                    } else {
                        let conditionText = '';
                        if (conditions[step.step]) {
                            conditionText = conditions[step.step];
                        } else {
                            switch (step.step) {
                                case 'CD_CHECK':
                                    conditionText = 'C+D';
                                    break;
                                case 'CJE_BIK_CHECK':
                                    conditionText = 'C+J+E+(B or I or K)';
                                    break;
                                case 'ACD_CHECK':
                                    conditionText = 'A+C+D';
                                    break;
                                case 'E_OR_HI_CHECK':
                                case 'E_OR_HI_CHECK_FINAL':
                                    conditionText = 'E or (H+I)';
                                    break;
                                case 'CL_CHECK':
                                    conditionText = 'C+L';
                                    break;
                                case 'C_FOR_E_OR_HI':
                                    conditionText = 'C';
                                    break;
                                case 'C_FOR_E_OR_HI_FINAL':
                                    conditionText = 'C(최종)';
                                    break;
                                case 'F_FOR_CD':
                                    conditionText = 'F(제공권)';
                                    break;
                                case 'F_FOR_ACD':
                                    conditionText = 'F(남방자원)';
                                    break;
                                default:
                                    conditionText = step.step;
                            }
                        }
        
                        stepDiv.innerHTML = `
                            <div class="step-icon">${step.choice ? 'Y' : 'N'}</div>
                            <div>
                                <strong>${step.step}:</strong> 
                                ${conditionText} → ${step.choice ? 'YES' : 'NO'}
                            </div>
                        `;
                    }
        
                    pathStepsDiv.appendChild(stepDiv);
                });
        
                pathHistoryDiv.classList.remove('hidden');
            }
        
            function resetFlow() {
                currentStep = 'start';
                stepCount = 0;
                pathHistory = [];
                evaluatedConditions = {};
        
                // Step 1: Create top-level elements
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const stepSection = createMissingElement('stepSection', 'div', document.body);
                const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
                const resultSection = createMissingElement('resultSection', 'div', document.body, ['hidden']);
                const pathHistoryDiv = createMissingElement('pathHistory', 'div', document.body, ['hidden']);
                const progressBar = createMissingElement('progress-bar', 'div', document.body, ['progress-bar']);
        
                // Step 2: Create child elements that depend on top-level elements
                const elements = {
                    errorContainer,
                    stepSection,
                    diceSection,
                    resultSection,
                    pathHistoryDiv,
                    progressBar,
                    stepNumber: createMissingElement('stepNumber', 'div', stepSection),
                    stepTitle: createMissingElement('stepTitle', 'h2', stepSection),
                    conditionBox: createMissingElement('conditionBox', 'div', stepSection),
                    buttonGroup: createMissingElement('buttonGroup', 'div', stepSection),
                    progressFill: createMissingElement('progressFill', 'div', progressBar, ['progress-fill']),
                    pathSteps: createMissingElement('pathSteps', 'div', pathHistoryDiv),
                    strategyName: createMissingElement('strategyName', 'h2', resultSection),
                    strategyDetails: createMissingElement('strategyDetails', 'div', resultSection),
                    diceResult: createMissingElement('diceResult', 'div', diceSection)
                };
        
                const createdElements = Object.keys(elements).filter(key => {
                    const element = document.getElementById(elements[key].id);
                    return element && element !== document.getElementById(key);
                });
        
                if (createdElements.length > 0) {
                    console.warn('Created missing DOM elements in resetFlow:', createdElements);
                    console.warn('To avoid dynamic creation, add the following to your HTML:', createdElements.map(id => `<div id="${id}"></div>`).join('\n'));
                    if (elements.errorContainer) {
                        elements.errorContainer.classList.remove('hidden');
                    }
                } else if (elements.errorContainer) {
                    elements.errorContainer.classList.add('hidden');
                }
        
                if (elements.stepSection) elements.stepSection.classList.remove('hidden');
                if (elements.diceSection) elements.diceSection.classList.add('hidden');
                if (elements.resultSection) elements.resultSection.classList.add('hidden');
                if (elements.pathHistoryDiv) elements.pathHistoryDiv.classList.add('hidden');
                if (elements.stepNumber) elements.stepNumber.textContent = '1';
                if (elements.stepTitle) elements.stepTitle.textContent = '시작';
                if (elements.conditionBox) elements.conditionBox.innerHTML = '에라스무스의 전쟁 초기 전략을 결정합니다';
                if (elements.buttonGroup) elements.buttonGroup.innerHTML = '<button class="btn btn-primary" onclick="startFlow()">시작하기</button>';
                if (elements.progressFill) elements.progressFill.style.width = '0%';
            }
        
            function goBack() {
                if (pathHistory.length === 0) {
                    resetFlow();
                    return;
                }
        
                // Remove the last step from history
                const lastStep = pathHistory.pop();
                stepCount--;
        
                // Remove the last evaluated condition
                if (lastStep.step !== 'DICE') {
                    delete evaluatedConditions[lastStep.step];
                }
        
                // Determine the previous step
                if (pathHistory.length === 0) {
                    currentStep = 'start';
                } else {
                    currentStep = pathHistory[pathHistory.length - 1].step;
                    if (lastStep.step === 'DICE') {
                        currentStep = pathHistory.length > 0 ? pathHistory[pathHistory.length - 1].step : 'start';
                        pathHistory.pop();
                        stepCount--;
                        if (pathHistory.length > 0) {
                            delete evaluatedConditions[pathHistory[pathHistory.length - 1].step];
                        }
                    }
                }
        
                // Update UI
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const stepSection = createMissingElement('stepSection', 'div', document.body);
                const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
                const resultSection = createMissingElement('resultSection', 'div', document.body, ['hidden']);
                if (errorContainer) errorContainer.classList.add('hidden');
        
                stepSection.classList.remove('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.add('hidden');
                showStep(currentStep);
            }
        
            function showComplexConditionStep(stepId) {
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const stepSection = createMissingElement('stepSection', 'div', document.body);
                const stepNumber = createMissingElement('stepNumber', 'div', stepSection);
                const stepTitle = createMissingElement('stepTitle', 'h2', stepSection);
                const conditionBox = createMissingElement('conditionBox', 'div', stepSection);
                const buttonGroup = createMissingElement('buttonGroup', 'div', stepSection);
                if (errorContainer) errorContainer.classList.add('hidden');
        
                stepNumber.textContent = stepCount;
        
                let conditionText = '';
                let displayTitle = '';
        
                switch (stepId) {
                    case 'CD_CHECK':
                        displayTitle = 'C+D';
                        conditionText = '다음 조건을 모두 충족합니까? <li>일본이 가진 카드가 3장 이상</li> <li>일본이 통제Control하는 자원 헥스가 13개 미만</li>';
                        break;
                    case 'CJE_BIK_CHECK':
                        displayTitle = 'C+J+E+(B or I or K)';
                        conditionText = '일본이 카드를 3장 이상 가지고 있고, <br>과달카날과 라바울을 통제Control하며, <br>통제Control하는 자원 헥스가 13개 이상이며, <br> <br>다음 중 하나 이상이 참인 경우 <li>DEI 항복 목표들이 점령된 상태거나</li> <li>모든 DEI 항구가 일본군의 AZOI 영향권에 있거나</li> <li>일본이 뉴기니 항구 6개 중 4개를 통제Control하거나 AZOI를 행사하고 있는 경우</li>';
                        break;
                    case 'ACD_CHECK':
                        displayTitle = 'A+C+D';
                        conditionText = '다음 조건을 모두 충족합니까? <li>필리핀, DEI, 말라야에 있는 연합군 본부가 OOS 상태</li> <li>일본이 가진 카드가 3장 이상</li> <li>일본이 통제Control하는 자원 헥스가 13개 미만</li>';
                        break;
                    case 'E_OR_HI_CHECK':
                    case 'E_OR_HI_CHECK_FINAL':
                        displayTitle = 'E or (H+I)';
                        conditionText = '다음 중 하나 이상이 참입니까? <li>일본이 통제Control하는 자원 헥스가 13개 이상</li> <li>병참 평가 수치가 19 이하이고 모든 DEI 항구가 일본군의 AZOI 영향권에 있는 경우';
                        break;
                    case 'CL_CHECK':
                        displayTitle = 'C+L';
                        conditionText = '다음 조건을 모두 충족합니까? <li>일본이 가진 카드가 3장 이상</li><li>말라야, 필리핀, DEI 중 한 곳이 정복Conquered되기 까지 딱 1 헥스가 부족한 상황</li>';
                        break;
                    case 'C_FOR_E_OR_HI':
                        displayTitle = 'C';
                        conditionText = '일본이 가진 카드가 3장 이상입니까?';
                        break;
                    case 'C_FOR_E_OR_HI_FINAL':
                        displayTitle = 'C (최종 확인)';
                        conditionText = '일본이 가진 카드가 3장 이상입니까?';
                        break;
                    case 'F_FOR_CD':
                        displayTitle = 'F (제공권 결정)';
                        conditionText = '병참 평가 수치가 20 이상입니까?';
                        break;
                    case 'F_FOR_ACD':
                        displayTitle = 'F (남방자원 결정)';
                        conditionText = '병참 평가 수치가 20 이상입니까?';
                        break;
                    default:
                        displayTitle = '확인';
                        conditionText = '알 수 없는 조건';
                }
        
                stepTitle.textContent = displayTitle;
                conditionBox.innerHTML = ` ${conditionText}`;
                buttonGroup.innerHTML = `
                    <button class="btn btn-yes" onclick="selectChoice('${stepId}', true)">YES</button>
                    <button class="btn btn-no" onclick="selectChoice('${stepId}', false)">NO</button>
                    ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                `;
        
                updateProgress();
                updatePathHistory();
            }
        
            // 페이지 로드 시 초기화
            window.onload = function () {
                if (document.readyState === 'complete') {
                    resetFlow();
                } else {
                    window.addEventListener('DOMContentLoaded', resetFlow);
                }
            };
        </script>
    </body>
    </html> 
  </template>

  <!-- 2. 전쟁 중기 -->
  <template id="tmpl-mid">
    <!DOCTYPE html>
    <html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Japanese Erasmus Bot - 전쟁 중기</title>
        <!-- Malaya, DEI, Philippines이 항복했거나, 4턴이 이후인 경우에만 이 매트릭스를 따릅니다. 그 외에는 전쟁 초기 매트릭스를 사용합니다. -->
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                background: #2e2e2e;
                min-height: 100vh;
                margin: 0;
                padding: 20px;
                box-sizing: border-box;
                color: #d8d8d8;
            }
        
            .impl-note {
                font-style: italic;
                font-size: 14px;
                color: #ffffff;
                line-height: 1.6;
                margin: 4px 0;
            }
        
            .container {
                max-width: 800px;
                margin: 0 auto;
                background: #3c3c3c;
                border-radius: 8px;
                padding: 20px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            }
        
            .header {
                text-align: center;
                margin-bottom: 20px;
                padding: 15px;
                background: #4a4a4a;
                border-radius: 8px;
                color: #ffffff;
                border: 1px solid #5c5c5c;
            }
        
            .header h1 {
                margin: 0;
                font-size: 2rem;
                font-weight: 700;
            }
        
            .header p {
                margin: 8px 0 0 0;
                font-size: 1rem;
                font-weight: 400;
            }
        
            .progress-bar {
                background: #4a4a4a;
                border-radius: 5px;
                height: 6px;
                margin-bottom: 20px;
                overflow: hidden;
                border: 1px solid #5c5c5c;
            }
        
            .progress-fill {
                background: #4682b4;
                height: 100%;
                border-radius: 5px;
                transition: width 0.3s ease;
                width: 0%;
            }
        
            .step-section {
                background: #3c3c3c;
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 15px;
                border: 1px solid #5c5c5c;
            }
        
            .step-header {
                display: flex;
                align-items: center;
                margin-bottom: 15px;
            }
        
            .step-number {
                background: #4682b4;
                color: #ffffff;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                font-size: 1rem;
                margin-right: 15px;
            }
        
            .step-title {
                font-size: 1.3rem;
                font-weight: 600;
                color: #d8d8d8;
                margin: 0;
            }
        
            .condition-box {
                background: #4a4a4a;
                border-left: 4px solid #4682b4;
                border-radius: 5px;
                padding: 15px;
                margin: 15px 0;
                font-size: 1rem;
                line-height: 1.5;
                color: #c8c8c8;
            }
        
            .condition-box strong {
                color: #4682b4;
                font-size: 1.1rem;
            }
        
            .button-group {
                display: flex;
                gap: 15px;
                justify-content: center;
                margin-top: 20px;
            }
        
            .btn {
                padding: 10px 30px;
                border: none;
                border-radius: 5px;
                font-size: 1rem;
                font-weight: 500;
                cursor: pointer;
                transition: background 0.2s ease, transform 0.1s ease;
                text-transform: uppercase;
                min-width: 100px;
                font-family: 'Georgia', 'Times New Roman', Times, serif;
            }
        
            .btn-yes {
                background: #2e8b57;
                color: #ffffff;
            }
        
            .btn-yes:hover {
                background: #257a4b;
                transform: translateY(-2px);
            }
        
            .btn-no {
                background: #696969;
                color: #ffffff;
            }
        
            .btn-no:hover {
                background: #585858;
                transform: translateY(-2px);
            }
        
            .btn-primary {
                background: #4682b4;
                color: #ffffff;
            }
        
            .btn-primary:hover {
                background: #3a6b9a;
                transform: translateY(-2px);
            }
        
            .btn-secondary {
                background: #5c5c5c;
                color: #ffffff;
            }
        
            .btn-secondary:hover {
                background: #4b4b4b;
                transform: translateY(-2px);
            }
        
            .btn-back {
                background: #5c5c5c;
                color: #ffffff;
            }
        
            .btn-back:hover {
                background: #4b4b4b;
                transform: translateY(-2px);
            }
        
            .path-history {
                background: #4a4a4a;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 15px;
                border-left: 3px solid #2e8b57;
            }
        
            .path-step {
                display: flex;
                align-items: center;
                margin: 8px 0;
                padding: 8px;
                background: #3c3c3c;
                border-radius: 5px;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            }
        
            .path-step .step-icon {
                width: 25px;
                height: 25px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                margin-right: 10px;
                font-size: 0.8rem;
            }
        
            .path-step.yes .step-icon {
                background: #2e8b57;
                color: #ffffff;
            }
        
            .path-step.no .step-icon {
                background: #696969;
                color: #ffffff;
            }
        
            .dice-section {
                background: #4a4a4a;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                margin: 15px 0;
                border: 1px solid #5c5c5c;
            }
        
            .dice-result {
                font-size: 3rem;
                font-weight: bold;
                color: #d8d8d8;
                margin: 15px 0;
            }
        
            .result-section {
                background: #2e8b57;
                color: #ffffff;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                margin-top: 15px;
                border: 1px solid #3c3c3c;
            }
        
            .result-section h2 {
                margin: 0 0 15px 0;
                font-size: 2rem;
                display: none;
            }
        
            .result-section p {
                margin: 10px 0;
                font-size: 32px;
                white-space: pre-line;
                font-weight: bold;
                font-style: italic;
            }
        
            .strategy-details {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 5px;
                padding: 15px;
                margin-top: 15px;
            }
        
            .strategy-list {
                text-align: left;
                margin: 15px 0;
                list-style: none;
                padding: 0;
            }
        
            .strategy-list li {
                margin: 8px 0;
                padding: 8px 10px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 5px;
                border-left: 3px solid rgba(255, 255, 255, 0.3);
            }
        
            .sub-priority-list {
                list-style: none;
                padding-left: 20px;
                margin-top: 5px;
            }
        
            .sub-priority-list li {
                margin: 5px 0;
                padding: 5px 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 5px;
                border-left: 2px solid rgba(255, 255, 255, 0.4);
                font-size: 0.9rem;
            }
        
            .hidden {
                display: none;
            }
        
            @media (max-width: 768px) {
                .container {
                    padding: 15px;
                    margin: 10px;
                }
                
                .header h1 {
                    font-size: 1.5rem;
                }
                
                .button-group {
                    flex-direction: column;
                    align-items: center;
                }
                
                .btn {
                    width: 100%;
                    max-width: 180px;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>전쟁 중기 페이즈</h1>
                <br>Malaya, DEI, Philippines이 항복했거나 4턴 이후인 경우에만 사용합니다.<br>그 외에는 <b>전쟁 초기 차트</b>를 사용합니다.</strong>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div id="pathHistory" class="path-history hidden">
                <h4 style="margin-top: 0; color: #ffffff;">진행 경로</h4>
                <div id="pathSteps"></div>
            </div>

            <div id="stepSection" class="step-section">
                <div class="step-header">
                    <div class="step-number" id="stepNumber">1</div>
                    <h2 class="step-title" id="stepTitle">시작</h2>
                </div>
                
                <div class="condition-box" id="conditionBox">
                    첫 번째 조건을 확인해주세요.
                </div>
                
                <div class="button-group" id="buttonGroup">
                    <button class="btn btn-primary" onclick="startFlow()">시작하기</button>
                </div>
            </div>

            <div id="diceSection" class="dice-section hidden">
                <h3 style="margin: 0 0 20px 0; color: #2d3436;">Roll D10</h3>
                <div class="dice-result" id="diceResult">?</div>
                <div class="button-group">
                    <button class="btn btn-primary" onclick="rollDice()">Roll dice</button>
                </div>
            </div>

            <div id="resultSection" class="result-section hidden">
                <h2 id="strategyTitle">Strategy Result</h2>
                <p id="strategyName"></p>
                <div class="strategy-details" id="strategyDetails"></div>
                <div class="button-group" style="margin-top: 30px;">
                    <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                </div>
            </div>
        </div>

        <script>
            // Implementation notes
            const notes = {
                '[1]': '카드 및 조건이 있다면 나열된 순서대로 이벤트를 플레이합니다.',
                '[2]': '지정된 목표 지점에, 손실(소모전)을 견딜 수 있는 지상 유닛을 AA를 통해 상륙시킵니다.',
                '[3]': '일본이 자원을 최소 13개 점령할 때까지 최대한 많은 자원을 점령합니다. 우선 순위에 상관없이 가장 쉬운 목표부터 점령합니다: 비어있는 자원, 공군/해군 유닛이 점령한 자원, 가장 약한 유닛부터 가장 강한 유닛까지 지상 유닛이 점령한 자원 순으로 점령합니다. 동점인 경우 우선 순위를 따라 선택합니다.',
                '[4]': '가능하다면 목표에 AZOI를 전개합니다. 그렇지 않다면 모든 목표에 AZOI를 전개했거나 목표가 다 떨어질 때까지 우선순위에 따라 다음 목표로 이동합니다.',
                '[5]': '표시된 위치에 최소 지상 유닛 스텝 1개 또는 공중 유닛 스텝 1개를 배치합니다. 선택할 수 있는 경우 공중 유닛을 배치하고, 가능하다면 둘 다 배치합니다.',
            };
        
            // 전략 정보 데이터
            const strategies = {
                'Event Strategy': {
                    name: '이벤트 전략[1]',
                    details: [
                        '연합군 WiE > 0이면 WiE, 그 외 FOQ',
                        '일본이 ISR이면 ISR 종료, 그 외 FOQ',
                        '연합군이 전략적 합의 상태면 ISR 생성, 그 외 FOQ.',
                        '도쿄 로즈를 FOQ로',
                        '병력 보충을 FOQ로',
                        '날씨 카드를 FOQ로',
                        '이벤트로 플레이했을 때 미국 PW가 0이 되지 않는 한, 도조 카드를 TOC로 플레이',
                        '기타: FOQ가 없다면 카드를 FOQ에 넣음.'
                    ]
                },
                'Resource Strategy': {
                    name: '자원 전략',
                    details: [
                        '자원 확보',
                        '뉴기니 항복<em style="font-size:0.9em;">New Guinie Surrender</em>',
                        '버마 항복<em style="font-size:0.9em;">Burma Surrender</em>',
                        '중국 항복<em style="font-size:0.9em;">China Surrender</em>',
                        '항구 증원[5]<em style="font-size:0.9em;">Reinforce Ports</em>'
                    ]
                },
                'Central Pacific Strategy': {
                    name: '중부 태평양 전략',
                    details: [
                        'Attu/Kiska[2]',
                        'Defend Marshalls',
                        'Midway[2]',
                        '미군 함대 공격'
                    ]
                },
                'CBI Strategy': {
                    name: 'CBI 전략',
                    details: [
                        '버마 항복<em style="font-size:0.9em;">Burma Surrender</em>',
                        '중국 항복<em style="font-size:0.9em;">China Surrender</em>',
                        '항구 증원[5]<em style="font-size:0.9em;">Reinforce Ports</em>',
                        '인도 항복<em style="font-size:0.9em;">India Surrender</em>',
                        '이벤트 전략[1]'
                    ]
                },
                'Defense Perimeter Strategy': {
                    name: '방어선 전략',
                    details: [
                        '남태평양 측면<em style="font-size:0.9em;">South Pacific Flank</em>',
                        '중국 항복<em style="font-size:0.9em;">China Surrender</em>',
                        '항구 증원[5]<em style="font-size:0.9em;">Reinforce Ports</em>',
                        'CBI 전략'
                    ]
                },
                'India Strategy': {
                    name: '인도 전략',
                    details: [
                        '인도 항복<em style="font-size:0.9em;">India Surrender</em>',
                        '중국 항복<em style="font-size:0.9em;">China Surrender</em>',
                        '항구 증원[5]<em style="font-size:0.9em;">Reinforce Ports</em>'
                    ]
                },
                'Pass': {
                    name: 'PASS',
                    details: [
                        '행동을 패스합니다'
                ]
            }
            };
        
            // 하위 우선순위 목록
            const subPriorities = {
                '이벤트 전략[1]': [
                    '연합군 WiE > 0이면 WiE, 그 외 FOQ',
                    '일본이 ISR이면 ISR 종료, 그 외 FOQ',
                    '연합군이 전략적 합의 상태면 ISR 생성, 그 외 FOQ.',
                    '도쿄 로즈를 FOQ로',
                    '병력 보충을 FOQ로',
                    '날씨 카드를 FOQ로',
                    '이벤트로 플레이했을 때 미국 PW가 0이 되지 않는 한, 도조 카드를 TOC로 플레이',
                    '기타: FOQ에 넣을 카드가 없는 경우.'
                ],
                'CBI 전략': [
                    '버마 항복<em style="font-size:0.9em;">Burma Surrender</em>',
                    '중국 항복<em style="font-size:0.9em;">China Surrender</em>',
                    '항구 증원[5]<em style="font-size:0.9em;">Reinforce Ports</em>',
                    '인도 항복<em style="font-size:0.9em;">India Surrender</em>',
                    '이벤트 전략[1]'
                ],
                '버마 항복<em style="font-size:0.9em;">Burma Surrender</em>': [
                    'Rangoon',
                    'Mandalay',
                    'Lashio',
                    'Myitkyina'
                ],
                '중국 항복<em style="font-size:0.9em;">China Surrender</em>': [
                    'Lashio',
                    '중국 공세<em style="font-size:0.9em;">China Offensive</em>',
                    '중국 이벤트'
                ],
                '인도 항복<em style="font-size:0.9em;">India Surrender</em>': [
                    'Akyab',
                    'Imphal',
                    'Dimasur',
                    'Jarhat',
                    'Ledo',
                    'Dacca'
                ],
                '뉴기니 항복<em style="font-size:0.9em;">New Guinie Surrender</em>': [
                    'Biak',
                    'Vogelkop',
                    'Hollandia',
                    'Lae',
                    'Buna',
                    'Wewak',
                    'Gili-Gili',
                    'Port Moresby'

                ],
                '항구 증원[5]<em style="font-size:0.9em;">Reinforce Ports</em>': [
                    'Truk',
                    'Rabaul',
                    'Saipan',
                    'Davao',
                    'Saigon',
                    'Eniwetok',
                    'Kwajalein',
                    'Palau Islands',
                    'Timor',
                    'Kendari',
                    'Soerabja',
                    'Balikpapan',
                    'Tarakan',
                    'Rangoon',
                    'Mandalay',
                    'Lashio'
                ],
                '자원 확보': [
                    'Seoul',
                    'Manila',
                    'Kuantan',
                    '모든 DEI 자원',
                    'Vogelkop',
                    'Rangoon'
                ],
                '남태평양 측면<em style="font-size:0.9em;">South Pacific Flank</em>': [
                    'Hollandia',
                    'Lae',
                    'Buna',
                    'Biak',
                    'Wewak',
                    'Buin'
                ]
            };
        
            // 정의
            const conditions = {
                'A': '일본이 카드를 3장 이상 가지고 있습니까?',
                'B': '일본이 PASS를 사용할 수 있습니까?',
                'C': '일본이 통제Control하는 자원 헥스가 13개 미만입니까?',
                'D': '병참 평가 수치가 20 이상입니까?',
                'E': '미국의 PW가 4미만입니까?',
                'F': '버마가 항복했습니까?',
                'G': '병참 평가 수치가 15 이상입니까?',
                'H': '간디 카드를 사용할 수 있습니까?',
                'I': '일본이 연합군보다 버마/인도 북부에 더 많은 대규모 군대 지상 유닛 스텝을 보유하고 있습니까?<br>대규모 지상 유닛 스텝: 총 방어력이 12 이상인 스텝들만 해당',
                'J': '병참 평가 수치가 18 이상입니까?'
            };
        
            let currentStep = 'start';
            let pathHistory = [];
            let stepCount = 0;
            let evaluatedConditions = {};
        
            // Helper function to create missing DOM elements
            function createMissingElement(id, tag, parent, classes = []) {
                let element = document.getElementById(id);
                if (!element) {
                    console.warn(`Creating missing element: ${id}`);
                    element = document.createElement(tag);
                    element.id = id;
                    classes.forEach(cls => element.classList.add(cls));
                    if (parent && parent.appendChild) {
                        parent.appendChild(element);
                    } else {
                        document.body.appendChild(element);
                    }
                }
                return element;
            }
        
            function startFlow() {
                currentStep = 'A';
                stepCount = 1;
                pathHistory = [];
                evaluatedConditions = {};
                showStep('A');
            }
        
            function showStep(stepId) {
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const stepSection = createMissingElement('stepSection', 'div', document.body);
                const stepNumber = createMissingElement('stepNumber', 'div', stepSection);
                const stepTitle = createMissingElement('stepTitle', 'h2', stepSection);
                const conditionBox = createMissingElement('conditionBox', 'div', stepSection);
                const buttonGroup = createMissingElement('buttonGroup', 'div', stepSection);
        
                if (errorContainer) errorContainer.classList.add('hidden');
        
                stepNumber.textContent = stepCount;
        
                if (stepId === 'DICE') {
                    const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
                    const diceResult = createMissingElement('diceResult', 'div', diceSection);
                    stepSection.classList.add('hidden');
                    diceSection.classList.remove('hidden');
                    diceResult.textContent = '-';
                    buttonGroup.innerHTML = `
                        <button class="btn btn-primary" onclick="rollDice()">Roll dice</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                    return;
                }
        
                // 복합 조건들 처리 (e.g., (H or I) + J)
                if (stepId === '(H or I) + J_CHECK') {
                    showComplexConditionStep(stepId);
                    return;
                }
        
                // 기본 조건들 처리
                if (conditions[stepId]) {
                    stepTitle.textContent = `${stepId} 확인`;
                    conditionBox.innerHTML = ` ${conditions[stepId]}`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-yes" onclick="selectChoice('${stepId}', true)">YES</button>
                        <button class="btn btn-no" onclick="selectChoice('${stepId}', false)">NO</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                } else if (stepId === 'start') {
                    stepTitle.textContent = '시작';
                    conditionBox.innerHTML = `전쟁 중기 페이즈`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-primary" onclick="startFlow()">시작하기</button>
                    `;
                }
        
                updateProgress();
                updatePathHistory();
            }
        
            function selectChoice(conditionId, choice) {
                evaluatedConditions[conditionId] = choice;
                pathHistory.push({ step: conditionId, choice: choice, stepNum: stepCount });
                stepCount++;
        
                const nextStep = getNextStep(conditionId, choice);
        
                if (nextStep.startsWith('STRATEGY_')) {
                    const strategy = nextStep.replace('STRATEGY_', '');
                    showResult(strategy);
                } else {
                    currentStep = nextStep;
                    showStep(nextStep);
                }
            }
        
            function getNextStep(conditionId, choice) {
                switch (conditionId) {
                    case 'A':
                        return choice ? 'C' : 'B';
                    case 'B':
                        return choice ? 'STRATEGY_Pass' : 'STRATEGY_Event Strategy';
                    case 'C':
                        return choice ? 'STRATEGY_Resource Strategy' : 'D';
                    case 'D':
                        return choice ? 'E' : 'G';
                    case 'E':
                        return choice ? 'STRATEGY_Central Pacific Strategy' : 'F';
                    case 'F':
                        return choice ? '(H or I) + J_CHECK' : 'STRATEGY_CBI Strategy';
                    case 'G':
                        return choice ? 'F' : 'STRATEGY_Defense Perimeter Strategy';
                    case '(H or I) + J_CHECK':
                        return choice ? 'STRATEGY_India Strategy' : 'STRATEGY_Defense Perimeter Strategy';
                    default:
                        return 'STRATEGY_Defense Perimeter Strategy';
                }
            }
        
            function rollDice() {
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
                const diceResult = createMissingElement('diceResult', 'div', diceSection);
                if (errorContainer) errorContainer.classList.add('hidden');
        
                const diceValue = Math.floor(Math.random() * 10); // 0-9
                diceResult.textContent = diceValue;
        
                let strategy;
                if (diceValue >= 0 && diceValue <= 2) {
                    strategy = 'Event Strategy';
                } else if (diceValue >= 3 && diceValue <= 6) {
                    strategy = 'Central Pacific Strategy';
                } else if (diceValue >= 7 && diceValue <= 9) {
                    strategy = 'India Strategy';
                }
        
                pathHistory.push({
                    step: 'DICE',
                    choice: diceValue,
                    stepNum: stepCount,
                    isResult: true,
                    result: strategy
                });
        
                setTimeout(() => showResult(strategy), 1000);
            }
        
            function showResult(strategyKey) {
                const strategy = strategies[strategyKey];
                if (!strategy) {
                    console.error('Strategy not found:', strategyKey);
                    return;
                }
        
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const stepSection = createMissingElement('stepSection', 'div', document.body);
                const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
                const resultSection = createMissingElement('resultSection', 'div', document.body, ['hidden']);
                const strategyName = createMissingElement('strategyName', 'h2', resultSection);
                const strategyDetails = createMissingElement('strategyDetails', 'div', resultSection);
                const buttonGroup = resultSection.querySelector('.button-group') || createMissingElement('button-group', 'div', resultSection, ['button-group']);
        
                if (errorContainer) errorContainer.classList.add('hidden');
        
                stepSection.classList.add('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.remove('hidden');
                strategyName.textContent = strategy.name;
        
                // Extract annotations from strategy name, details, and sub-priorities
                const annotationRegex = /\[\d+\]/g;
                const annotations = new Set();
                if (strategy.name.match(annotationRegex)) {
                    strategy.name.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                }
                strategy.details.forEach(detail => {
                    if (detail.match(annotationRegex)) {
                        detail.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                    }
                    // Check sub-priorities for annotations
                    if (subPriorities[detail]) {
                        subPriorities[detail].forEach(sub => {
                            if (sub.match(annotationRegex)) {
                                sub.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                            }
                        });
                    }
                });
        
                strategyDetails.innerHTML = `
                    <h4 style="margin-top: 0; color: #fff;">전략 우선순위:</h4>
                    <ul class="strategy-list">
                        ${strategy.details.map(detail => `
                            <li>
                                ${detail}
                                ${subPriorities[detail] ? `
                                    <ul class="sub-priority-list">
                                        ${subPriorities[detail].map(sub => `<li>${sub}</li>`).join('')}
                                    </ul>
                                ` : ''}
                            </li>
                        `).join('')}
                    </ul>
                    ${annotations.size > 0 ? `
                        <h4 style="margin-top: 20px; color: #fff;">주석:</h4>
                        <ul class="strategy-list">
                            ${Array.from(annotations).sort().map(annotation => `
                                <li class="impl-note">${annotation}: ${notes[annotation]}</li>
                            `).join('')}
                        </ul>
                    ` : ''}
                `;
        
                buttonGroup.innerHTML = `
                    <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                    ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                `;
        
                updateProgress();
                updatePathHistory();
            }
        
            function updateProgress() {
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const progressBar = createMissingElement('progress-bar', 'div', document.body, ['progress-bar']);
                const progressFill = createMissingElement('progressFill', 'div', progressBar, ['progress-fill']);
                if (errorContainer) errorContainer.classList.add('hidden');
        
                const totalSteps = 15; // 대략적인 최대 단계 수
                const progress = Math.min((stepCount / totalSteps) * 100, 100);
                progressFill.style.width = progress + '%';
            }
        
            function updatePathHistory() {
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const pathHistoryDiv = createMissingElement('pathHistory', 'div', document.body, ['hidden']);
                const pathStepsDiv = createMissingElement('pathSteps', 'div', pathHistoryDiv);
                if (errorContainer) errorContainer.classList.add('hidden');
        
                if (pathHistory.length === 0) {
                    pathHistoryDiv.classList.add('hidden');
                    return;
                }
        
                pathStepsDiv.innerHTML = '';
        
                pathHistory.forEach(step => {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = `path-step ${step.choice && step.step !== 'DICE' ? 'yes' : step.step !== 'DICE' ? 'no' : ''}`;
        
                    if (step.step === 'DICE') {
                        stepDiv.innerHTML = `
                            <div class="step-icon">${step.choice}</div>
                            <div>
                                <strong>Roll dice:</strong> ${step.choice} 
                                ${step.result ? `→ ${strategies[step.result].name}` : ''}
                            </div>
                        `;
                    } else {
                        let conditionText = '';
                        if (conditions[step.step]) {
                            conditionText = conditions[step.step];
                        } else if (step.step === '(H or I) + J_CHECK') {
                            conditionText = 'H 또는 I가 참이고 J가 참입니까?';
                        } else {
                            conditionText = step.step;
                        }
        
                        stepDiv.innerHTML = `
                            <div class="step-icon">${step.choice ? 'Y' : 'N'}</div>
                            <div>
                                <strong>${step.step}:</strong> 
                                ${conditionText} → ${step.choice ? 'YES' : 'NO'}
                            </div>
                        `;
                    }
        
                    pathStepsDiv.appendChild(stepDiv);
                });
        
                pathHistoryDiv.classList.remove('hidden');
            }
        
            function resetFlow() {
                currentStep = 'start';
                stepCount = 0;
                pathHistory = [];
                evaluatedConditions = {};
        
                // Step 1: Create top-level elements
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const stepSection = createMissingElement('stepSection', 'div', document.body);
                const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
                const resultSection = createMissingElement('resultSection', 'div', document.body, ['hidden']);
                const pathHistoryDiv = createMissingElement('pathHistory', 'div', document.body, ['hidden']);
                const progressBar = createMissingElement('progress-bar', 'div', document.body, ['progress-bar']);
        
                // Step 2: Create child elements that depend on top-level elements
                const elements = {
                    errorContainer,
                    stepSection,
                    diceSection,
                    resultSection,
                    pathHistoryDiv,
                    progressBar,
                    stepNumber: createMissingElement('stepNumber', 'div', stepSection),
                    stepTitle: createMissingElement('stepTitle', 'h2', stepSection),
                    conditionBox: createMissingElement('conditionBox', 'div', stepSection),
                    buttonGroup: createMissingElement('buttonGroup', 'div', stepSection),
                    progressFill: createMissingElement('progressFill', 'div', progressBar, ['progress-fill']),
                    pathSteps: createMissingElement('pathSteps', 'div', pathHistoryDiv),
                    strategyName: createMissingElement('strategyName', 'h2', resultSection),
                    strategyDetails: createMissingElement('strategyDetails', 'div', resultSection),
                    diceResult: createMissingElement('diceResult', 'div', diceSection)
                };
        
                const createdElements = Object.keys(elements).filter(key => {
                    const element = document.getElementById(elements[key].id);
                    return element && element !== document.getElementById(key); // Check if element was newly created
                });
        
                if (createdElements.length > 0) {
                    console.warn('Created missing DOM elements in resetFlow:', createdElements);
                    console.warn('To avoid dynamic creation, add the following to your HTML:', createdElements.map(id => `<div id="${id}"></div>`).join('\n'));
                    if (elements.errorContainer) {
                        // elements.errorContainer.innerHTML = `경고: 다음 HTML 요소가 누락되어 동적으로 생성되었습니다: ${createdElements.join(', ')}. HTML에 추가하세요.`;
                        elements.errorContainer.classList.remove('hidden');
                    }
                } else if (elements.errorContainer) {
                    elements.errorContainer.classList.add('hidden');
                }
        
                if (elements.stepSection) elements.stepSection.classList.remove('hidden');
                if (elements.diceSection) elements.diceSection.classList.add('hidden');
                if (elements.resultSection) elements.resultSection.classList.add('hidden');
                if (elements.pathHistoryDiv) elements.pathHistoryDiv.classList.add('hidden');
                if (elements.stepNumber) elements.stepNumber.textContent = '1';
                if (elements.stepTitle) elements.stepTitle.textContent = '시작';
                if (elements.conditionBox) elements.conditionBox.innerHTML = '에라스무스의 전쟁 중기 전략을 결정합니다';
                if (elements.buttonGroup) elements.buttonGroup.innerHTML = '<button class="btn btn-primary" onclick="startFlow()">시작하기</button>';
                if (elements.progressFill) elements.progressFill.style.width = '0%';
            }
        
            function goBack() {
                if (pathHistory.length === 0) {
                    resetFlow();
                    return;
                }
        
                // Remove the last step from history
                const lastStep = pathHistory.pop();
                stepCount--;
        
                // Remove the last evaluated condition
                if (lastStep.step !== 'DICE') {
                    delete evaluatedConditions[lastStep.step];
                }
        
                // Determine the previous step
                if (pathHistory.length === 0) {
                    currentStep = 'start';
                } else {
                    currentStep = pathHistory[pathHistory.length - 1].step;
                    // If the last step was DICE, we need to go back to the step before DICE
                    if (lastStep.step === 'DICE') {
                        currentStep = pathHistory.length > 0 ? pathHistory[pathHistory.length - 1].step : 'start';
                        pathHistory.pop(); // Remove the step before DICE as well
                        stepCount--;
                        if (pathHistory.length > 0) {
                            delete evaluatedConditions[pathHistory[pathHistory.length - 1].step];
                        }
                    }
                }
        
                // Update UI
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const stepSection = createMissingElement('stepSection', 'div', document.body);
                const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
                const resultSection = createMissingElement('resultSection', 'div', document.body, ['hidden']);
                if (errorContainer) errorContainer.classList.add('hidden');
        
                stepSection.classList.remove('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.add('hidden');
                showStep(currentStep);
            }
        
            function showComplexConditionStep(stepId) {
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const stepSection = createMissingElement('stepSection', 'div', document.body);
                const stepNumber = createMissingElement('stepNumber', 'div', stepSection);
                const stepTitle = createMissingElement('stepTitle', 'h2', stepSection);
                const conditionBox = createMissingElement('conditionBox', 'div', stepSection);
                const buttonGroup = createMissingElement('buttonGroup', 'div', stepSection);
                if (errorContainer) errorContainer.classList.add('hidden');
        
                stepNumber.textContent = stepCount;
        
                let conditionText = '';
                let displayTitle = '';
        
                if (stepId === '(H or I) + J_CHECK') {
                    displayTitle = '(H or I) + J';
                    conditionText = '<br>다음 조건을 충족합니까? <li>H: 간디 카드를 사용할 수 있습니까?</li> <li>I: 일본이 연합군보다 버마/인도 북부에 더 많은 대규모 군대 지상 유닛 스텝을 보유하고 있습니까?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(대규모 지상 유닛 스텝: 총 방어력이 12 이상인 스텝들만 해당)</li> <li>J: 병참 평가 수치가 18 이상입니까?</li>';
                }
        
                stepTitle.textContent = displayTitle;
                conditionBox.innerHTML = ` ${conditionText}`;
                buttonGroup.innerHTML = `
                    <button class="btn btn-yes" onclick="selectChoice('${stepId}', true)">YES</button>
                    <button class="btn btn-no" onclick="selectChoice('${stepId}', false)">NO</button>
                    ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                `;
        
                updateProgress();
                updatePathHistory();
            }
        
            // 페이지 로드 시 초기화
            window.onload = function () {
                if (document.readyState === 'complete') {
                    resetFlow();
                } else {
                    window.addEventListener('DOMContentLoaded', resetFlow);
                }
            };
        </script>
    </body>
    </html>
  </template>

  <!-- 3. 전쟁 말기 -->
  <template id="tmpl-late">
    <!DOCTYPE html>
    <html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Japanese Erasmus Bot -  전쟁 말기</title>
        <!-- 연합군이 도쿄 8헥스 이내에 있는 항구를 점령했을 때만 이 매트릭스를 따릅니다. 그렇지 않은 경우 전쟁 중기 매트릭스를 사용합니다 -->
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                background: #2e2e2e;
                min-height: 100vh;
                margin: 0;
                padding: 20px;
                box-sizing: border-box;
                color: #d8d8d8;
            }
        
            .impl-note {
                font-style: italic;
                font-size: 14px;
                color: #ffffff;
                line-height: 1.6;
                margin: 4px 0;
            }
        
            .container {
                max-width: 800px;
                margin: 0 auto;
                background: #3c3c3c;
                border-radius: 8px;
                padding: 20px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            }
        
            .header {
                text-align: center;
                margin-bottom: 20px;
                padding: 15px;
                background: #4a4a4a;
                border-radius: 8px;
                color: #ffffff;
                border: 1px solid #5c5c5c;
            }
        
            .header h1 {
                margin: 0;
                font-size: 2rem;
                font-weight: 700;
            }
        
            .header p {
                margin: 8px 0 0 0;
                font-size: 1rem;
                font-weight: 400;
            }
        
            .progress-bar {
                background: #4a4a4a;
                border-radius: 5px;
                height: 6px;
                margin-bottom: 20px;
                overflow: hidden;
                border: 1px solid #5c5c5c;
            }
        
            .progress-fill {
                background: #4682b4;
                height: 100%;
                border-radius: 5px;
                transition: width 0.3s ease;
                width: 0%;
            }
        
            .step-section {
                background: #3c3c3c;
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 15px;
                border: 1px solid #5c5c5c;
            }
        
            .step-header {
                display: flex;
                align-items: center;
                margin-bottom: 15px;
            }
        
            .step-number {
                background: #4682b4;
                color: #ffffff;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                font-size: 1rem;
                margin-right: 15px;
            }
        
            .step-title {
                font-size: 1.3rem;
                font-weight: 600;
                color: #d8d8d8;
                margin: 0;
            }
        
            .condition-box {
                background: #4a4a4a;
                border-left: 4px solid #4682b4;
                border-radius: 5px;
                padding: 15px;
                margin: 15px 0;
                font-size: 1rem;
                line-height: 1.5;
                color: #c8c8c8;
            }
        
            .condition-box strong {
                color: #4682b4;
                font-size: 1.1rem;
            }
        
            .button-group {
                display: flex;
                gap: 15px;
                justify-content: center;
                margin-top: 20px;
            }
        
            .btn {
                padding: 10px 30px;
                border: none;
                border-radius: 5px;
                font-size: 1rem;
                font-weight: 500;
                cursor: pointer;
                transition: background 0.2s ease, transform 0.1s ease;
                text-transform: uppercase;
                min-width: 100px;
                font-family: 'Georgia', 'Times New Roman', Times, serif;
            }
        
            .btn-yes {
                background: #2e8b57;
                color: #ffffff;
            }
        
            .btn-yes:hover {
                background: #257a4b;
                transform: translateY(-2px);
            }
        
            .btn-no {
                background: #696969;
                color: #ffffff;
            }
        
            .btn-no:hover {
                background: #585858;
                transform: translateY(-2px);
            }
        
            .btn-primary {
                background: #4682b4;
                color: #ffffff;
            }
        
            .btn-primary:hover {
                background: #3a6b9a;
                transform: translateY(-2px);
            }
        
            .btn-secondary {
                background: #5c5c5c;
                color: #ffffff;
            }
        
            .btn-secondary:hover {
                background: #4b4b4b;
                transform: translateY(-2px);
            }
        
            .btn-back {
                background: #5c5c5c;
                color: #ffffff;
            }
        
            .btn-back:hover {
                background: #4b4b4b;
                transform: translateY(-2px);
            }
        
            .path-history {
                background: #4a4a4a;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 15px;
                border-left: 3px solid #2e8b57;
            }
        
            .path-step {
                display: flex;
                align-items: center;
                margin: 8px 0;
                padding: 8px;
                background: #3c3c3c;
                border-radius: 5px;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            }
        
            .path-step .step-icon {
                width: 25px;
                height: 25px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                margin-right: 10px;
                font-size: 0.8rem;
            }
        
            .path-step.yes .step-icon {
                background: #2e8b57;
                color: #ffffff;
            }
        
            .path-step.no .step-icon {
                background: #696969;
                color: #ffffff;
            }
        
            .dice-section {
                background: #4a4a4a;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                margin: 15px 0;
                border: 1px solid #5c5c5c;
            }
        
            .dice-result {
                font-size: 3rem;
                font-weight: bold;
                color: #d8d8d8;
                margin: 15px 0;
            }
        
            .result-section {
                background: #2e8b57;
                color: #ffffff;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                margin-top: 15px;
                border: 1px solid #3c3c3c;
            }
        
            .result-section h2 {
                margin: 0 0 15px 0;
                font-size: 2rem;
                display: none;
            }
        
            .result-section p {
                margin: 10px 0;
                font-size: 32px;
                white-space: pre-line;
                font-weight: bold;
                font-style: italic;
            }
        
            .strategy-details {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 5px;
                padding: 15px;
                margin-top: 15px;
            }
        
            .strategy-list {
                text-align: left;
                margin: 15px 0;
                list-style: none;
                padding: 0;
            }
        
            .strategy-list li {
                margin: 8px 0;
                padding: 8px 10px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 5px;
                border-left: 3px solid rgba(255, 255, 255, 0.3);
            }
        
            .sub-priority-list {
                list-style: none;
                padding-left: 20px;
                margin-top: 5px;
            }
        
            .sub-priority-list li {
                margin: 5px 0;
                padding: 5px 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 5px;
                border-left: 2px solid rgba(255, 255, 255, 0.4);
                font-size: 0.9rem;
            }
        
            .hidden {
                display: none;
            }
        
            @media (max-width: 768px) {
                .container {
                    padding: 15px;
                    margin: 10px;
                }
                
                .header h1 {
                    font-size: 1.5rem;
                }
                
                .button-group {
                    flex-direction: column;
                    align-items: center;
                }
                
                .btn {
                    width: 100%;
                    max-width: 180px;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>전쟁 말기 페이즈</h1>
                <br>
                연합군이 도쿄 8헥스 이내에 있는 항구를 점령했을 때만 사용합니다. <br>그외에는 <b>전쟁 중기 차트</b>를 사용합니다
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div id="pathHistory" class="path-history hidden">
                <h4 style="margin-top: 0; color: #ffffff;">진행 경로</h4>
                <div id="pathSteps"></div>
            </div>

            <div id="stepSection" class="step-section">
                <div class="step-header">
                    <div class="step-number" id="stepNumber">1</div>
                    <h2 class="step-title" id="stepTitle">시작</h2>
                </div>
                
                <div class="condition-box" id="conditionBox">
                    첫 번째 조건을 확인해주세요.
                </div>
                
                <div class="button-group" id="buttonGroup">
                    <button class="btn btn-primary" onclick="startFlow()">시작하기</button>
                </div>
            </div>

            <div id="diceSection" class="dice-section hidden">
                <h3 style="margin: 0 0 20px 0; color: #2d3436;">Roll D10</h3>
                <div class="dice-result" id="diceResult">?</div>
                <div class="button-group">
                    <button class="btn btn-primary" onclick="rollDice()">Roll dice</button>
                </div>
            </div>

            <div id="resultSection" class="result-section hidden">
                <h2 id="strategyTitle">Strategy Result</h2>
                <p id="strategyName"></p>
                <div class="strategy-details" id="strategyDetails"></div>
                <div class="button-group" style="margin-top: 30px;">
                    <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                </div>
            </div>
        </div>

        <script>
            // Implementation notes
            const notes = {
                '[1]': '카드 및 조건이 있다면 나열된 순서대로 이벤트를 플레이합니다. 12번 턴에는 카드를 절대 FO로 사용할 수 없습니다.',
                '[2]': '일본이 통제하는 헥스만 병력이 주둔하고 있는 것으로Garrison로 간주합니다.',
                '[3]': '혼슈에 공중 또는 해군 보충 유닛을 배치합니다. 공중 유닛을 사용해서 혼슈에 있는 일본 본부와 일본이 통제하는 자원 헥스 사이의 통신선(AZOI)을 유지합니다.',
                '[4]': '혼슈에 있는 연합군 지상 유닛에 인접한 헥스를 모두 점령할 때까지 지상 유닛을 연합군 지상 유닛 인접 헥스로 이동합니다.',
                '[5]': '지상 유닛이 있는 혼슈의 각 헥스마다, 가능하다면 해당 헥스에 공군 또는 해군 유닛 배치를 시도합니다.',
                '[6]': '일본 지상 유닛이 혼슈에 있는 연합군 유닛과 인접한 모든 헥스를 점령했다면, 가능한 많은 유닛으로 연합군 지상 유닛을 공격합니다. 선택할 수 있다면, 가장 강력한 유닛을 먼저 사용합니다.',
                '[7]': '혼슈 전투 헥스마다, 가능하다면 해당 전투 헥스를 지원하도록 하나의 공군 또는 해군 유닛을 배치합니다(해군을 헥스 안으로 이동시키거나, 공중 유닛이 범위 내에서 공격하는 방식).',
                '[8]': '마지막 지상 유닛 스텝까지 싸웁니다.'
            };
        
            // 전략 정보 데이터
            const strategies = {
                'Event Strategy': {
                    name: '이벤트 전략[1]',
                    details: [
                        '자원[3]',
                        '연합군이 전략적 합의 상태면 ISR 생성.',
                        '일본이 ISR이면 ISR 종료',
                        '도쿄 로즈 이벤트 발동',
                        '강제로 도조 이벤트 발동',
                        '마지막 턴이 아니라면, 날씨 카드를 FOQ로',
                        '이벤트로 플레이했을 때 미국 PW가 0이 되지 않는 한, 도조 카드를 TOC로 플레이',
                        '기타: FOQ가 없다면 카드를 FOQ에 넣음'
                    ]
                },
                'Final Perimeter Strategy': {
                    name: '최종 방어선 전략',
                    details: [
                        '항구 주둔[2]',
                        '공군 기지 주둔[2]',
                        '일본 항구 주둔[2]'
                    ]
                },
                'Final Defense Strategy': {
                    name: '최종 방어 전략',
                    details: [
                        '병력 집결[4]',
                        '공중/해상 지원[5]',
                        '반자이 돌격[6][7][8]'
                    ]
                },
                'Pass': {
                    name: 'PASS (작전 중지)',
                    details: [
                        '행동을 패스합니다'
                    ]
                }
            };
        
            // 하위 우선순위 목록
            const subPriorities = {
                '공군 기지 주둔[2]': [
                    'Iwo Jima',
                    'Kyoto'
                ],
                '항구 주둔[2]': [
                    'Okinawa',
                    'Seoul',
                    'Pusan',
                    'Tainan',
                    'Saipan/Tinian'
                ],
                '일본 항구 주둔[2]': [
                    'Sasebo',
                    'Kure',
                    'Tokyo',
                    'Osaka',
                    'Nagoya',
                    'Ominato',
                    'Hakodate'
                ]
            };
        
            // 정의
            const conditions = {
                'A': '일본이 가진 카드가 3장 이상입니까?',
                'B': '도쿄에서 8헥스 이내에 있고 중국 항구가 아닌 항구에 병력이 주둔하고 있습니까?[2]',
                'C': '도쿄에서 5헥스 이내에 있고 중국 공군기지(항구 제외)가 아닌 공군기지에 병력이 주둔하고 있습니까?[2]',
                'D': '일본에게 사용 가능한 PASS가 남아 있습니까?',
                'E': '혼슈에 연합군 지상 유닛이 있습니까?'
            };
        
            let currentStep = 'start';
            let pathHistory = [];
            let stepCount = 0;
            let evaluatedConditions = {};
        
            // Helper function to create missing DOM elements
        function createMissingElement(id, tag, parent, classes = []) {
            let element = document.getElementById(id);
            if (!element) {
                console.warn(`Creating missing element: ${id}`);
                element = document.createElement(tag);
                element.id = id;
                classes.forEach(cls => element.classList.add(cls));
                if (parent && parent.appendChild) {
                    parent.appendChild(element);
                } else {
                    document.body.appendChild(element);
                }
            }
            return element;
        }

        function startFlow() {
            currentStep = 'A';
            stepCount = 1;
            pathHistory = [];
            evaluatedConditions = {};
            showStep('A');
        }

        function showStep(stepId) {
            const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
            const stepSection = createMissingElement('stepSection', 'div', document.body);
            const stepNumber = createMissingElement('stepNumber', 'div', stepSection);
            const stepTitle = createMissingElement('stepTitle', 'h2', stepSection);
            const conditionBox = createMissingElement('conditionBox', 'div', stepSection);
            const buttonGroup = createMissingElement('buttonGroup', 'div', stepSection);

            if (errorContainer) errorContainer.classList.add('hidden');

            stepNumber.textContent = stepCount;

            if (stepId === 'B+C') {
                stepTitle.textContent = 'B+C 확인';
                conditionBox.innerHTML = ` <br>다음 조건을 모두 충족합니까? <ul><li>${conditions['B']}</li><li>${conditions['C']}</li></ul>`;
                buttonGroup.innerHTML = `
                    <button class="btn btn-yes" onclick="selectChoice('B+C', true)">YES</button>
                    <button class="btn btn-no" onclick="selectChoice('B+C', false)">NO</button>
                    ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                `;
            } else if (stepId === 'DICE') {
                const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
                const diceResult = createMissingElement('diceResult', 'div', diceSection);
                stepSection.classList.add('hidden');
                diceSection.classList.remove('hidden');
                diceResult.textContent = '-';
                buttonGroup.innerHTML = `
                    <button class="btn btn-primary" onclick="rollDice()">Roll dice</button>
                    ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                `;
                return;
            } else if (conditions[stepId]) {
                stepTitle.textContent = `${stepId} 확인`;
                conditionBox.innerHTML = ` ${conditions[stepId]}`;
                buttonGroup.innerHTML = `
                    <button class="btn btn-yes" onclick="selectChoice('${stepId}', true)">YES</button>
                    <button class="btn btn-no" onclick="selectChoice('${stepId}', false)">NO</button>
                    ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                `;
            } else if (stepId === 'start') {
                stepTitle.textContent = '시작';
                conditionBox.innerHTML = `전쟁 말기 페이즈`;
                buttonGroup.innerHTML = `
                    <button class="btn btn-primary" onclick="startFlow()">시작하기</button>
                `;
            }

            updateProgress();
            updatePathHistory();
        }

        function selectChoice(conditionId, choice) {
            evaluatedConditions[conditionId] = choice;
            pathHistory.push({ step: conditionId, choice: choice, stepNum: stepCount });
            stepCount++;

            const nextStep = getNextStep(conditionId, choice);

            if (nextStep.startsWith('STRATEGY_')) {
                const strategy = nextStep.replace('STRATEGY_', '');
                showResult(strategy);
            } else {
                currentStep = nextStep;
                showStep(nextStep);
            }
        }

        function getNextStep(conditionId, choice) {
            switch (conditionId) {
                case 'A':
                    return choice ? 'B+C' : 'STRATEGY_Event Strategy';
                case 'B+C':
                    return choice ? 'D' : 'STRATEGY_Final Perimeter Strategy';
                case 'D':
                    return choice ? 'STRATEGY_Pass' : 'E';
                case 'E':
                    return choice ? 'STRATEGY_Final Defense Strategy' : 'STRATEGY_Event Strategy';
                default:
                    return 'STRATEGY_Event Strategy';
            }
        }

        function rollDice() {
            const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
            const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
            const diceResult = createMissingElement('diceResult', 'div', diceSection);
            if (errorContainer) errorContainer.classList.add('hidden');

            const diceValue = Math.floor(Math.random() * 10); // 0-9
            diceResult.textContent = diceValue;

            let strategy;
            if (diceValue >= 0 && diceValue <= 3) {
                strategy = 'Event Strategy';
            } else if (diceValue >= 4 && diceValue <= 7) {
                strategy = 'Final Perimeter Strategy';
            } else if (diceValue >= 8 && diceValue <= 9) {
                strategy = 'Final Defense Strategy';
            }

            pathHistory.push({
                step: 'DICE',
                choice: diceValue,
                stepNum: stepCount,
                isResult: true,
                result: strategy
            });

            setTimeout(() => showResult(strategy), 1000);
        }

        function showResult(strategyKey) {
            const strategy = strategies[strategyKey];
            if (!strategy) {
                console.error('Strategy not found:', strategyKey);
                return;
            }

            const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
            const stepSection = createMissingElement('stepSection', 'div', document.body);
            const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
            const resultSection = createMissingElement('resultSection', 'div', document.body, ['hidden']);
            const strategyName = createMissingElement('strategyName', 'h2', resultSection);
            const strategyDetails = createMissingElement('strategyDetails', 'div', resultSection);
            const buttonGroup = resultSection.querySelector('.button-group') || createMissingElement('button-group', 'div', resultSection, ['button-group']);

            if (errorContainer) errorContainer.classList.add('hidden');

            stepSection.classList.add('hidden');
            diceSection.classList.add('hidden');
            resultSection.classList.remove('hidden');
            strategyName.textContent = strategy.name;

            // Extract annotations from strategy name, details, and sub-priorities
            const annotationRegex = /\[\d+\]/g;
            const annotations = new Set();
            if (strategy.name.match(annotationRegex)) {
                strategy.name.match(annotationRegex).forEach(annotation => annotations.add(annotation));
            }
            strategy.details.forEach(detail => {
                if (detail.match(annotationRegex)) {
                    detail.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                }
                // Check sub-priorities for annotations
                if (subPriorities[detail]) {
                    subPriorities[detail].forEach(sub => {
                        if (sub.match(annotationRegex)) {
                            sub.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                        }
                    });
                }
            });

            strategyDetails.innerHTML = `
                <h4 style="margin-top: 0; color: #fff;">전략 세부사항:</h4>
                <ul class="strategy-list">
                    ${strategy.details.map(detail => `
                        <li>
                            ${detail}
                            ${subPriorities[detail] ? `
                                <ul class="sub-priority-list">
                                    ${subPriorities[detail].map(sub => `<li>${sub}</li>`).join('')}
                                </ul>
                            ` : ''}
                        </li>
                    `).join('')}
                </ul>
                ${annotations.size > 0 ? `
                    <h4 style="margin-top: 20px; color: #fff;">주석:</h4>
                    <ul class="strategy-list">
                        ${Array.from(annotations).sort().map(annotation => `
                            <li class="impl-note">${annotation}: ${notes[annotation]}</li>
                        `).join('')}
                    </ul>
                ` : ''}
            `;

            buttonGroup.innerHTML = `
                <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
            `;

            updateProgress();
            updatePathHistory();
        }

        function updateProgress() {
            const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
            const progressBar = createMissingElement('progress-bar', 'div', document.body, ['progress-bar']);
            const progressFill = createMissingElement('progressFill', 'div', progressBar, ['progress-fill']);
            if (errorContainer) errorContainer.classList.add('hidden');

            const totalSteps = 5; // 대략적인 최대 단계 수 (A, B+C, D, E)
            const progress = Math.min((stepCount / totalSteps) * 100, 100);
            progressFill.style.width = progress + '%';
        }

        function updatePathHistory() {
            const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
            const pathHistoryDiv = createMissingElement('pathHistory', 'div', document.body, ['hidden']);
            const pathStepsDiv = createMissingElement('pathSteps', 'div', pathHistoryDiv);
            if (errorContainer) errorContainer.classList.add('hidden');

            if (pathHistory.length === 0) {
                pathHistoryDiv.classList.add('hidden');
                return;
            }

            pathStepsDiv.innerHTML = '';

            pathHistory.forEach(step => {
                const stepDiv = document.createElement('div');
                stepDiv.className = `path-step ${step.choice && step.step !== 'DICE' ? 'yes' : step.step !== 'DICE' ? 'no' : ''}`;

                if (step.step === 'DICE') {
                    stepDiv.innerHTML = `
                        <div class="step-icon">${step.choice}</div>
                        <div>
                            <strong>Roll dice:</strong> ${step.choice} 
                            ${step.result ? `→ ${strategies[step.result].name}` : ''}
                        </div>
                    `;
                } else {
                    let conditionText = '';
                    if (conditions[step.step]) {
                        conditionText = conditions[step.step];
                    } else if (step.step === 'B+C') {
                        conditionText = '다음 조건을 모두 충족합니까? <ul><li>혼슈에 일본 지상 유닛이 연합군 유닛과 인접한 헥스를 모두 점령했습니까?</li><li>현재 턴이 12번 턴입니까?</li></ul>';
                    }

                    stepDiv.innerHTML = `
                        <div class="step-icon">${step.choice ? 'Y' : 'N'}</div>
                        <div>
                            <strong>${step.step}:</strong> 
                            ${conditionText} → ${step.choice ? 'YES' : 'NO'}
                        </div>
                    `;

                    pathStepsDiv.appendChild(stepDiv);
                }
            });

            pathHistoryDiv.classList.remove('hidden');
        }

        function resetFlow() {
            currentStep = 'start';
            stepCount = 0;
            pathHistory = [];
            evaluatedConditions = {};

            // Step 1: Create top-level elements
            const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
            const stepSection = createMissingElement('stepSection', 'div', document.body);
            const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
            const resultSection = createMissingElement('resultSection', 'div', document.body, ['hidden']);
            const pathHistoryDiv = createMissingElement('pathHistory', 'div', document.body, ['hidden']);
            const progressBar = createMissingElement('progress-bar', 'div', document.body, ['progress-bar']);

            // Step 2: Create child elements that depend on top-level elements
            const elements = {
                errorContainer,
                stepSection,
                diceSection,
                resultSection,
                pathHistoryDiv,
                progressBar,
                stepNumber: createMissingElement('stepNumber', 'div', stepSection),
                stepTitle: createMissingElement('stepTitle', 'h2', stepSection),
                conditionBox: createMissingElement('conditionBox', 'div', stepSection),
                buttonGroup: createMissingElement('buttonGroup', 'div', stepSection),
                progressFill: createMissingElement('progressFill', 'div', progressBar, ['progress-fill']),
                pathSteps: createMissingElement('pathSteps', 'div', pathHistoryDiv),
                strategyName: createMissingElement('strategyName', 'h2', resultSection),
                strategyDetails: createMissingElement('strategyDetails', 'div', resultSection),
                diceResult: createMissingElement('diceResult', 'div', diceSection)
            };

            const createdElements = Object.keys(elements).filter(key => {
                const element = document.getElementById(elements[key].id);
                return element && element !== document.getElementById(key); // Check if element was newly created
            });

            if (createdElements.length > 0) {
                console.warn('Created missing DOM elements in resetFlow:', createdElements);
                console.warn('To avoid dynamic creation, add the following to your HTML:', createdElements.map(id => `<div id="${id}"></div>`).join('\n'));
                if (elements.errorContainer) {
                    // elements.errorContainer.innerHTML = `경고: 다음 HTML 요소가 누락되어 동적으로 생성되었습니다: ${createdElements.join(', ')}. HTML에 추가하세요.`;
                    elements.errorContainer.classList.remove('hidden');
                }
            } else if (elements.errorContainer) {
                elements.errorContainer.classList.add('hidden');
            }

            if (elements.stepSection) elements.stepSection.classList.remove('hidden');
            if (elements.diceSection) elements.diceSection.classList.add('hidden');
            if (elements.resultSection) elements.resultSection.classList.add('hidden');
            if (elements.pathHistoryDiv) elements.pathHistoryDiv.classList.add('hidden');
            if (elements.stepNumber) elements.stepNumber.textContent = '1';
            if (elements.stepTitle) elements.stepTitle.textContent = '시작';
            if (elements.conditionBox) elements.conditionBox.innerHTML = '에라스무스의 전쟁 말기 전략을 결정합니다';
            if (elements.buttonGroup) elements.buttonGroup.innerHTML = '<button class="btn btn-primary" onclick="startFlow()">시작하기</button>';
            if (elements.progressFill) elements.progressFill.style.width = '0%';
        }

        function goBack() {
            if (pathHistory.length === 0) {
                resetFlow();
                return;
            }

            // Remove the last step from history
            const lastStep = pathHistory.pop();
            stepCount--;

            // Remove the last evaluated condition
            if (lastStep.step !== 'DICE') {
                delete evaluatedConditions[lastStep.step];
            }

            // Determine the previous step
            if (pathHistory.length === 0) {
                currentStep = 'start';
            } else {
                currentStep = pathHistory[pathHistory.length - 1].step;
                // If the last step was DICE, we need to go back to the step before DICE
                if (lastStep.step === 'DICE') {
                    currentStep = pathHistory.length > 0 ? pathHistory[pathHistory.length - 1].step : 'start';
                    pathHistory.pop(); // Remove the step before DICE as well
                    stepCount--;
                    if (pathHistory.length > 0) {
                        delete evaluatedConditions[pathHistory[pathHistory.length - 1].step];
                    }
                }
            }

            // Update UI
            const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
            const stepSection = createMissingElement('stepSection', 'div', document.body);
            const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
            const resultSection = createMissingElement('resultSection', 'div', document.body, ['hidden']);
            if (errorContainer) errorContainer.classList.add('hidden');

            stepSection.classList.remove('hidden');
            diceSection.classList.add('hidden');
            resultSection.classList.add('hidden');
            showStep(currentStep);
        }

        // 페이지 로드 시 초기화
        window.onload = function () {
            if (document.readyState === 'complete') {
                resetFlow();
            } else {
                window.addEventListener('DOMContentLoaded', resetFlow);
            }
        };
    </script>
    </body>
    </html>
  </template>

  <!-- 4. 카드 선택 -->
  <template id="tmpl-card">
    <!DOCTYPE html>
    <html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Japanese Erasmus Bot - 카드 선택</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                background: #2e2e2e;
                min-height: 100vh;
                margin: 0;
                padding: 20px;
                box-sizing: border-box;
                color: #d8d8d8;
            }
        
            .impl-note {
                font-style: italic;
                font-size: 14px;
                color: #ffffff;
                line-height: 1.6;
                margin: 4px 0;
            }
        
            .container {
                max-width: 800px;
                margin: 0 auto;
                background: #3c3c3c;
                border-radius: 8px;
                padding: 20px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            }
        
            .header {
                text-align: center;
                margin-bottom: 20px;
                padding: 15px;
                background: #4a4a4a;
                border-radius: 8px;
                color: #ffffff;
                border: 1px solid #5c5c5c;
            }
        
            .header h1 {
                margin: 0;
                font-size: 2rem;
                font-weight: 700;
            }
        
            .header p {
                margin: 8px 0 0 0;
                font-size: 1rem;
                font-weight: 400;
            }
        
            .progress-bar {
                background: #4a4a4a;
                border-radius: 5px;
                height: 6px;
                margin-bottom: 20px;
                overflow: hidden;
                border: 1px solid #5c5c5c;
            }
        
            .progress-fill {
                background: #4682b4;
                height: 100%;
                border-radius: 5px;
                transition: width 0.3s ease;
                width: 0%;
            }
        
            .step-section {
                background: #3c3c3c;
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 15px;
                border: 1px solid #5c5c5c;
            }
        
            .step-header {
                display: flex;
                align-items: center;
                margin-bottom: 15px;
            }
        
            .step-number {
                background: #4682b4;
                color: #ffffff;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                font-size: 1rem;
                margin-right: 15px;
            }
        
            .step-title {
                font-size: 1.3rem;
                font-weight: 600;
                color: #d8d8d8;
                margin: 0;
            }
        
            .condition-box {
                background: #4a4a4a;
                border-left: 4px solid #4682b4;
                border-radius: 5px;
                padding: 15px;
                margin: 15px 0;
                font-size: 1rem;
                line-height: 1.5;
                color: #c8c8c8;
            }
        
            .condition-box strong {
                color: #4682b4;
                font-size: 1.1rem;
            }
        
            .button-group {
                display: flex;
                gap: 15px;
                justify-content: center;
                margin-top: 20px;
            }
        
            .btn {
                padding: 10px 30px;
                border: none;
                border-radius: 5px;
                font-size: 1rem;
                font-weight: 500;
                cursor: pointer;
                transition: background 0.2s ease, transform 0.1s ease;
                text-transform: uppercase;
                min-width: 100px;
                font-family: 'Georgia', 'Times New Roman', Times, serif;
            }
        
            .btn-yes {
                background: #2e8b57;
                color: #ffffff;
            }
        
            .btn-yes:hover {
                background: #257a4b;
                transform: translateY(-2px);
            }
        
            .btn-no {
                background: #696969;
                color: #ffffff;
            }
        
            .btn-no:hover {
                background: #585858;
                transform: translateY(-2px);
            }
        
            .btn-primary {
                background: #4682b4;
                color: #ffffff;
            }
        
            .btn-primary:hover {
                background: #3a6b9a;
                transform: translateY(-2px);
            }
        
            .btn-secondary {
                background: #5c5c5c;
                color: #ffffff;
            }
        
            .btn-secondary:hover {
                background: #4b4b4b;
                transform: translateY(-2px);
            }
        
            .btn-back {
                background: #5c5c5c;
                color: #ffffff;
            }
        
            .btn-back:hover {
                background: #4b4b4b;
                transform: translateY(-2px);
            }
        
            .path-history {
                background: #4a4a4a;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 15px;
                border-left: 3px solid #2e8b57;
            }
        
            .path-step {
                display: flex;
                align-items: center;
                margin: 8px 0;
                padding: 8px;
                background: #3c3c3c;
                border-radius: 5px;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            }
        
            .path-step .step-icon {
                width: 25px;
                height: 25px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                margin-right: 10px;
                font-size: 0.8rem;
            }
        
            .path-step.yes .step-icon {
                background: #2e8b57;
                color: #ffffff;
            }
        
            .path-step.no .step-icon {
                background: #696969;
                color: #ffffff;
            }
        
            .dice-section {
                background: #4a4a4a;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                margin: 15px 0;
                border: 1px solid #5c5c5c;
            }
        
            .dice-result {
                font-size: 3rem;
                font-weight: bold;
                color: #d8d8d8;
                margin: 15px 0;
            }
        
            .result-section {
                background: #2e8b57;
                color: #ffffff;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                margin-top: 15px;
                border: 1px solid #3c3c3c;
            }
        
            .result-section h2 {
                margin: 0 0 15px 0;
                font-size: 2rem;
                display: none;
            }
        
            .result-section p {
                margin: 10px 0;
                font-size: 32px;
                white-space: pre-line;
                font-weight: bold;
                font-style: italic;
            }
        
            .strategy-details {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 5px;
                padding: 15px;
                margin-top: 15px;
            }
        
            .strategy-list {
                text-align: left;
                margin: 15px 0;
                list-style: none;
                padding: 0;
            }
        
            .strategy-list li {
                margin: 8px 0;
                padding: 8px 10px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 5px;
                border-left: 3px solid rgba(255, 255, 255, 0.3);
            }
        
            .sub-priority-list {
                list-style: none;
                padding-left: 20px;
                margin-top: 5px;
            }
        
            .sub-priority-list li {
                margin: 5px 0;
                padding: 5px 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 5px;
                border-left: 2px solid rgba(255, 255, 255, 0.4);
                font-size: 0.9rem;
            }
        
            .hidden {
                display: none;
            }
        
            @media (max-width: 768px) {
                .container {
                    padding: 15px;
                    margin: 10px;
                }
                
                .header h1 {
                    font-size: 1.5rem;
                }
                
                .button-group {
                    flex-direction: column;
                    align-items: center;
                }
                
                .btn {
                    width: 100%;
                    max-width: 180px;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>카드 선택</h1>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div id="pathHistory" class="path-history hidden">
                <h4 style="margin-top: 0; color: #ffffff;">진행 경로</h4>
                <div id="pathSteps"></div>
            </div>

            <div id="stepSection" class="step-section">
                <div class="step-header">
                    <div class="step-number" id="stepNumber">1</div>
                    <h2 class="step-title" id="stepTitle">시작</h2>
                </div>
                
                <div class="condition-box" id="conditionBox">
                    첫 번째 조건을 확인해주세요.
                </div>
                
                <div class="button-group" id="buttonGroup">
                    <button class="btn btn-primary" onclick="startFlow()">시작하기</button>
                </div>
            </div>

            <div id="diceSection" class="dice-section hidden">
                <h3 style="margin: 0 0 20px 0; color: #2d3436;">Roll D10</h3>
                <div class="dice-result" id="diceResult">?</div>
                <div class="button-group">
                    <button class="btn btn-primary" onclick="rollDice()">Roll dice</button>
                </div>
            </div>

            <div id="resultSection" class="result-section hidden">
                <h2 id="strategyTitle">Strategy Result</h2>
                <p id="strategyName"></p>
                <div class="strategy-details" id="strategyDetails"></div>
                <div class="button-group" style="margin-top: 30px;">
                    <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                </div>
            </div>
        </div>

        <script>
            const notes = {
                '[1]': '카드를 왼쪽에서 오른쪽 순서로 다음과 같이 배열합니다: 군사 이벤트, 대응 이벤트, 자원 이벤트, 정치 이벤트. 마지막 카드 두 장은 다음 순서에서 가장 좋은 이벤트를 선택합니다: 도쿄 로즈, 도조, 유럽 전쟁, 일본군 내부 항쟁 종료, 미군 내부 항쟁 시작, 보충, 날씨 대응. 그 외의 카드는 무작위로 선택하세요.',
                '[2]': '일본 에라스무스가 아직 오프닝 페이즈에 있고, 전략이 중부 태평양Central Pacific 또는 방어 경계Defensive Perimeter거나, 목표를 달성할 수 있는 유일한 남은 군사 이벤트 카드 가 아니라면 Operation MI 카드는 고려하지 않습니다.',
                '[3]': '공세 단계(Offensives Phase)의 시작에서, 정렬된 순서에서 첫 번째 카드를 사용하세요.',
                '[4]': '제한없는 군사 이벤트 카드란? 활성화 제한(지상, 공군, 해군)도 없고 전투 헥스 제한도 없는 군사 이벤트 카드입니다. HQ 제한은 무시하세요.',
                '[5]': '제한적 군사 이벤트 카드란? 활성화 제한(지상, 공군, 해군) 또는 전투 헥스 제한이 있는 군사 이벤트 카드입니다. HQ 제한은 무시하세요.'
            };

            const strategies = {
                'First Strike EC Strategy': { 
                    name: '첫 타격 EC 전략', 
                    details: [
                        '다음 우선 순위에 따라 사용 가능한 카드 사용',
                        '1. Operation I-Go',
                        '2. 2nd Operational Phase'
                    ] 
                },
                'Unrestricted Event EC Strategy': { 
                    name: '제한 없는 이벤트 EC 전략[4]', 
                    details: [
                        '기준: 병참 값이 가장 높은 카드를 선택합니다. 만약 공세 보너스가 있다면 다음 우선순위에 따라 선택합니다',
                        '1. 공수부대 보너스',
                        '2. 비-공수부대 보너스',
                        '3. 보너스 없음'
                    ] 
                },
                'Restricted Event OC Strategy': { 
                    name: '제한된 이벤트 OC 전략[2][5]', 
                    details: [
                        '기준: 가장 높은 OC 값을 가진 카드를 선택합니다. 단, 그것이 군사 이벤트 카드고, 군사 이벤트가 아닌 카드가 있다면(값과 관계없이), 군사 이벤트 카드는 제외하고 OC 카드를 무작위로 선택합니다.'
                    ] 
                },
                'Restricted Event EC Strategy': { 
                    name: '제한된 이벤트 EC 전략[2][5]', 
                    details: [
                        '기준: 병참 값이 가장 높은 카드를 선택합니다. 동률일 경우 보너스가 없는 카드보다 공세 보너스 카드들을 우선 선택합니다. 그 외에는 무작위로 선택합니다.'
                    ] 
                },
                'Non-Military Event OC Strategy': { 
                    name: '비군사 이벤트 OC 전략[3]', 
                    details: [
                        '기준: 가장 높은 OC 값을 가진 카드를 선택합니다'
                    ] 
                },
                'Play Card as Future Offensive': { 
                    name: '미래 공세 카드 플레이', 
                    details: [
                        '카드를 미래 공세로 사용합니다'
                    ] 
                },
                'Event Strategy': { 
                    name: '이벤트 전략', 
                    details: [
                        '다음 우선순위에 따라 사용 가능한 이벤트 카드를 플레이하세요:',
                        '1. 유럽 전쟁(War in Europe)',
                        '2. 병력 보충(Replacements)',
                        '3. 일본 ISR 종료',
                        '4. 미군 ISR 생성',
                        '5. 기타 (무작위)'
                    ] 
                },
                // 'Restricted Event As OC Strategy': { 
                //     name: '제한된 이벤트 OC 전략', 
                //     details: ['OC 가치 기준으로 제한된 이벤트 처리'
                //     ] 
                // }
            };

            const conditions = {
                'A': '이번 공세 페이즈 동안, 카드를 하나라도 사용했습니까?',
                'B': '손패에 카드가 2장 이상 있습니까?',
                'C': '이 카드가 이번 게임에서 처음 사용하는 카드입니까?',
                'D': '손패에 Operation I-GO 또는 2차 작전 단계 군사 이벤트 카드가 있습니까?',
                'E': '사용 가능한 제한없는Unrestricted 군사 이벤트가 있습니까?',
                'F': '사용 가능한 제한된Restricted 군사 이벤트가 있습니까?',
                'G': '사용 가능한 모든 군사 이벤트 카드 제한 사항 때문에 선택한 대상을 공격하거나 점령할 수 없습니까?',
                'H': '이번 턴에 보관할 FO 카드를 선택했습니까?',
                'I': 'DEI 목표를 완료했습니까? (전쟁 초기인 경우에만)',
                'J': '남은 카드가 1장 있습니까?',
                'K': '남아있는 사용 가능한 이벤트 카드가 모두 대응 카드입니까?'
            };

            let currentStep = 'start';
            let pathHistory = [];
            let stepCount = 0;
            let evaluatedConditions = {};

            function createMissingElement(id, tag, parent, classes = []) {
                let element = document.getElementById(id);
                if (!element) {
                    element = document.createElement(tag);
                    element.id = id;
                    classes.forEach(cls => element.classList.add(cls));
                    if (parent && parent.appendChild) {
                        parent.appendChild(element);
                    } else {
                        document.body.appendChild(element);
                    }
                }
                return element;
            }

            function startFlow() {
                currentStep = 'A';
                stepCount = 1;
                pathHistory = [];
                evaluatedConditions = {};
                showStep('A');
            }

            function showStep(stepId) {
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const stepSection = createMissingElement('stepSection', 'div', document.body);
                const stepNumber = createMissingElement('stepNumber', 'div', stepSection);
                const stepTitle = createMissingElement('stepTitle', 'h2', stepSection);
                const conditionBox = createMissingElement('conditionBox', 'div', stepSection);
                const buttonGroup = createMissingElement('buttonGroup', 'div', stepSection);

                if (errorContainer) errorContainer.classList.add('hidden');

                stepNumber.textContent = stepCount;

                if (stepId === 'Sort Cards') {
                    stepTitle.textContent = '카드 정렬';
                    conditionBox.innerHTML = ` 카드를 정렬합니다.[1]<br>카드를 왼쪽에서 오른쪽 순서로 다음과 같이 배열합니다: 군사 이벤트, 대응 이벤트, 자원 이벤트, 정치 이벤트. 마지막 카드 두 장은 다음 순서에서 가장 좋은 이벤트를 선택합니다: 도쿄 로즈, 도조, 유럽 전쟁, 일본군 내부 항쟁 종료, 미군 내부 항쟁 시작, 보충, 날씨 대응. 그 외의 카드는 무작위로 선택하세요.`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-continue" onclick="selectChoice('Sort Cards', true)">계속</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                } else if (conditions[stepId]) {
                    stepTitle.textContent = `${stepId} 확인`;
                    conditionBox.innerHTML = ` ${conditions[stepId]}`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-yes" onclick="selectChoice('${stepId}', true)">YES</button>
                        <button class="btn btn-no" onclick="selectChoice('${stepId}', false)">NO</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                } else if (stepId === 'start') {
                    stepTitle.textContent = '시작';
                    conditionBox.innerHTML = `카드 선택`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-primary" onclick="startFlow()">시작하기</button>
                    `;
                }

                updateProgress();
                updatePathHistory();
            }

            function selectChoice(conditionId, choice) {
                evaluatedConditions[conditionId] = choice;
                pathHistory.push({ step: conditionId, choice: choice, stepNum: stepCount });
                stepCount++;

                const nextStep = getNextStep(conditionId, choice);

                if (nextStep.startsWith('STRATEGY_')) {
                    const strategy = nextStep.replace('STRATEGY_', '');
                    showResult(strategy);
                } else if (nextStep) {
                    currentStep = nextStep;
                    showStep(nextStep);
                } else {
                    console.warn('No next step defined for', conditionId, choice);
                    showResult('Event Strategy'); // 기본 전략으로 전환
                }
            }

            function getNextStep(conditionId, choice) {
                switch (conditionId) {
                    case 'A':
                        return choice ? 'B' : 'Sort Cards'; // 수정: A가 true면 B, false면 Sort Cards
                    case 'Sort Cards':
                        return 'B';
                    case 'B':
                        return choice ? 'C' : 'H';
                    case 'C':
                        return choice ? 'D' : 'E';
                    case 'D':
                        return choice ? 'STRATEGY_First Strike EC Strategy' : 'E';
                    case 'E':
                        return choice ? 'STRATEGY_Unrestricted Event EC Strategy' : 'F';
                    case 'F':
                        return choice ? 'G' : 'STRATEGY_Non-Military Event OC Strategy';
                    case 'G':
                        return choice ? 'STRATEGY_Restricted Event OC Strategy' : 'STRATEGY_Restricted Event EC Strategy';
                    case 'H':
                        return choice ? 'STRATEGY_Non-Military Event OC Strategy' : 'I';
                    case 'I':
                        return choice ? 'J' : 'STRATEGY_Non-Military Event OC Strategy';
                    case 'J':
                        return choice ? 'STRATEGY_Play Card as Future Offensive' : 'K';
                    case 'K':
                        return choice ? 'STRATEGY_Non-Military Event OC Strategy' : 'STRATEGY_Event Strategy';
                    default:
                        return 'STRATEGY_Event Strategy';
                }
            }

            function rollDice() {
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
                const diceResult = createMissingElement('diceResult', 'div', diceSection);
                if (errorContainer) errorContainer.classList.add('hidden');

                const diceValue = Math.floor(Math.random() * 10);
                diceResult.textContent = diceValue;

                let strategy;
                if (diceValue >= 0 && diceValue <= 3) {
                    strategy = 'Event Strategy';
                } else if (diceValue >= 4 && diceValue <= 7) {
                    strategy = 'Non-Military Event OC Strategy';
                } else if (diceValue >= 8 && diceValue <= 9) {
                    strategy = 'First Strike EC Strategy';
                }

                pathHistory.push({
                    step: 'DICE',
                    choice: diceValue,
                    stepNum: stepCount,
                    isResult: true,
                    result: strategy
                });

                setTimeout(() => showResult(strategy), 1000);
            }

            function showResult(strategyKey) {
                const strategy = strategies[strategyKey];
                if (!strategy) {
                    console.error('Strategy not found:', strategyKey);
                    return;
                }

                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const stepSection = createMissingElement('stepSection', 'div', document.body);
                const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
                const resultSection = createMissingElement('resultSection', 'div', document.body, ['hidden']);
                const strategyName = createMissingElement('strategyName', 'h2', resultSection);
                const strategyDetails = createMissingElement('strategyDetails', 'div', resultSection);
                const buttonGroup = resultSection.querySelector('.button-group') || createMissingElement('button-group', 'div', resultSection, ['button-group']);

                if (errorContainer) errorContainer.classList.add('hidden');

                stepSection.classList.add('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.remove('hidden');
                strategyName.textContent = strategy.name;

                const annotationRegex = /\[\d+\]/g;
                const annotations = new Set();
                if (strategy.name.match(annotationRegex)) {
                    strategy.name.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                }
                strategy.details.forEach(detail => {
                    if (detail.match(annotationRegex)) {
                        detail.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                    }
                });

                strategyDetails.innerHTML = `
                    <h4 style="margin-top: 0; color: #fff;">전략 세부사항:</h4>
                    <ul class="strategy-list">
                        ${strategy.details.map(detail => `<li>${detail}</li>`).join('')}
                    </ul>
                    ${annotations.size > 0 ? `
                        <h4 style="margin-top: 20px; color: #fff;">주석:</h4>
                        <ul class="strategy-list">
                            ${Array.from(annotations).sort().map(annotation => `
                                <li class="impl-note">${annotation}: ${notes[annotation]}</li>
                            `).join('')}
                        </ul>
                    ` : ''}
                `;

                buttonGroup.innerHTML = `
                    <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                    ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                `;

                updateProgress();
                updatePathHistory();
            }

            function updateProgress() {
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const progressBar = createMissingElement('progress-bar', 'div', document.body, ['progress-bar']);
                const progressFill = createMissingElement('progressFill', 'div', progressBar, ['progress-fill']);
                if (errorContainer) errorContainer.classList.add('hidden');

                const totalSteps = 11; // A부터 K까지 최대 단계 수
                const progress = Math.min((stepCount / totalSteps) * 100, 100);
                progressFill.style.width = progress + '%';
            }

            function updatePathHistory() {
                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const pathHistoryDiv = createMissingElement('pathHistory', 'div', document.body, ['hidden']);
                const pathStepsDiv = createMissingElement('pathSteps', 'div', pathHistoryDiv);
                if (errorContainer) errorContainer.classList.add('hidden');

                if (pathHistory.length === 0) {
                    pathHistoryDiv.classList.add('hidden');
                    return;
                }

                pathStepsDiv.innerHTML = '';

                pathHistory.forEach(step => {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = `path-step ${step.choice && step.step !== 'DICE' ? 'yes' : step.step !== 'DICE' ? 'no' : ''}`;

                    if (step.step === 'DICE') {
                        stepDiv.innerHTML = `
                            <div class="step-icon">${step.choice}</div>
                            <div>
                                <strong>Roll dice:</strong> ${step.choice} 
                                ${step.result ? `→ ${strategies[step.result].name}` : ''}
                            </div>
                        `;
                    } else if (step.step === 'Sort Cards') {
                        stepDiv.innerHTML = `
                            <div class="step-icon">S</div>
                            <div>
                                <strong>${step.step}:</strong> 
                                카드 정렬 → 계속
                            </div>
                        `;
                    } else {
                        let conditionText = conditions[step.step] || '';
                        stepDiv.innerHTML = `
                            <div class="step-icon">${step.choice ? 'Y' : 'N'}</div>
                            <div>
                                <strong>${step.step}:</strong> 
                                ${conditionText} → ${step.choice ? 'YES' : 'NO'}
                            </div>
                        `;
                    }

                    pathStepsDiv.appendChild(stepDiv);
                });

                pathHistoryDiv.classList.remove('hidden');
            }

            function resetFlow() {
                currentStep = 'start';
                stepCount = 0;
                pathHistory = [];
                evaluatedConditions = {};

                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const stepSection = createMissingElement('stepSection', 'div', document.body);
                const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
                const resultSection = createMissingElement('resultSection', 'div', document.body, ['hidden']);
                const pathHistoryDiv = createMissingElement('pathHistory', 'div', document.body, ['hidden']);
                const progressBar = createMissingElement('progress-bar', 'div', document.body, ['progress-bar']);

                const elements = {
                    errorContainer,
                    stepSection,
                    diceSection,
                    resultSection,
                    pathHistoryDiv,
                    progressBar,
                    stepNumber: createMissingElement('stepNumber', 'div', stepSection),
                    stepTitle: createMissingElement('stepTitle', 'h2', stepSection),
                    conditionBox: createMissingElement('conditionBox', 'div', stepSection),
                    buttonGroup: createMissingElement('buttonGroup', 'div', stepSection),
                    progressFill: createMissingElement('progressFill', 'div', progressBar, ['progress-fill']),
                    pathSteps: createMissingElement('pathSteps', 'div', pathHistoryDiv),
                    strategyName: createMissingElement('strategyName', 'h2', resultSection),
                    strategyDetails: createMissingElement('strategyDetails', 'div', resultSection),
                    diceResult: createMissingElement('diceResult', 'div', diceSection)
                };

                const createdElements = Object.keys(elements).filter(key => {
                    const element = document.getElementById(elements[key].id);
                    return element && element !== document.getElementById(key);
                });

                if (createdElements.length > 0) {
                    console.warn('Created missing DOM elements in resetFlow:', createdElements);
                    if (elements.errorContainer) {
                        elements.errorContainer.classList.remove('hidden');
                    }
                } else if (elements.errorContainer) {
                    elements.errorContainer.classList.add('hidden');
                }

                if (elements.stepSection) elements.stepSection.classList.remove('hidden');
                if (elements.diceSection) elements.diceSection.classList.add('hidden');
                if (elements.resultSection) elements.resultSection.classList.add('hidden');
                if (elements.pathHistoryDiv) elements.pathHistoryDiv.classList.add('hidden');
                if (elements.stepNumber) elements.stepNumber.textContent = '1';
                if (elements.stepTitle) elements.stepTitle.textContent = '시작';
                if (elements.conditionBox) elements.conditionBox.innerHTML = '에라스무스가 사용할 카드를 결정합니다';
                if (elements.buttonGroup) elements.buttonGroup.innerHTML = '<button class="btn btn-primary" onclick="startFlow()">시작하기</button>';
                if (elements.progressFill) elements.progressFill.style.width = '0%';
            }

            function goBack() {
                if (pathHistory.length === 0) {
                    resetFlow();
                    return;
                }

                const lastStep = pathHistory.pop();
                stepCount--;

                if (lastStep.step !== 'DICE') {
                    delete evaluatedConditions[lastStep.step];
                }

                if (pathHistory.length === 0) {
                    currentStep = 'start';
                } else {
                    currentStep = pathHistory[pathHistory.length - 1].step;
                    if (lastStep.step === 'DICE') {
                        currentStep = pathHistory.length > 0 ? pathHistory[pathHistory.length - 1].step : 'start';
                        pathHistory.pop();
                        stepCount--;
                        if (pathHistory.length > 0) {
                            delete evaluatedConditions[pathHistory[pathHistory.length - 1].step];
                        }
                    }
                }

                const errorContainer = createMissingElement('errorContainer', 'div', document.body, ['hidden']);
                const stepSection = createMissingElement('stepSection', 'div', document.body);
                const diceSection = createMissingElement('diceSection', 'div', document.body, ['hidden']);
                const resultSection = createMissingElement('resultSection', 'div', document.body, ['hidden']);
                if (errorContainer) errorContainer.classList.add('hidden');

                stepSection.classList.remove('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.add('hidden');
                showStep(currentStep);
            }

            window.onload = function () {
                if (document.readyState === 'complete') {
                    resetFlow();
                } else {
                    window.addEventListener('DOMContentLoaded', resetFlow);
                }
            };
        </script>
  </template>

  <!-- 5. 태스크 포스 구성 -->
  <template id="tmpl-task">
    <!DOCTYPE html>
    <html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Japanese Erasmus Bot - 태스크 포스 구성</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                background: #2e2e2e;
                min-height: 100vh;
                margin: 0;
                padding: 20px;
                box-sizing: border-box;
                color: #d8d8d8;
            }
        
            .impl-note {
                font-style: italic;
                font-size: 14px;
                color: #ffffff;
                line-height: 1.6;
                margin: 4px 0;
            }
        
            .container {
                max-width: 800px;
                margin: 0 auto;
                background: #3c3c3c;
                border-radius: 8px;
                padding: 20px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            }
        
            .header {
                text-align: center;
                margin-bottom: 20px;
                padding: 15px;
                background: #4a4a4a;
                border-radius: 8px;
                color: #ffffff;
                border: 1px solid #5c5c5c;
            }
        
            .header h1 {
                margin: 0;
                font-size: 2rem;
                font-weight: 700;
            }
        
            .header p {
                margin: 8px 0 0 0;
                font-size: 1rem;
                font-weight: 400;
            }
        
            .progress-bar {
                background: #4a4a4a;
                border-radius: 5px;
                height: 6px;
                margin-bottom: 20px;
                overflow: hidden;
                border: 1px solid #5c5c5c;
            }
        
            .progress-fill {
                background: #4682b4;
                height: 100%;
                border-radius: 5px;
                transition: width 0.3s ease;
                width: 0%;
            }
        
            .step-section {
                background: #3c3c3c;
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 15px;
                border: 1px solid #5c5c5c;
            }
        
            .step-header {
                display: flex;
                align-items: center;
                margin-bottom: 15px;
            }
        
            .step-number {
                background: #4682b4;
                color: #ffffff;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                font-size: 1rem;
                margin-right: 15px;
            }
        
            .step-title {
                font-size: 1.3rem;
                font-weight: 600;
                color: #d8d8d8;
                margin: 0;
            }
        
            .condition-box {
                background: #4a4a4a;
                border-left: 4px solid #4682b4;
                border-radius: 5px;
                padding: 15px;
                margin: 15px 0;
                font-size: 1rem;
                line-height: 1.5;
                color: #c8c8c8;
            }
        
            .condition-box strong {
                color: #4682b4;
                font-size: 1.1rem;
            }
        
            .button-group {
                display: flex;
                gap: 15px;
                justify-content: center;
                margin-top: 20px;
            }
        
            .btn {
                padding: 10px 30px;
                border: none;
                border-radius: 5px;
                font-size: 1rem;
                font-weight: 500;
                cursor: pointer;
                transition: background 0.2s ease, transform 0.1s ease;
                text-transform: uppercase;
                min-width: 100px;
                font-family: 'Georgia', 'Times New Roman', Times, serif;
            }
        
            .btn-yes {
                background: #2e8b57;
                color: #ffffff;
            }
        
            .btn-yes:hover {
                background: #257a4b;
                transform: translateY(-2px);
            }
        
            .btn-no {
                background: #696969;
                color: #ffffff;
            }
        
            .btn-no:hover {
                background: #585858;
                transform: translateY(-2px);
            }
        
            .btn-primary {
                background: #4682b4;
                color: #ffffff;
            }
        
            .btn-primary:hover {
                background: #3a6b9a;
                transform: translateY(-2px);
            }
        
            .btn-secondary {
                background: #5c5c5c;
                color: #ffffff;
            }
        
            .btn-secondary:hover {
                background: #4b4b4b;
                transform: translateY(-2px);
            }
        
            .btn-back {
                background: #5c5c5c;
                color: #ffffff;
            }
        
            .btn-back:hover {
                background: #4b4b4b;
                transform: translateY(-2px);
            }
        
            .path-history {
                background: #4a4a4a;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 15px;
                border-left: 3px solid #2e8b57;
            }
        
            .path-step {
                display: flex;
                align-items: center;
                margin: 8px 0;
                padding: 8px;
                background: #3c3c3c;
                border-radius: 5px;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            }
        
            .path-step .step-icon {
                width: 25px;
                height: 25px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                margin-right: 10px;
                font-size: 0.8rem;
            }
        
            .path-step.yes .step-icon {
                background: #2e8b57;
                color: #ffffff;
            }
        
            .path-step.no .step-icon {
                background: #696969;
                color: #ffffff;
            }
        
            .dice-section {
                background: #4a4a4a;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                margin: 15px 0;
                border: 1px solid #5c5c5c;
            }
        
            .dice-result {
                font-size: 3rem;
                font-weight: bold;
                color: #d8d8d8;
                margin: 15px 0;
            }
        
            .result-section {
                background: #2e8b57;
                color: #ffffff;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                margin-top: 15px;
                border: 1px solid #3c3c3c;
            }
        
            .result-section h2 {
                margin: 0 0 15px 0;
                font-size: 2rem;
                display: none;
            }
        
            .result-section p {
                margin: 10px 0;
                font-size: 32px;
                white-space: pre-line;
                font-weight: bold;
                font-style: italic;
            }
        
            .strategy-details {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 5px;
                padding: 15px;
                margin-top: 15px;
            }
        
            .strategy-list {
                text-align: left;
                margin: 15px 0;
                list-style: none;
                padding: 0;
            }
        
            .strategy-list li {
                margin: 8px 0;
                padding: 8px 10px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 5px;
                border-left: 3px solid rgba(255, 255, 255, 0.3);
            }
        
            .sub-priority-list {
                list-style: none;
                padding-left: 20px;
                margin-top: 5px;
            }
        
            .sub-priority-list li {
                margin: 5px 0;
                padding: 5px 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 5px;
                border-left: 2px solid rgba(255, 255, 255, 0.4);
                font-size: 0.9rem;
            }
        
            .hidden {
                display: none;
            }
        
            @media (max-width: 768px) {
                .container {
                    padding: 15px;
                    margin: 10px;
                }
                
                .header h1 {
                    font-size: 1.5rem;
                }
                
                .button-group {
                    flex-direction: column;
                    align-items: center;
                }
                
                .btn {
                    width: 100%;
                    max-width: 180px;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>태스크 포스 구성</h1>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div id="pathHistory" class="path-history hidden">
                <h4 style="margin-top: 0; color: #ffffff;">진행 경로</h4>
                <div id="pathSteps"></div>
            </div>

            <div id="stepSection" class="step-section">
                <div class="step-header">
                    <div class="step-number" id="stepNumber">1</div>
                    <h2 class="step-title" id="stepTitle">시작</h2>
                </div>
                
                <div class="condition-box" id="conditionBox">
                    첫 번째 조건을 확인해주세요.
                </div>
                
                <div class="button-group" id="buttonGroup">
                    <button class="btn btn-primary" onclick="startFlow()">시작하기</button>
                </div>
            </div>

            <div id="diceSection" class="dice-section hidden">
                <h3 style="margin: 0 0 20px 0; color: #2d3436;">Roll D10</h3>
                <div class="dice-result" id="diceResult">?</div>
                <div class="button-group">
                    <button class="btn btn-primary" onclick="rollDice()">Roll dice</button>
                </div>
            </div>

            <div id="resultSection" class="result-section hidden">
                <h2 id="strategyTitle">최종 병력 구성</h2>
                <p id="strategyName"></p>
                <div class="strategy-details" id="strategyDetails"></div>
                <div class="button-group" style="margin-top: 30px;">
                    <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                </div>
            </div>
        </div>

        <script>
            // Implementation notes
            const notes = {
                '[1]': '매트릭스에 의해 결정된 각 목표마다 이 표에 따라 병력을 편성합니다. 만약 OC 공세 상황이고 이미 전투 헥스 하나가 지정됐다면, **점령되지 않은 목표만 고려**한 후, 다음으로 우선순위가 높은 목표에 지상 → 공군 → 해군 순서로 더 가까워지도록 하는 두 장 카드 조합을 선택하세요.',
                '[2]': '지상 유닛 하나를 활성화하여 이 헥스로 진격시킵니다. 만약 적 해군 유닛이 목표를 점령 중이라면 전투 헥스 생성 방지를 위해 지상 유닛을 목표 밖으로 이동시킵니다. 필요하다면 이 지상 유닛을 육상 진격(Overland Advance)을 통해 추가 목표를 점령하는 데 다시 사용할 수 있습니다.',
                '[3]': '선택된 전략의 병력Force 편성 유형에 따라, 목표 범위 내에서 해당 헥스의 피해 수준 기준Damage Level criteria을 달성할 수 있는 최소한의 유닛을 활성화합니다. 달성 불가한 경우 가능한 한 많은 유닛을 활성화합니다. 만약 대응이 가능하다면, 목표에 도달할 수 있는 적의 대응 병력을 고려하여 필요한 전력을 계산합니다.',
                '[4]': '일본 제도 외의 HQ 헥스에 주둔 중인 지상 유닛의 경우, HQ를 방어하기 위해 반드시 하나는 해당 헥스에 남겨둬야 하며 활성화하지않습니다.',
                '[5]': '지상 유닛 하나를 활성화하여 AA(상륙 강습)를 통해 목표를 침공하세요. 가능하다면 유기적 수송(organic transportation)을 이용하고, 그렇지 않으면 ASP를 사용하여 해당 지상 유닛과 동반하는 해군 유닛을 활성화합니다. ASP가 없으면 이 목표는 건너뜁니다.',
                '[6]': '"장악(Capture)"이란 전투 결과로 수비자가 입힌 손실보다 더 많은 스텝 손실을 가해 전투에서 승리하는 것을 의미합니다. 즉, 에라스무스가 해당 전투 결과 이상을 굴리고, 수비자는 동일 결과 이하를 굴렸을 때를 말합니다.',
                '[7]': '만약 에라스무스가 적 유닛의 후퇴를 수행해야 하는 경우, 가장 약한 수비 유닛부터 가장 강한 유닛 순으로 후퇴 규칙을 따라 이동합니다.',
                '[8]': '대응이 가능한 경우, 가장 우선순위가 높은 목표에 대해 해군 → 공군 순으로 번갈아 추가하세요. 그렇지 않은 경우에는 공군을 활성화해 적 공군을 공격하고, 그다음 해군, 마지막으로 지상군을 활성화하세요.',
                '[9]': '육상 진격 / AA(상륙 강습) 규칙<br>지상 공격을 하려면, 지상 전투 결과가 1x일 때 헥스를 점령[6][7]할 수 있을 만큼 공격력이 충분히 커야 하며, 최소 지상 유닛 1스텝이 적의 2x 결과에서 살아남아야 합니다. <br> 이때 발생할 수 있는 AA 대응과 전투 헥스에 도달 할 수 있는 충분한 MP를 가진 인접 헥스의 공격도 포함합니다.',
                '[10]': '피해 수준<br>공격력에 피해 결과를 곱한 값으로, 목표 헥스에 있는 적 부대를 파괴합니다. 1x 결과는 전투 테이블의 결과가 1x인 경우 적과 동등 이상의 전투력이 있어야 적 유닛을 제거한다는 의미입니다. 지상 전투는 (육상 진격/AA 규칙)을 참고.<br>목표에 대한 수치가 따로 적혀있지 않다면, 지상 전투: 1x, 공중/해상 전투: 0.5x 사용.',
                '[11]': '전투 지원 기준<br>공습(Air Raid): 없음. 자동으로 YES.<br>지상 공격(Ground Attacks): 최소한 공중 또는 해상 유닛 1개 이상 필요. <br>해상 침공(Naval Invasion): 최소한 해상 유닛 1개 이상 필요. <br>공중/해상 침공(Air/Naval Invasion): 공중과 해상 유닛 각각 최소 1개 이상, 또는 항모 1개 이상 필요.',
                '[12]': '질식 공격(Smothering Attack): 활성화된 하나 이상의 공중/해상 유닛이 적의 유닛/스택을 묶어 두기 위해 그들이 위치한 헥스를 공격하여 목표 헥스 이외의 전투 헥스를 만들어내는 것. 전투 헥스가 하나 이상 생성되어야 하기 때문에 EC 공세 중에만 수행할 수 있음.'
            };
        
            // 병력 구성 정보 데이터
            const strategies = {
                'Air Raid': {
                    name: '공중 습격 \n (Air Raid)',
                    details: [
                        '병력: 공중 유닛, 해상 유닛, 항모',
                        '유닛을 선택할 때 가능하다면 공중 균형(Air Parity)을 맞출 만큼 충분히 선택합니다.'
                    ]
                },
                'Ground Attack with Air Support': {
                    name: '공중 지원 지상 공격\n(Ground Attack with Air Support)',
                    details: [
                        '병력: 지상 유닛, 공중 유닛, 항모(범위 내).'
                    ]
                },
                'Ground Attack with Air/Naval Support': {
                    name: '공중/해상 지원 지상 공격\n(Ground Attack with Air/Naval Support)',
                    details: [
                        '병력: 지상 유닛, 공중 유닛, 항모'
                    ]
                },
                'Invasion with Naval Support': {
                    name: '해상 지원을 받는 침공\n(Invasion with Naval Support)',
                    details: [
                        '병력: 해상 유닛, 지상 유닛 상륙 강습(AA) 및 항모.'
                    ]
                },
                'Invasion with Air/Naval Support': {
                    name: '공중/해상 지원을 받는 침공\n(Invasion with Air/Naval Support)',
                    details: [
                        '병력: 공중 유닛, 해상 유닛, 지상 유닛 상륙 강습(AA) 및 항모.'
                    ]
                },
                'Unsupported Invasion': {
                    name: '무지원 침공 [4][5]\n(Unsupported Invasion)',
                    details: [
                        '병력: 지상 유닛 상륙 강습(AA)'
                    ]
                },
                'March into the Target': {
                    name: '목표로 진군 [2][4] \n (March into the Target)',
                    details: [
                        '목표 헥스로 진군합니다.'
                    ]
                },
                'Execute Air/Naval Attack against weakest stack': {
                    name: '가장 약한 스택을 대상으로 공중/해상 공격 실행',
                    details: [
                        '가장 약한 스택에 공중/해상 공격을 수행합니다.'
                    ]
                },
                'Move activated units to the Target': {
                    name: '활성화된 유닛을 목표로 이동',
                    details: [
                        '활성화된 유닛을 목표 헥스로 이동합니다.'
                    ]
                },
                'Consider Performing a Smothering Attack (see CDSS)': {
                    name: '질식 공격 고려 [12]',
                    details: [
                        '질식 공격을 고려합니다.'
                    ]
                },
                'Create a new Force for the next Target': {
                    name: '다음 목표를 위한 새로운 병력 생성',
                    details: [
                        '다음 목표를 위한 새로운 병력을 생성합니다.'
                    ]
                },
                'Activate units for the target': {
                    name: '목표를 위해 유닛을 활성화합니다 [3]][4]',
                    details: [
                        '목표를 위해 유닛을 활성화합니다.'
                    ]
                },
                'Activate more units with extra activations': {
                    name: '추가 활성화로 더 많은 유닛 활성화 [8]',
                    details: [
                        '추가 활성화로 더 많은 유닛을 활성화합니다.'
                    ]
                }
            };
        
            // 하위 우선순위 목록 (필요 시 추가, 이미지에 따라 비어있음)
            const subPriorities = {};
        
            // 조건 정의
            const conditions = {
                'A': '목표에 대한 공중-해상 공격입니까?',
                'B': '목표가 해안 또는 섬 헥스입니까?',
                'C': '육상 진격(Overland Advance)로 목표를 장악할 수 있습니까?',
                'D or (E and F)': '다음 중 하나 이상이 참입니까? <li>목표에 적의 해상 유닛만 있고, 지상 유닛이 목표에 진입하거나 빠져나올 수 있는 경우</li> <li>목표 헥스가 점령되지 않은 경우</li>',
                'D1': '목표 헥스가 비어 있습니까(Unoccupied)?',
                'D2': '목표 헥스가 비어 있습니까(Unoccupied)?',
                'G': '목표 헥스가 잠재적인 SR(특수 대응) 헥스입니까?',
                'H': '적 공중 유닛 또는 항공 모함 유닛이 이 목표에 대응할 수 있습니까?',
                'I': '전투 지원 기준을 충족할 만큼 활성화 개수가 충분합니까?',
                'J': '목표에 피해 수준만큼의 피해를 입혔습니까?',
                'K+L': '다음 조건을 모두 충족합니까? <li>적 해상 또는 지상 유닛이 이 목표에 대응할 수 있음</li> <li>EC 공세임</li>',
                'M': '이 헥스가 마지막 목표입니까?'
            };
        
            let currentStep = 'start';
            let pathHistory = [];
            let stepCount = 0;
            let evaluatedConditions = {};
        
            function startFlow() {
                currentStep = 'A';
                stepCount = 1;
                pathHistory = [];
                evaluatedConditions = {};
                showStep('A');
            }
        
            function showStep(stepId) {
                const stepSection = document.getElementById('stepSection');
                const stepNumber = document.getElementById('stepNumber');
                const stepTitle = document.getElementById('stepTitle');
                const conditionBox = document.getElementById('conditionBox');
                const buttonGroup = document.getElementById('buttonGroup');
                const diceSection = document.getElementById('diceSection');
                const resultSection = document.getElementById('resultSection');
        
                stepSection.classList.remove('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.add('hidden');
        
                stepNumber.textContent = stepCount;
        
                if (stepId === 'DICE') {
                    stepSection.classList.add('hidden');
                    diceSection.classList.remove('hidden');
                    document.getElementById('diceResult').textContent = '?';
                    return;
                }

                // if (conditions[stepId]) {
                //     stepTitle.textContent = `${stepId} 확인`;
                //     conditionBox.innerHTML = `<strong>Step ${stepCount}:</strong> ${conditions[stepId]}`;
                //     buttonGroup.innerHTML = `
                //         <button class="btn btn-yes" onclick="selectChoice('${stepId}', true)">YES</button>
                //         <button class="btn btn-no" onclick="selectChoice('${stepId}', false)">NO</button>
                //         ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                //     `;
                // } else if (stepId === 'start') {
                //     stepTitle.textContent = '시작';
                //     conditionBox.innerHTML = `<strong>Step 1:</strong> 태스크 포스 결정 시작`;
                //     buttonGroup.innerHTML = `
                //         <button class="btn btn-primary" onclick="startFlow()">시작하기</button>
                //     `;
                // } else if (stepId === 'Activate Units for the Target') {
                //     stepTitle.textContent = '목표에 대한 유닛 활성화';
                //     conditionBox.innerHTML = `<strong>Step ${stepCount}:</strong> 목표에 대한 유닛을 활성화합니다.`;
                //     buttonGroup.innerHTML = `
                //         <button class="btn btn-primary" onclick="selectChoice('Activate Units for the Target', true)">계속</button>
                //         ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                //     `;
                // } else if (stepId === 'K+L') {
                //     stepTitle.textContent = 'K+L 확인';
                //     conditionBox.innerHTML = `<strong>Step ${stepCount}:</strong> K와 L 조건을 확인하세요.`;
                //     buttonGroup.innerHTML = `
                //         <button class="btn btn-yes" onclick="selectChoice('K+L', true)">YES</button>
                //         <button class="btn btn-no" onclick="selectChoice('K+L', false)">NO</button>
                //         ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                //     `;
                // } else if (stepId === 'M') {
                //     stepTitle.textContent = 'M 확인';
                //     conditionBox.innerHTML = `<strong>Step ${stepCount}:</strong> 추가 활성화로 더 많은 유닛을 활성화할 수 있습니까?`;
                //     buttonGroup.innerHTML = `
                //         <button class="btn btn-yes" onclick="selectChoice('M', true)">YES</button>
                //         <button class="btn btn-no" onclick="selectChoice('M', false)">NO</button>
                //         ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                //     `;
                // }
        
                if (conditions[stepId]) {
                    stepTitle.textContent = `${stepId} 확인`;
                    conditionBox.innerHTML = ` ${conditions[stepId]}`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-yes" onclick="selectChoice('${stepId}', true)">YES</button>
                        <button class="btn btn-no" onclick="selectChoice('${stepId}', false)">NO</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                } else if (stepId === 'start') {
                    stepTitle.textContent = '시작';
                    conditionBox.innerHTML = `태스크 포스 결정 시작`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-primary" onclick="startFlow()">시작하기</button>
                    `;
                } else if (stepId === 'Activate Units for the Target') {
                    stepTitle.textContent = '목표에 대한 유닛 활성화';
                    conditionBox.innerHTML = ` 목표에 대한 유닛을 활성화합니다. <br><ul><li>선택된 전략의 병력Force 편성 유형에 따라, 목표 범위 내에서 해당 헥스의 피해 수준 기준을 달성할 수 있는 최소한의 유닛을 활성화합니다. 달성 불가한 경우 가능한 한 많은 유닛을 활성화합니다. 만약 대응이 가능하다면, 목표에 도달할 수 있는 적의 대응 병력을 고려하여 필요한 전력을 계산합니다.</li><li>일본 제도 외의 HQ 헥스에 주둔 중인 지상 유닛의 경우, HQ를 방어하기 위해 반드시 하나는 해당 헥스에 남겨둬야 하며 활성화하지않습니다.</li></ul><br><b>피해 수준 기준</b><ul><li>공격력에 피해 결과를 곱한 값으로, 목표 헥스에 있는 적 부대를 파괴합니다. 1x 결과는 전투 테이블의 결과가 1x인 경우 적과 동등 이상의 전투력이 있어야 적 유닛을 제거한다는 의미입니다. 지상 전투는 (육상 진격/AA 규칙)을 참고.</li><li>목표에 대한 수치가 따로 적혀있지 않다면, 지상 전투: 1x, 공중/해상 전투: 0.5x 사용.</li></ul>`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-primary" onclick="selectChoice('Activate Units for the Target', true)">계속</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                } else if (stepId === 'K+L') {
                    stepTitle.textContent = 'K+L 확인';
                    conditionBox.innerHTML = ` K와 L 조건을 확인하세요.`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-yes" onclick="selectChoice('K+L', true)">YES</button>
                        <button class="btn btn-no" onclick="selectChoice('K+L', false)">NO</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                } else if (stepId === 'M') {
                    stepTitle.textContent = 'M 확인';
                    conditionBox.innerHTML = ` 추가 활성화로 더 많은 유닛을 활성화할 수 있습니까?`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-yes" onclick="selectChoice('M', true)">YES</button>
                        <button class="btn btn-no" onclick="selectChoice('M', false)">NO</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                }
        
                updateProgress();
                updatePathHistory();
            }
        
            function selectChoice(conditionId, choice) {
                evaluatedConditions[conditionId] = choice;
                pathHistory.push({ step: conditionId, choice: choice, stepNum: stepCount });
                stepCount++;
        
                const nextStep = getNextStep(conditionId, choice);
        
                if (nextStep.startsWith('STRATEGY_')) {
                    const strategy = nextStep.replace('STRATEGY_', '');
                    showResult(strategy);
                } else {
                    currentStep = nextStep;
                    showStep(nextStep);
                }
            }
        
            function getNextStep(conditionId, choice) {
                switch (conditionId) {
                    case 'A':
                        return choice ? 'STRATEGY_Air Raid' : 'B';
                    case 'B':
                        return choice ? 'C' : 'D2';
                    case 'C':
                        return choice ? 'D or (E and F)' : 'D1';
                    case 'D1':
                        return choice ? 'G' : 'H';
                    case 'G':
                        return choice ? 'H' : 'STRATEGY_Unsupported Invasion';
                    case 'D2':
                        return choice ? 'STRATEGY_March into the Target' : 'STRATEGY_Ground Attack with Air Support';
                    case 'D or (E and F)':
                        return choice ? 'STRATEGY_March into the Target' : 'STRATEGY_Ground Attack with Air/Naval Support';
                    case 'H':
                        return choice ? 'STRATEGY_Invasion with Air/Naval Support' : 'STRATEGY_Invasion with Naval Support';
                    case 'I':
                        return choice ? 'J' : 'STRATEGY_Execute Air/Naval Attack against weakest stack';
                    case 'J':
                        return choice ? 'STRATEGY_Move activated units to the Target' : 'DICE';
                    case 'K+L':
                        return choice ? 'STRATEGY_Consider Performing a Smothering Attack (see CDSS)' : 'M';
                    case 'M':
                        return choice ? 'STRATEGY_Activate more units with extra activations' : 'STRATEGY_Create a new Force for the next Target';
                    case 'Activate Units for the Target':
                        return 'I';
                    case 'Air Raid Continue':
                    case 'Ground Attack with Air Support Continue':
                    case 'Ground Attack with Air/Naval Support Continue':
                    case 'Invasion with Naval Support Continue':
                    case 'Invasion with Air/Naval Support Continue':
                        return 'Activate Units for the Target';
                    case 'Move activated units to the Target Continue':
                        return 'K+L';
                    case 'Consider Performing a Smothering Attack (see CDSS) Continue':
                        return 'M';
                    case 'Execute Air/Naval Attack against weakest stack Continue':
                        return 'K+L';
                    default:
                        return 'start';
                }
            }
        
            function rollDice() {
                const diceValue = Math.floor(Math.random() * 10); // 0-9
                document.getElementById('diceResult').textContent = diceValue;
        
                let strategy;
                if (diceValue <= 3) {
                    strategy = 'Move activated units to the Target';
                } else {
                    strategy = 'Execute Air/Naval Attack against weakest stack';
                }
        
                pathHistory.push({
                    step: 'DICE',
                    choice: diceValue,
                    stepNum: stepCount,
                    isResult: true,
                    result: strategy
                });
        
                setTimeout(() => showResult(strategy), 1000);
            }
        
            function showResult(strategyKey) {
                const strategy = strategies[strategyKey];
                if (!strategy) {
                    console.error('Strategy not found:', strategyKey);
                    return;
                }
        
                const stepSection = document.getElementById('stepSection');
                const diceSection = document.getElementById('diceSection');
                const resultSection = document.getElementById('resultSection');
                const strategyTitle = document.getElementById('strategyTitle');
                const strategyName = document.getElementById('strategyName');
                const strategyDetails = document.getElementById('strategyDetails');
                const buttonGroup = document.getElementById('resultSection').querySelector('.button-group');
        
                stepSection.classList.add('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.remove('hidden');
                strategyTitle.textContent = '최종 병력 구성';
                strategyName.textContent = strategy.name;
        
                // 특정 전략에 대해 내용 없이 제목만 표시하고 '계속' 버튼 추가
                const continueStrategies = [];
                // const continueStrategies = ['Air Raid', 'Ground Attack with Air Support', 'Ground Attack with Air/Naval Support', 'Invasion with Naval Support', 'Invasion with Air/Naval Support', 'Move activated units to the Target', 'Consider Performing a Smothering Attack (see CDSS)'];
                if (continueStrategies.includes(strategyKey)) {
                    // // strategyDetails.innerHTML = '';
                    // buttonGroup.innerHTML = `
                    //     <button class="btn btn-primary" onclick="selectChoice('${strategyKey} Continue', true)">계속</button>
                    //     <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                    //     ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    // `;
                    const annotationRegex = /\[\d+\]/g;
                    const parts = strategy.details.split(annotationRegex);
                    const annotations = strategy.details.match(annotationRegex);

                    let combined = '';
                    parts.forEach((part, i) => {
                        combined += part;
                        if (annotations && annotations[i]) {
                            const number = annotations[i].replace(/\[|\]/g, '');
                            combined += `<sup class="annotation" data-number="${number}">[${number}]</sup>`;
                        }
                    });
                    strategyDetails.innerHTML = combined;

                    // 그리고 버튼 그룹에는 "계속" 버튼 + 기존 버튼들 추가
                    buttonGroup.innerHTML = `
                        <button class="btn btn-primary" onclick="selectChoice('${strategyKey} Continue', true)">계속</button>
                        <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                } else {
                    const annotationRegex = /\[\d+\]/g;
                    const annotations = new Set();
                    if (strategy.name.match(annotationRegex)) {
                        strategy.name.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                    }
                    strategy.details.forEach(detail => {
                        if (detail.match(annotationRegex)) {
                            detail.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                        }
                    });
        
                    strategyDetails.innerHTML = `
                        <h4 style="margin-top: 0; color: #fff;">병력 구성 세부사항:</h4>
                        <ul class="strategy-list">
                            ${strategy.details.map(detail => `
                                <li>
                                    ${detail}
                                    ${subPriorities[detail] ? `
                                        <ul class="sub-priority-list">
                                            ${subPriorities[detail].map(sub => `<li>${sub}</li>`).join('')}
                                        </ul>
                                    ` : ''}
                                </li>
                            `).join('')}
                        </ul>
                        ${annotations.size > 0 ? `
                            <h4 style="margin-top: 20px; color: #fff;">주석:</h4>
                            <ul class="strategy-list">
                                ${Array.from(annotations).sort().map(annotation => `
                                    <li class="impl-note">${annotation}: ${notes[annotation]}</li>
                                `).join('')}
                            </ul>
                        ` : ''}
                    `;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-primary" onclick="selectChoice('${strategyKey} Continue', true)">계속</button>
                        <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                }
        
                updateProgress();
                updatePathHistory();
            }
        
            function updateProgress() {
                const progressFill = document.getElementById('progressFill');
                const totalSteps = 15;
                const progress = Math.min((stepCount / totalSteps) * 100, 100);
                progressFill.style.width = progress + '%';
            }
        
            function updatePathHistory() {
                const pathHistoryDiv = document.getElementById('pathHistory');
                const pathStepsDiv = document.getElementById('pathSteps');
        
                if (pathHistory.length === 0) {
                    pathHistoryDiv.classList.add('hidden');
                    return;
                }
        
                pathStepsDiv.innerHTML = '';
        
                pathHistory.forEach(step => {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = `path-step ${step.choice && step.step !== 'DICE' ? 'yes' : step.step !== 'DICE' ? 'no' : ''}`;
        
                    if (step.step === 'DICE') {
                        stepDiv.innerHTML = `
                            <div class="step-icon">${step.choice}</div>
                            <div>
                                <strong>Roll dice:</strong> ${step.choice} 
                                ${step.result ? `→ ${strategies[step.result].name}` : ''}
                            </div>
                        `;
                    } else {
                        let conditionText = conditions[step.step] || step.step;
                        stepDiv.innerHTML = `
                            <div class="step-icon">${step.choice ? 'Y' : 'N'}</div>
                            <div>
                                <strong>${step.step}:</strong> 
                                ${conditionText} → ${step.choice ? 'YES' : 'NO'}
                            </div>
                        `;
                    }
        
                    pathStepsDiv.appendChild(stepDiv);
                });
        
                pathHistoryDiv.classList.remove('hidden');
            }
        
            function resetFlow() {
                currentStep = 'start';
                stepCount = 0;
                pathHistory = [];
                evaluatedConditions = {};
        
                const stepSection = document.getElementById('stepSection');
                const diceSection = document.getElementById('diceSection');
                const resultSection = document.getElementById('resultSection');
                const pathHistoryDiv = document.getElementById('pathHistory');
                const stepNumber = document.getElementById('stepNumber');
                const stepTitle = document.getElementById('stepTitle');
                const conditionBox = document.getElementById('conditionBox');
                const buttonGroup = document.getElementById('buttonGroup');
                const progressFill = document.getElementById('progressFill');
        
                stepSection.classList.remove('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.add('hidden');
                pathHistoryDiv.classList.add('hidden');
                stepNumber.textContent = '1';
                stepTitle.textContent = '시작';
                conditionBox.innerHTML = '에라스무스의 태스크 포스 구성을 결정합니다';
                buttonGroup.innerHTML = '<button class="btn btn-primary" onclick="startFlow()">시작하기</button>';
                progressFill.style.width = '0%';
            }
        
            function goBack() {
                if (pathHistory.length === 0) return;
        
                const lastStep = pathHistory.pop();
                stepCount--;
        
                if (lastStep.step !== 'DICE') {
                    delete evaluatedConditions[lastStep.step];
                }
        
                currentStep = pathHistory.length > 0 ? pathHistory[pathHistory.length - 1].step : 'start';
        
                const stepSection = document.getElementById('stepSection');
                const diceSection = document.getElementById('diceSection');
                const resultSection = document.getElementById('resultSection');
        
                stepSection.classList.remove('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.add('hidden');
                showStep(currentStep);
            }
        
            window.onload = resetFlow;
        </script>
  </template>

  <!-- 6. 대응 -->
  <template id="tmpl-resp">
    <!DOCTYPE html>
    <html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Japanese Erasmus Bot - 대응 구성</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                background: #2e2e2e;
                min-height: 100vh;
                margin: 0;
                padding: 20px;
                box-sizing: border-box;
                color: #d8d8d8;
            }
        
            .impl-note {
                font-style: italic;
                font-size: 14px;
                color: #ffffff;
                line-height: 1.6;
                margin: 4px 0;
            }
        
            .container {
                max-width: 800px;
                margin: 0 auto;
                background: #3c3c3c;
                border-radius: 8px;
                padding: 20px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            }
        
            .header {
                text-align: center;
                margin-bottom: 20px;
                padding: 15px;
                background: #4a4a4a;
                border-radius: 8px;
                color: #ffffff;
                border: 1px solid #5c5c5c;
            }
        
            .header h1 {
                margin: 0;
                font-size: 2rem;
                font-weight: 700;
            }
        
            .header p {
                margin: 8px 0 0 0;
                font-size: 1rem;
                font-weight: 400;
            }
        
            .progress-bar {
                background: #4a4a4a;
                border-radius: 5px;
                height: 6px;
                margin-bottom: 20px;
                overflow: hidden;
                border: 1px solid #5c5c5c;
            }
        
            .progress-fill {
                background: #4682b4;
                height: 100%;
                border-radius: 5px;
                transition: width 0.3s ease;
                width: 0%;
            }
        
            .step-section {
                background: #3c3c3c;
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 15px;
                border: 1px solid #5c5c5c;
            }
        
            .step-header {
                display: flex;
                align-items: center;
                margin-bottom: 15px;
            }
        
            .step-number {
                background: #4682b4;
                color: #ffffff;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                font-size: 1rem;
                margin-right: 15px;
            }
        
            .step-title {
                font-size: 1.3rem;
                font-weight: 600;
                color: #d8d8d8;
                margin: 0;
            }
        
            .condition-box {
                background: #4a4a4a;
                border-left: 4px solid #4682b4;
                border-radius: 5px;
                padding: 15px;
                margin: 15px 0;
                font-size: 1rem;
                line-height: 1.5;
                color: #c8c8c8;
            }
        
            .condition-box strong {
                color: #4682b4;
                font-size: 1.1rem;
            }
        
            .button-group {
                display: flex;
                gap: 15px;
                justify-content: center;
                margin-top: 20px;
            }
        
            .btn {
                padding: 10px 30px;
                border: none;
                border-radius: 5px;
                font-size: 1rem;
                font-weight: 500;
                cursor: pointer;
                transition: background 0.2s ease, transform 0.1s ease;
                text-transform: uppercase;
                min-width: 100px;
                font-family: 'Georgia', 'Times New Roman', Times, serif;
            }
        
            .btn-yes {
                background: #2e8b57;
                color: #ffffff;
            }
        
            .btn-yes:hover {
                background: #257a4b;
                transform: translateY(-2px);
            }
        
            .btn-no {
                background: #696969;
                color: #ffffff;
            }
        
            .btn-no:hover {
                background: #585858;
                transform: translateY(-2px);
            }
        
            .btn-primary {
                background: #4682b4;
                color: #ffffff;
            }
        
            .btn-primary:hover {
                background: #3a6b9a;
                transform: translateY(-2px);
            }
        
            .btn-secondary {
                background: #5c5c5c;
                color: #ffffff;
            }
        
            .btn-secondary:hover {
                background: #4b4b4b;
                transform: translateY(-2px);
            }
        
            .btn-back {
                background: #5c5c5c;
                color: #ffffff;
            }
        
            .btn-back:hover {
                background: #4b4b4b;
                transform: translateY(-2px);
            }
        
            .path-history {
                background: #4a4a4a;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 15px;
                border-left: 3px solid #2e8b57;
            }
        
            .path-step {
                display: flex;
                align-items: center;
                margin: 8px 0;
                padding: 8px;
                background: #3c3c3c;
                border-radius: 5px;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            }
        
            .path-step .step-icon {
                width: 25px;
                height: 25px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                margin-right: 10px;
                font-size: 0.8rem;
            }
        
            .path-step.yes .step-icon {
                background: #2e8b57;
                color: #ffffff;
            }
        
            .path-step.no .step-icon {
                background: #696969;
                color: #ffffff;
            }
        
            .dice-section {
                background: #4a4a4a;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                margin: 15px 0;
                border: 1px solid #5c5c5c;
            }
        
            .dice-result {
                font-size: 3rem;
                font-weight: bold;
                color: #d8d8d8;
                margin: 15px 0;
            }
        
            .result-section {
                background: #2e8b57;
                color: #ffffff;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                margin-top: 15px;
                border: 1px solid #3c3c3c;
            }
        
            .result-section h2 {
                margin: 0 0 15px 0;
                font-size: 2rem;
                display: none;
            }
        
            .result-section p {
                margin: 10px 0;
                font-size: 32px;
                white-space: pre-line;
                font-weight: bold;
                font-style: italic;
            }
        
            .strategy-details {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 5px;
                padding: 15px;
                margin-top: 15px;
            }
        
            .strategy-list {
                text-align: left;
                margin: 15px 0;
                list-style: none;
                padding: 0;
            }
        
            .strategy-list li {
                margin: 8px 0;
                padding: 8px 10px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 5px;
                border-left: 3px solid rgba(255, 255, 255, 0.3);
            }
        
            .sub-priority-list {
                list-style: none;
                padding-left: 20px;
                margin-top: 5px;
            }
        
            .sub-priority-list li {
                margin: 5px 0;
                padding: 5px 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 5px;
                border-left: 2px solid rgba(255, 255, 255, 0.4);
                font-size: 0.9rem;
            }
        
            .hidden {
                display: none;
            }
        
            @media (max-width: 768px) {
                .container {
                    padding: 15px;
                    margin: 10px;
                }
                
                .header h1 {
                    font-size: 1.5rem;
                }
                
                .button-group {
                    flex-direction: column;
                    align-items: center;
                }
                
                .btn {
                    width: 100%;
                    max-width: 180px;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>대응</h1>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div id="pathHistory" class="path-history hidden">
                <h4 style="margin-top: 0; color: #ffffff;">진행 경로</h4>
                <div id="pathSteps"></div>
            </div>

            <div id="stepSection" class="step-section">
                <div class="step-header">
                    <div class="step-number" id="stepNumber">1</div>
                    <h2 class="step-title" id="stepTitle">시작</h2>
                </div>
                
                <div class="condition-box" id="conditionBox">
                    첫 번째 조건을 확인해주세요.
                </div>
                
                <div class="button-group" id="buttonGroup">
                    <button class="btn btn-primary" onclick="startFlow()">시작하기</button>
                </div>
            </div>

            <div id="diceSection" class="dice-section hidden">
                <h3 style="margin: 0 0 20px 0; color: #2d3436;">Roll D10</h3>
                <div class="dice-result" id="diceResult">?</div>
                <div class="button-group">
                    <button class="btn btn-primary" onclick="rollDice()">Roll dice</button>
                </div>
            </div>

            <div id="resultSection" class="result-section hidden">
                <h2 id="strategyTitle">최종 병력 구성</h2>
                <p id="strategyName"></p>
                <div class="strategy-details" id="strategyDetails"></div>
                <div class="button-group" style="margin-top: 30px;">
                    <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                </div>
            </div>
        </div>

        <script>
            // Implementation notes
            const notes = {
                '[1]': '선택지가 있다면, 반격(Counteroffensive) 카드보다 먼저 JN-25 첩보(Intelligence) 카드를 사용합니다.',
                '[2]': '여러 적 유닛 중에서 선택해야 할 경우, 우선순위는 다음과 같습니다: 항모(CV) → 전함(BB) → 중순양함(CA) → 구축함(DD). 동일 유형일 경우 방어력이 가장 높은 유닛을 선택합니다.',
                '[3]': '여러 전투 헥스가 가능할 경우, 대응 전략의 우선순위 목록을 따라 전투 헥스를 선택합니다.',
                '[4]': '2스텝 손실을 가할 때도 [2]와 동일하게, CV → BB → CA → DD 순서로, 같은 유형 중에서는 방어력이 가장 높은 유닛을 선택합니다.',
                '[5]': '우선순위가 동일한 전투 헥스가 여러 개 있을 경우, 무작위로 순서를 결정합니다.',
                '[6]': '최우선 전투 헥스의 대응 병력 조건을 먼저 충족해야 하며, 그다음은 두 번째, 세 번째 순으로 충족합니다.',
                '[7]': '특정 전투 헥스 조건을 충족할 수 없을 경우, 다음 우선순위 전투 헥스로 건너뜁니다. 이 과정을 반복하다가 더 이상 대응할 전투 헥스가 없으면 종료합니다.',
                '[8]': '가용(Available)"이란 카드를 손에 보유하는 것 외에도, Erasmus가 해당 페이즈에서 최대 3장의 보너스 뽑기 제한을 아직 초과하지 않았다는 뜻입니다.',
                '[9]': '특정 전략에 PBM이 있다면, 이 표를 적용하기 전에 먼저 그것을 따릅니다.',
                '[10]': '우선순위 헥스가 모두 일본 AZOI에 이미 들어가 있는 경우, 그 우선순위는 건너뜁니다.',
                '[11]': '여러 공군 기지가 있을 경우, 여러 우선순위를 동시에 충족할 수 있는 기지를 우선적으로 선택합니다.',
                '[12]': '한 공군 기지에는 공중 유닛은 최대 1개만 배치할 수 있습니다.',
                '[13]': '가능한 공중 유닛 중에서는 가장 강력한 유닛을 선택합니다.',
                '[14]': '자원 헥스가 여러개인 경우, 가장 가까운 자원 헥스 → 두 번째로 가까운 자원 헥스 .. 순으로 선택합니다.',
                '[15]': '대응 카드에 보너스 뽑기가 적혀 있을 경우, 주사위 굴림에 -4를 적용합니다.'
            };
        
            // 병력 구성 정보 데이터
            const strategies = {
                'Play Weather Reaction Card': {
                    name: '날씨 대응 카드 사용',
                    details: ['날씨 대응 카드를 사용합니다.']
                },
                'Roll for each SR': {
                    name: '각 SR에 대해 주사위 굴림',
                    details: ['각 SR에 대해 주사위를 굴립니다.']
                },
                'Play Intel-CO Reaction Card': {
                    name: '첩보-CO 대응 카드 사용 [1]',
                    details: ['첩보-CO 대응 카드를 사용합니다.']
                },
                'If possible, roll for Intelligence': {
                    name: '가능하다면 첩보 주사위 굴림',
                    details: ['첩보 주사위 굴림을 시도합니다.']
                },
                'Play Kamikaze Attack Card': {
                    name: '가미카제 공격 카드 사용 [3][4]',
                    details: ['가미카제 공격 카드를 사용합니다.']
                },
                'Play Submarine Attack Card': {
                    name: '잠수함 공격 카드 사용 [2]',
                    details: ['잠수함 공격 카드를 사용합니다.']
                },
                'Execute PBM if applicable': {
                    name: '적용 가능한 경우 PBM 수행',
                    details: ['적용 가능한 경우 PBM을 수행합니다.']
                },
                'Reaction Strategy': {
                    name: '대응 전략',
                    details: ['대응 전략을 실행합니다.']
                }
            };
        
            // 하위 우선순위 목록 (필요 시 추가)
            const subPriorities = {};
        
            // 조건 정의
            const conditions = {
                'A': '사용 가능한 날씨 카드가 있습니까?',
                'B': '날씨 카드 기준을 충족합니까?<br><br><b>날씨 카드 기준</b><li>1d10을 굴립니다. 결과가 활성 아군 유닛 수 x 2보다 적으면 사용합니다.</li> <li>기습 카드인 경우 주사위 결과에 -2를 적용합니다</li>',
                'C': 'SR 상황이 있습니까?',
                'E+(F or G)': '다음 조건을 모두 충족합니까? <li>전투 헥스가 보급 상태인 본부의 범위 안에 있음</li> <li>JN-25 대응 카드를 사용할 수 있거나 반격 대응 카드를 사용할 수 있음[8]</li>',
                'I+J': '다음 조건을 모두 충족합니까? <li>DEI 및 방어 경계 목표를 충족함(초기 단계에서만)</li> <li>가미카제 카드를 가지고 있으며 가미카제 공격 기준을 충족함[8]</li><br><br><b>가미카제 카드 기준</b><br>가미카제 공격이 가능한 전투 헥스가 있다고 가정하고, 다음 경우에만 사용합니다:<li>1. 최소 한 척의 연합군 BB 또는 CV에 명중할 수 있는 경우</li> <li>2. 1스텝 손실이 가능하며 점이 없는(Non-dot) 공중 유닛이 있는 경우</li>',
                'K+L': '다음 조건을 모두 충족합니까? <li>사용 가능한 잠수함 공격 카드가 있음[8]</li> <li>잠수함 공격 카드의 특정 조건을 충족하는 적 유닛이 최소 하나 있음</li>',
                'D': '전투 헥스가 있습니까?',
                'E': '전투 헥스가 보급 상태인 본부의 범위 안에 있습니까?',
                'F': 'JN-25 대응 카드를 사용할 수 있습니까?[8]',
                'G': '반격 대응 카드를 사용할 수 있습니까?[8]',
                'H': '최소 하나의 전투 헥스에서 대응 부대 기준을 충족합니까?<br><br><b>대응 부대 기준</b><br>다음 경우일 때, 최소한 유닛 # 개를 활성화합니다:<li>1. 공중/해상 통합 전투력이 상대 공중/해상 전투력의 1x 이상</li><li>2. 아군 공중 유닛 # 개 = 적 공중 유닛 # 개</li><li>3. 1D10 주사위 굴림 결과: <ul><li>0-4: 2x 결과에서 지상 유닛의 상대 지상 유닛을 제거할 수 있음.</li> <li>5-9: 기준 없음.</li></ul></li>',
                'I': 'DEI 및 방어 경계 목표를 충족합니까?(초기 단계에서만)',
                'J': '가미카제 카드를 가지고 있으며 가미카제 공격 기준을 충족합니까?[8]',
                'K': '사용 가능한 잠수함 공격 카드가 있습니까?[8]',
                'L': '잠수함 공격 카드의 특정 조건을 충족하는 적 유닛이 최소 하나 있습니까?'
            };
        
            let currentStep = 'start';
            let pathHistory = [];
            let stepCount = 0;
            let evaluatedConditions = {};
        
            function startFlow() {
                currentStep = 'A';
                stepCount = 1;
                pathHistory = [];
                evaluatedConditions = {};
                showStep('A');
            }
        
            function showStep(stepId) {
                const stepSection = document.getElementById('stepSection');
                const stepNumber = document.getElementById('stepNumber');
                const stepTitle = document.getElementById('stepTitle');
                const conditionBox = document.getElementById('conditionBox');
                const buttonGroup = document.getElementById('buttonGroup');
                const diceSection = document.getElementById('diceSection');
                const resultSection = document.getElementById('resultSection');
        
                stepSection.classList.remove('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.add('hidden');
        
                stepNumber.textContent = stepCount;
        
                if (stepId === 'DICE') {
                    stepSection.classList.add('hidden');
                    diceSection.classList.remove('hidden');
                    document.getElementById('diceResult').textContent = '?';
                    return;
                }
        
                if (conditions[stepId]) {
                    stepTitle.textContent = `${stepId} 확인`;
                    conditionBox.innerHTML = ` ${conditions[stepId]}`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-yes" onclick="selectChoice('${stepId}', true)">YES</button>
                        <button class="btn btn-no" onclick="selectChoice('${stepId}', false)">NO</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                } else if (stepId === 'start') {
                    stepTitle.textContent = '시작';
                    conditionBox.innerHTML = `첫 번째 조건을 확인해주세요.`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-primary" onclick="startFlow()">시작하기</button>
                    `;
                } else if (stepId === 'C') {
                    stepTitle.textContent = '각 SR에 대해 굴림';
                    conditionBox.innerHTML = ` 각 SR에 대해 주사위를 굴립니다.`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-primary" onclick="selectChoice('C', true)">계속</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                } else if (stepId === 'If possible, roll for Intelligence') {
                    stepTitle.textContent = '첩보 굴림 가능 여부';
                    conditionBox.innerHTML = ` 가능하다면 첩보 주사위를 굴립니다. 성공 여부를 골라주세요`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-yes" onclick="selectChoice('If possible, roll for Intelligence', 'success')">성공</button>
                        <button class="btn btn-no" onclick="selectChoice('If possible, roll for Intelligence', 'failure')">실패</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                }
        
                updateProgress();
                updatePathHistory();
            }
        
            function selectChoice(conditionId, choice) {
                evaluatedConditions[conditionId] = choice;
                pathHistory.push({ step: conditionId, choice: choice, stepNum: stepCount });
                stepCount++;
        
                const nextStep = getNextStep(conditionId, choice);
        
                if (nextStep.startsWith('STRATEGY_')) {
                    const strategy = nextStep.replace('STRATEGY_', '');
                    showResult(strategy);
                } else if (nextStep === 'DICE') {
                    currentStep = nextStep;
                    showStep(nextStep);
                } else {
                    currentStep = nextStep;
                    showStep(nextStep);
                }
            }
        
            function getNextStep(conditionId, choice) {
                switch (conditionId) {
                    case 'A':
                        return choice ? 'B' : 'C';
                    case 'B':
                        return choice ? 'STRATEGY_Play Weather Reaction Card' : 'C';
                    case 'C':
                        return choice ? 'STRATEGY_Roll for each SR' : 'D' // '계속'으로 D로 이동
                    case 'D':
                        return choice ? 'E+(F or G)' : 'K+L';
                    case 'E+(F or G)':
                        return choice ? 'DICE' : 'If possible, roll for Intelligence';
                    case 'If possible, roll for Intelligence':
                        return choice === 'success' ? 'H' : 'I+J';
                    case 'H':
                        return choice ? 'STRATEGY_Reaction Strategy' : 'I+J';
                    case 'I+J':
                        return choice ? 'STRATEGY_Play Kamikaze Attack Card' : 'K+L';
                    case 'K+L':
                        return choice ? 'STRATEGY_Play Submarine Attack Card' : 'STRATEGY_Execute PBM if applicable';
                    case 'Play Kamikaze Attack Card Continue':
                        return 'K+L';
                    case 'Play Submarine Attack Card Continue':
                        return 'STRATEGY_Execute PBM if applicable';
                    case 'Roll for each SR Continue':
                        return 'D';
                    case 'Reaction Strategy Continue':
                        return 'I+J';
                    case 'Play Intel-CO Reaction Card Continue':
                        return 'H';
                    default:
                        return 'start';
                }
            }
        
            function rollDice() {
                const diceValue = Math.floor(Math.random() * 10); // 0-9
                document.getElementById('diceResult').textContent = diceValue;
        
                let nextStep;
                if (diceValue === 0) {
                    nextStep = 'STRATEGY_Play Intel-CO Reaction Card';
                } else {
                    nextStep = 'If possible, roll for Intelligence';
                }
        
                pathHistory.push({
                    step: 'DICE',
                    choice: diceValue,
                    stepNum: stepCount,
                    isResult: true,
                    result: nextStep.replace('STRATEGY_', '')
                });
        
                setTimeout(() => {
                    if (nextStep.startsWith('STRATEGY_')) {
                        showResult(nextStep.replace('STRATEGY_', ''));
                    } else {
                        currentStep = nextStep;
                        showStep(nextStep);
                    }
                }, 1000);
            }
        
            function showResult(strategyKey) {
                const strategy = strategies[strategyKey];
                if (!strategy) {
                    console.error('Strategy not found:', strategyKey);
                    return;
                }
        
                const stepSection = document.getElementById('stepSection');
                const diceSection = document.getElementById('diceSection');
                const resultSection = document.getElementById('resultSection');
                const strategyTitle = document.getElementById('strategyTitle');
                const strategyName = document.getElementById('strategyName');
                const strategyDetails = document.getElementById('strategyDetails');
                const buttonGroup = document.getElementById('resultSection').querySelector('.button-group');
        
                stepSection.classList.add('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.remove('hidden');
                strategyTitle.textContent = '최종 병력 구성';
                strategyName.textContent = strategy.name;

                const continueStrategies = [];
                // const continueStrategies = ['Roll for each SR','Play Kamikaze Attack Card','Play Submarine Attack Card', 'Play Intel-CO Reaction Card', 'Reaction Strategy'];
                if (continueStrategies.includes(strategyKey)) {
                    // strategyDetails.innerHTML = '';
                    // buttonGroup.innerHTML = `
                    //     <button class="btn btn-primary" onclick="selectChoice('${strategyKey} Continue', true)">계속</button>
                    //     <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                    //     ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    // `;
                    const annotationRegex = /\[\d+\]/g;
                    const parts = strategy.details.split(annotationRegex);
                    const annotations = strategy.details.match(annotationRegex);

                    let combined = '';
                    parts.forEach((part, i) => {
                        combined += part;
                        if (annotations && annotations[i]) {
                            const number = annotations[i].replace(/\[|\]/g, '');
                            combined += `<sup class="annotation" data-number="${number}">[${number}]</sup>`;
                        }
                    });
                    strategyDetails.innerHTML = combined;

                    // 그리고 버튼 그룹에는 "계속" 버튼 + 기존 버튼들 추가
                    buttonGroup.innerHTML = `
                        <button class="btn btn-primary" onclick="selectChoice('${strategyKey} Continue', true)">계속</button>
                        <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;

                } else {
                    const annotationRegex = /\[\d+\]/g;
                    const annotations = new Set();
                    if (strategy.name.match(annotationRegex)) {
                        strategy.name.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                    }
                    strategy.details.forEach(detail => {
                        if (detail.match(annotationRegex)) {
                            detail.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                        }
                    });
        
                    strategyDetails.innerHTML = `
                        <h4 style="margin-top: 0; color: #fff;">병력 구성 세부사항:</h4>
                        <ul class="strategy-list">
                            ${strategy.details.map(detail => `
                                <li>
                                    ${detail}
                                    ${subPriorities[detail] ? `
                                        <ul class="sub-priority-list">
                                            ${subPriorities[detail].map(sub => `<li>${sub}</li>`).join('')}
                                        </ul>
                                    ` : ''}
                                </li>
                            `).join('')}
                        </ul>
                        ${annotations.size > 0 ? `
                            <h4 style="margin-top: 20px; color: #fff;">주석:</h4>
                            <ul class="strategy-list">
                                ${Array.from(annotations).sort().map(annotation => `
                                    <li class="impl-note">${annotation}: ${notes[annotation]}</li>
                                `).join('')}
                            </ul>
                        ` : ''}
                    `;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-primary" onclick="selectChoice('${strategyKey} Continue', true)">계속</button>
                        <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                }
        
                updateProgress();
                updatePathHistory();
            }
        
            function updateProgress() {
                const progressFill = document.getElementById('progressFill');
                const totalSteps = 15;
                const progress = Math.min((stepCount / totalSteps) * 100, 100);
                progressFill.style.width = progress + '%';
            }
        
            function updatePathHistory() {
                const pathHistoryDiv = document.getElementById('pathHistory');
                const pathStepsDiv = document.getElementById('pathSteps');
        
                if (pathHistory.length === 0) {
                    pathHistoryDiv.classList.add('hidden');
                    return;
                }
        
                pathStepsDiv.innerHTML = '';
        
                pathHistory.forEach(step => {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = `path-step ${step.choice && step.step !== 'DICE' ? 'yes' : step.step !== 'DICE' ? 'no' : ''}`;
        
                    if (step.step === 'DICE') {
                        stepDiv.innerHTML = `
                            <div class="step-icon">${step.choice}</div>
                            <div>
                                <strong>Roll dice:</strong> ${step.choice} 
                                ${step.result ? `→ ${strategies[step.result].name}` : ''}
                            </div>
                        `;
                    } else if (step.choice === 'success' || step.choice === 'failure') {
                        stepDiv.innerHTML = `
                            <div class="step-icon">${step.choice === 'success' ? 'S' : 'F'}</div>
                            <div>
                                <strong>${step.step}:</strong> 
                                ${conditions[step.step] || step.step} → ${step.choice === 'success' ? '성공' : '실패'}
                            </div>
                        `;
                    } else {
                        let conditionText = conditions[step.step] || step.step;
                        stepDiv.innerHTML = `
                            <div class="step-icon">${step.choice ? 'Y' : 'N'}</div>
                            <div>
                                <strong>${step.step}:</strong> 
                                ${conditionText} → ${step.choice ? 'YES' : 'NO'}
                            </div>
                        `;
                    }
        
                    pathStepsDiv.appendChild(stepDiv);
                });
        
                pathHistoryDiv.classList.remove('hidden');
            }
        
            function resetFlow() {
                currentStep = 'start';
                stepCount = 0;
                pathHistory = [];
                evaluatedConditions = {};
        
                const stepSection = document.getElementById('stepSection');
                const diceSection = document.getElementById('diceSection');
                const resultSection = document.getElementById('resultSection');
                const pathHistoryDiv = document.getElementById('pathHistory');
                const stepNumber = document.getElementById('stepNumber');
                const stepTitle = document.getElementById('stepTitle');
                const conditionBox = document.getElementById('conditionBox');
                const buttonGroup = document.getElementById('buttonGroup');
                const progressFill = document.getElementById('progressFill');
        
                stepSection.classList.remove('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.add('hidden');
                pathHistoryDiv.classList.add('hidden');
                stepNumber.textContent = '1';
                stepTitle.textContent = '시작';
                conditionBox.innerHTML = '에라스무스의 대응 여부를 결정합니다';
                buttonGroup.innerHTML = '<button class="btn btn-primary" onclick="startFlow()">시작하기</button>';
                progressFill.style.width = '0%';
            }
        
            function goBack() {
                if (pathHistory.length === 0) return;
        
                const lastStep = pathHistory.pop();
                stepCount--;
        
                if (lastStep.step !== 'DICE') {
                    delete evaluatedConditions[lastStep.step];
                }
        
                currentStep = pathHistory.length > 0 ? pathHistory[pathHistory.length - 1].step : 'start';
        
                const stepSection = document.getElementById('stepSection');
                const diceSection = document.getElementById('diceSection');
                const resultSection = document.getElementById('resultSection');
        
                stepSection.classList.remove('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.add('hidden');
                showStep(currentStep);
            }
        
            window.onload = resetFlow;
        </script>
  </template>

  <!-- 7. PBM -->
  <template id="tmpl-pbm">
    <!DOCTYPE html>
    <html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Japanese Erasmus Bot - PBM</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                background: #2e2e2e;
                min-height: 100vh;
                margin: 0;
                padding: 20px;
                box-sizing: border-box;
                color: #d8d8d8;
            }
        
            .impl-note {
                font-style: italic;
                font-size: 14px;
                color: #ffffff;
                line-height: 1.6;
                margin: 4px 0;
            }
        
            .container {
                max-width: 800px;
                margin: 0 auto;
                background: #3c3c3c;
                border-radius: 8px;
                padding: 20px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            }
        
            .header {
                text-align: center;
                margin-bottom: 20px;
                padding: 15px;
                background: #4a4a4a;
                border-radius: 8px;
                color: #ffffff;
                border: 1px solid #5c5c5c;
            }
        
            .header h1 {
                margin: 0;
                font-size: 2rem;
                font-weight: 700;
            }
        
            .header p {
                margin: 8px 0 0 0;
                font-size: 1rem;
                font-weight: 400;
            }
        
            .progress-bar {
                background: #4a4a4a;
                border-radius: 5px;
                height: 6px;
                margin-bottom: 20px;
                overflow: hidden;
                border: 1px solid #5c5c5c;
            }
        
            .progress-fill {
                background: #4682b4;
                height: 100%;
                border-radius: 5px;
                transition: width 0.3s ease;
                width: 0%;
            }
        
            .step-section {
                background: #3c3c3c;
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 15px;
                border: 1px solid #5c5c5c;
            }
        
            .step-header {
                display: flex;
                align-items: center;
                margin-bottom: 15px;
            }
        
            .step-number {
                background: #4682b4;
                color: #ffffff;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                font-size: 1rem;
                margin-right: 15px;
            }
        
            .step-title {
                font-size: 1.3rem;
                font-weight: 600;
                color: #d8d8d8;
                margin: 0;
            }
        
            .condition-box {
                background: #4a4a4a;
                border-left: 4px solid #4682b4;
                border-radius: 5px;
                padding: 15px;
                margin: 15px 0;
                font-size: 1rem;
                line-height: 1.5;
                color: #c8c8c8;
            }
        
            .condition-box strong {
                color: #4682b4;
                font-size: 1.1rem;
            }
        
            .button-group {
                display: flex;
                gap: 15px;
                justify-content: center;
                margin-top: 20px;
            }
        
            .btn {
                padding: 10px 30px;
                border: none;
                border-radius: 5px;
                font-size: 1rem;
                font-weight: 500;
                cursor: pointer;
                transition: background 0.2s ease, transform 0.1s ease;
                text-transform: uppercase;
                min-width: 100px;
                font-family: 'Georgia', 'Times New Roman', Times, serif;
            }
        
            .btn-yes {
                background: #2e8b57;
                color: #ffffff;
            }
        
            .btn-yes:hover {
                background: #257a4b;
                transform: translateY(-2px);
            }
        
            .btn-no {
                background: #696969;
                color: #ffffff;
            }
        
            .btn-no:hover {
                background: #585858;
                transform: translateY(-2px);
            }
        
            .btn-primary {
                background: #4682b4;
                color: #ffffff;
            }
        
            .btn-primary:hover {
                background: #3a6b9a;
                transform: translateY(-2px);
            }
        
            .btn-secondary {
                background: #5c5c5c;
                color: #ffffff;
            }
        
            .btn-secondary:hover {
                background: #4b4b4b;
                transform: translateY(-2px);
            }
        
            .btn-back {
                background: #5c5c5c;
                color: #ffffff;
            }
        
            .btn-back:hover {
                background: #4b4b4b;
                transform: translateY(-2px);
            }
        
            .path-history {
                background: #4a4a4a;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 15px;
                border-left: 3px solid #2e8b57;
            }
        
            .path-step {
                display: flex;
                align-items: center;
                margin: 8px 0;
                padding: 8px;
                background: #3c3c3c;
                border-radius: 5px;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            }
        
            .path-step .step-icon {
                width: 25px;
                height: 25px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                margin-right: 10px;
                font-size: 0.8rem;
            }
        
            .path-step.yes .step-icon {
                background: #2e8b57;
                color: #ffffff;
            }
        
            .path-step.no .step-icon {
                background: #696969;
                color: #ffffff;
            }
        
            .dice-section {
                background: #4a4a4a;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                margin: 15px 0;
                border: 1px solid #5c5c5c;
            }
        
            .dice-result {
                font-size: 3rem;
                font-weight: bold;
                color: #d8d8d8;
                margin: 15px 0;
            }
        
            .result-section {
                background: #2e8b57;
                color: #ffffff;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                margin-top: 15px;
                border: 1px solid #3c3c3c;
            }
        
            .result-section h2 {
                margin: 0 0 15px 0;
                font-size: 2rem;
                display: none;
            }
        
            .result-section p {
                margin: 10px 0;
                font-size: 32px;
                white-space: pre-line;
                font-weight: bold;
                font-style: italic;
            }
        
            .strategy-details {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 5px;
                padding: 15px;
                margin-top: 15px;
            }
        
            .strategy-list {
                text-align: left;
                margin: 15px 0;
                list-style: none;
                padding: 0;
            }
        
            .strategy-list li {
                margin: 8px 0;
                padding: 8px 10px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 5px;
                border-left: 3px solid rgba(255, 255, 255, 0.3);
            }
        
            .sub-priority-list {
                list-style: none;
                padding-left: 20px;
                margin-top: 5px;
            }
        
            .sub-priority-list li {
                margin: 5px 0;
                padding: 5px 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 5px;
                border-left: 2px solid rgba(255, 255, 255, 0.4);
                font-size: 0.9rem;
            }
        
            .hidden {
                display: none;
            }
        
            @media (max-width: 768px) {
                .container {
                    padding: 15px;
                    margin: 10px;
                }
                
                .header h1 {
                    font-size: 1.5rem;
                }
                
                .button-group {
                    flex-direction: column;
                    align-items: center;
                }
                
                .btn {
                    width: 100%;
                    max-width: 180px;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>PBM</h1>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div id="pathHistory" class="path-history hidden">
                <h4 style="margin-top: 0; color: #495057;">진행 경로</h4>
                <div id="pathSteps"></div>
            </div>

            <div id="stepSection" class="step-section">
                <div class="step-header">
                    <div class="step-number" id="stepNumber">1</div>
                    <h2 class="step-title" id="stepTitle">시작</h2>
                </div>
                
                <div class="condition-box" id="conditionBox">
                    첫 번째 조건을 확인해주세요.
                </div>
                
                <div class="button-group" id="buttonGroup">
                    <button class="btn btn-primary" onclick="startFlow()">시작하기</button>
                </div>
            </div>

            <div id="diceSection" class="dice-section hidden">
                <h3 style="margin: 0 0 20px 0; color: #2d3436;">Roll D10</h3>
                <div class="dice-result" id="diceResult">?</div>
                <div class="button-group">
                    <button class="btn btn-primary" onclick="rollDice()">Roll dice</button>
                </div>
            </div>

            <div id="resultSection" class="result-section hidden">
                <h2 id="strategyTitle">최종 병력 구성</h2>
                <p id="strategyName"></p>
                <div class="strategy-details" id="strategyDetails"></div>
                <div class="button-group" style="margin-top: 30px;">
                    <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                </div>
            </div>
        </div>

        <script>
            // Implementation notes
            const notes = {
                '[1]': '선택지가 있다면, 반격(Counteroffensive) 카드보다 먼저 JN-25 첩보(Intelligence) 카드를 사용합니다.',
                '[2]': '여러 적 유닛 중에서 선택해야 할 경우, 우선순위는 다음과 같습니다: 항모(CV) → 전함(BB) → 중순양함(CA) → 구축함(DD). 동일 유형일 경우 방어력이 가장 높은 유닛을 선택합니다.',
                '[3]': '여러 전투 헥스가 가능할 경우, 대응 전략의 우선순위 목록을 따라 전투 헥스를 선택합니다.',
                '[4]': '2스텝 손실을 가할 때도 [2]와 동일하게, CV → BB → CA → DD 순서로, 같은 유형 중에서는 방어력이 가장 높은 유닛을 선택합니다.',
                '[5]': '우선순위가 동일한 전투 헥스가 여러 개 있을 경우, 무작위로 순서를 결정합니다.',
                '[6]': '최우선 전투 헥스의 대응 병력 조건을 먼저 충족해야 하며, 그다음은 두 번째, 세 번째 순으로 충족합니다.',
                '[7]': '특정 전투 헥스 조건을 충족할 수 없을 경우, 다음 우선순위 전투 헥스로 건너뜁니다. 이 과정을 반복하다가 더 이상 대응할 전투 헥스가 없으면 종료합니다.',
                '[8]': '가용(Available)"이란 카드를 손에 보유하는 것 외에도, Erasmus가 해당 페이즈에서 최대 3장의 보너스 뽑기 제한을 아직 초과하지 않았다는 뜻입니다.',
                '[9]': '특정 전략에 PBM이 있다면, 이 표를 적용하기 전에 먼저 그것을 따릅니다.',
                '[10]': '우선순위 헥스가 모두 일본 AZOI에 이미 들어가 있는 경우, 그 우선순위는 건너뜁니다.',
                '[11]': '여러 공군 기지가 있을 경우, 여러 우선순위를 동시에 충족할 수 있는 기지를 우선적으로 선택합니다.',
                '[12]': '한 공군 기지에는 공중 유닛은 최대 1개만 배치할 수 있습니다.',
                '[13]': '가능한 공중 유닛 중에서는 가장 강력한 유닛을 선택합니다.',
                '[14]': '자원 헥스가 여러개인 경우, 가장 가까운 자원 헥스 → 두 번째로 가까운 자원 헥스 .. 순으로 선택합니다.',
                '[15]': '대응 카드에 보너스 뽑기가 적혀 있을 경우, 주사위 굴림에 -4를 적용합니다.'
            };

            // 병력 구성 정보 데이터
            const strategies = {
                'Air PBM Strategy': { 
                    name: '공중 PBM 전략', 
                    details: [
                        '다음 우선 순위에 따라 AZOI를 전개할 수 있는 공군 기지가 있는 헥스를 향해 PBM을 수행합니다 [9][10][11]<li>1. AZOI가 없는 일본 열도 밖 본부.</li><li>2. 연합군 본부[13]</li><li>3. 연합군 AZOI 내 일본군 항구</li><li>4. 연합군 AZOI 내 일본군 공군 기지</li><li>5. 연합군 AZOI 내 일본군 지상 유닛</li><li>6. 가장 가까운 자원 헥스(연합/일본군)[14]</li>'
                    ] 
                },
                'Naval PBM Strategy': { 
                    name: '해상 PBM 전략', 
                    details: [
                        '우선 순위에 따라 아군 항구가 있는 헥스를 향해 해상 유닛 PBM을 수행합니다:<li>1. 해상 유닛이 없고 범위 내에 있는 남해 본부.</li><li>2. 지상 유닛만 있는 항구</li><li>3. 가장 가까운 항구</li>'
                    ] 
                },
                'AA PBM Strategy': { 
                    name: 'AA 지상 PBM 전략', 
                    details: [
                        '우선 순위에 따라 아군 항구가 있는 헥스를 향해 지상 유닛 PBM을 수행합니다:<li>1. 해상 유닛이 있는 항구.</li><li>2. 가장 가까운 항구.</li>'
                    ] 
                }
            };

            // 하위 우선순위 목록 (필요 시 추가)
            const subPriorities = {};

            // 조건 정의
            const conditions = {
                'A': 'PBM을 수행할 공중 유닛이 있습니까?',
                'B': 'PBM을 수행할 해상 유닛이 있습니까?',
                'C': 'PBM에 실패한 AA 지상 유닛이 있습니까?'
            };

            let currentStep = 'start';
            let pathHistory = [];
            let stepCount = 0;
            let evaluatedConditions = {};

            function startFlow() {
                currentStep = 'A';
                stepCount = 1;
                pathHistory = [];
                evaluatedConditions = {};
                showStep('A');
            }

            function showStep(stepId) {
                const stepSection = document.getElementById('stepSection');
                const stepNumber = document.getElementById('stepNumber');
                const stepTitle = document.getElementById('stepTitle');
                const conditionBox = document.getElementById('conditionBox');
                const buttonGroup = document.getElementById('buttonGroup');
                const diceSection = document.getElementById('diceSection');
                const resultSection = document.getElementById('resultSection');
                const progressFill = document.getElementById('progressFill');
                const pathHistoryDiv = document.getElementById('pathHistory');
                const pathStepsDiv = document.getElementById('pathSteps');

                if (!stepSection || !stepNumber || !stepTitle || !conditionBox || !buttonGroup || !diceSection || !resultSection || !progressFill || !pathHistoryDiv || !pathStepsDiv) {
                    console.error('Show step elements are missing:', { stepSection, stepNumber, stepTitle, conditionBox, buttonGroup, diceSection, resultSection, progressFill, pathHistoryDiv, pathStepsDiv });
                    const missingElements = [];
                    if (!stepSection) missingElements.push('stepSection');
                    if (!stepNumber) missingElements.push('stepNumber');
                    if (!stepTitle) missingElements.push('stepTitle');
                    if (!conditionBox) missingElements.push('conditionBox');
                    if (!buttonGroup) missingElements.push('buttonGroup');
                    if (!diceSection) missingElements.push('diceSection');
                    if (!resultSection) missingElements.push('resultSection');
                    if (!progressFill) missingElements.push('progressFill');
                    if (!pathHistoryDiv) missingElements.push('pathHistoryDiv');
                    if (!pathStepsDiv) missingElements.push('pathStepsDiv');
                    console.error('Missing element IDs:', missingElements);
                    alert('페이지에 필요한 요소가 누락되었습니다. HTML을 확인해 주세요. 누락된 ID: ' + missingElements.join(', '));
                    return;
                }

                stepSection.classList.remove('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.add('hidden');

                stepNumber.textContent = stepCount;

                if (stepId === 'DICE') {
                    stepSection.classList.add('hidden');
                    diceSection.classList.remove('hidden');
                    const diceResult = document.getElementById('diceResult');
                    if (diceResult) diceResult.textContent = '?';
                    return;
                }

                if (conditions[stepId]) {
                    stepTitle.textContent = `${stepId} 확인`;
                    conditionBox.innerHTML = `${conditions[stepId]}`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-yes" onclick="selectChoice('${stepId}', true)">YES</button>
                        <button class="btn btn-no" onclick="selectChoice('${stepId}', false)">NO</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                } else if (stepId === 'start') {
                    stepTitle.textContent = '시작';
                    conditionBox.innerHTML = `PBM 결정 시작`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-primary" onclick="startFlow()">시작하기</button>
                    `;
                } else if (stepId === 'End') {
                    stepTitle.textContent = '종료';
                    conditionBox.innerHTML = `PBM 프로세스가 완료되었습니다.`;
                    buttonGroup.innerHTML = `
                        <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                        ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                    `;
                }

                updateProgress();
                updatePathHistory();
            }

            function selectChoice(conditionId, choice) {
                evaluatedConditions[conditionId] = choice;
                pathHistory.push({ step: conditionId, choice: choice, stepNum: stepCount });
                stepCount++;

                const nextStep = getNextStep(conditionId, choice);

                if (nextStep.startsWith('STRATEGY_')) {
                    const strategy = nextStep.replace('STRATEGY_', '');
                    showResult(strategy);
                } else {
                    currentStep = nextStep;
                    showStep(nextStep);
                }
            }

            function getNextStep(conditionId, choice) {
                switch (conditionId) {
                    case 'A':
                        return choice ? 'STRATEGY_Air PBM Strategy' : 'B';
                    case 'B':
                        return choice ? 'STRATEGY_Naval PBM Strategy' : 'C';
                    case 'C':
                        return choice ? 'STRATEGY_AA PBM Strategy' : 'End';
                    default:
                        return 'start';
                }
            }

            function rollDice() {
                const diceSection = document.getElementById('diceSection');
                const diceResult = document.getElementById('diceResult');
                if (!diceSection || !diceResult) {
                    console.error('Dice section or result element is missing:', { diceSection, diceResult });
                    const missingElements = [];
                    if (!diceSection) missingElements.push('diceSection');
                    if (!diceResult) missingElements.push('diceResult');
                    console.error('Missing element IDs:', missingElements);
                    alert('페이지에 필요한 요소가 누락되었습니다. HTML을 확인해 주세요. 누락된 ID: ' + missingElements.join(', '));
                    return;
                }

                const diceValue = Math.floor(Math.random() * 10); // 0-9
                diceResult.textContent = diceValue;

                let nextStep;
                if (diceValue === 0) {
                    nextStep = 'STRATEGY_Air PBM Strategy';
                } else {
                    nextStep = 'B';
                }

                pathHistory.push({
                    step: 'DICE',
                    choice: diceValue,
                    stepNum: stepCount,
                    isResult: true,
                    result: nextStep.replace('STRATEGY_', '')
                });

                setTimeout(() => {
                    if (nextStep.startsWith('STRATEGY_')) {
                        showResult(nextStep.replace('STRATEGY_', ''));
                    } else {
                        currentStep = nextStep;
                        showStep(nextStep);
                    }
                }, 1000);
            }

            function showResult(strategyKey) {
                const resultSection = document.getElementById('resultSection');
                const strategyTitle = document.getElementById('strategyTitle');
                const strategyName = document.getElementById('strategyName');
                const strategyDetails = document.getElementById('strategyDetails');
                const buttonGroup = resultSection ? resultSection.querySelector('.button-group') : null;

                if (!resultSection || !strategyTitle || !strategyName || !strategyDetails || !buttonGroup) {
                    console.error('Result section elements are missing:', { resultSection, strategyTitle, strategyName, strategyDetails, buttonGroup });
                    const missingElements = [];
                    if (!resultSection) missingElements.push('resultSection');
                    if (!strategyTitle) missingElements.push('strategyTitle');
                    if (!strategyName) missingElements.push('strategyName');
                    if (!strategyDetails) missingElements.push('strategyDetails');
                    if (!buttonGroup) missingElements.push('buttonGroup');
                    console.error('Missing element IDs:', missingElements);
                    alert('페이지에 필요한 요소가 누락되었습니다. HTML을 확인해 주세요. 누락된 ID: ' + missingElements.join(', '));
                    return;
                }

                const strategy = strategies[strategyKey];
                if (!strategy) {
                    console.error('Strategy not found:', strategyKey);
                    alert('해당 전략을 찾을 수 없습니다. Retry해주세요.');
                    return;
                }

                stepSection.classList.add('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.remove('hidden');
                strategyTitle.textContent = 'PBM 전략';
                strategyName.textContent = strategy.name;

                // 주석 추출을 위한 정규 표현식
                const annotationRegex = /\[\d+\]/g;
                const annotations = new Set();

                // strategy.name에서 주석 추출
                if (strategy.name.match(annotationRegex)) {
                    strategy.name.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                }

                // strategy.details에서 주석 추출
                strategy.details.forEach(detail => {
                    if (detail.match(annotationRegex)) {
                        detail.match(annotationRegex).forEach(annotation => annotations.add(annotation));
                    }
                });

                strategyDetails.innerHTML = `
                    <h4 style="margin-top: 0; color: #fff;">세부사항:</h4>
                    <ul class="strategy-list">
                        ${strategy.details.map(detail => `
                            <li>
                                ${detail}
                                ${subPriorities[detail] ? `
                                    <ul class="sub-priority-list">
                                        ${subPriorities[detail].map(sub => `<li>${sub}</li>`).join('')}
                                    </ul>
                                ` : ''}
                            </li>
                        `).join('')}
                    </ul>
                    ${annotations.size > 0 ? `
                        <h4 style="margin-top: 20px; color: #fff;">주석:</h4>
                        <ul class="strategy-list">
                            ${Array.from(annotations).sort().map(annotation => `
                                <li class="impl-note">${annotation}: ${notes[annotation]}</li>
                            `).join('')}
                        </ul>
                    ` : ''}
                `;
                buttonGroup.innerHTML = `
                    <button class="btn btn-primary" onclick="startFlow()">계속</button>
                    <button class="btn btn-secondary" onclick="resetFlow()">Retry</button>
                    ${pathHistory.length > 0 ? '<button class="btn btn-back" onclick="goBack()">이전</button>' : ''}
                `;

                updateProgress();
                updatePathHistory();
            }

            function updateProgress() {
                const progressFill = document.getElementById('progressFill');
                if (progressFill) {
                    const totalSteps = 3; // A, B, C 조건에 기반
                    const progress = Math.min((stepCount / totalSteps) * 100, 100);
                    progressFill.style.width = progress + '%';
                }
            }

            function updatePathHistory() {
                const pathHistoryDiv = document.getElementById('pathHistory');
                const pathStepsDiv = document.getElementById('pathSteps');
                if (!pathHistoryDiv || !pathStepsDiv) {
                    console.error('Path history elements are missing:', { pathHistoryDiv, pathStepsDiv });
                    const missingElements = [];
                    if (!pathHistoryDiv) missingElements.push('pathHistoryDiv');
                    if (!pathStepsDiv) missingElements.push('pathStepsDiv');
                    console.error('Missing element IDs:', missingElements);
                    alert('페이지에 필요한 요소가 누락되었습니다. HTML을 확인해 주세요. 누락된 ID: ' + missingElements.join(', '));
                    return;
                }

                if (pathHistory.length === 0) {
                    pathHistoryDiv.classList.add('hidden');
                    return;
                }

                pathStepsDiv.innerHTML = '';

                pathHistory.forEach(step => {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = `path-step ${step.choice && step.step !== 'DICE' ? 'yes' : step.step !== 'DICE' ? 'no' : ''}`;

                    if (step.step === 'DICE') {
                        stepDiv.innerHTML = `
                            <div class="step-icon">${step.choice}</div>
                            <div>
                                <strong>Roll dice:</strong> ${step.choice} 
                                ${step.result ? `→ ${strategies[step.result].name}` : ''}
                            </div>
                        `;
                    } else if (step.choice === 'success' || step.choice === 'failure') {
                        stepDiv.innerHTML = `
                            <div class="step-icon">${step.choice === 'success' ? 'S' : 'F'}</div>
                            <div>
                                <strong>${step.step}:</strong> 
                                ${conditions[step.step] || step.step} → ${step.choice === 'success' ? '성공' : '실패'}
                            </div>
                        `;
                    } else {
                        let conditionText = conditions[step.step] || step.step;
                        stepDiv.innerHTML = `
                            <div class="step-icon">${step.choice ? 'Y' : 'N'}</div>
                            <div>
                                <strong>${step.step}:</strong> 
                                ${conditionText} → ${step.choice ? 'YES' : 'NO'}
                            </div>
                        `;
                    }

                    pathStepsDiv.appendChild(stepDiv);
                });

                pathHistoryDiv.classList.remove('hidden');
            }

            function resetFlow() {
                const stepSection = document.getElementById('stepSection');
                const diceSection = document.getElementById('diceSection');
                const resultSection = document.getElementById('resultSection');
                const pathHistoryDiv = document.getElementById('pathHistory');
                const stepNumber = document.getElementById('stepNumber');
                const stepTitle = document.getElementById('stepTitle');
                const conditionBox = document.getElementById('conditionBox');
                const buttonGroup = document.getElementById('buttonGroup');
                const progressFill = document.getElementById('progressFill');

                if (!stepSection || !diceSection || !resultSection || !pathHistoryDiv || !stepNumber || !stepTitle || !conditionBox || !buttonGroup || !progressFill) {
                    console.error('Reset flow elements are missing:', {
                        stepSection, diceSection, resultSection, pathHistoryDiv, stepNumber, stepTitle, conditionBox, buttonGroup, progressFill
                    });
                    const missingElements = [];
                    if (!stepSection) missingElements.push('stepSection');
                    if (!diceSection) missingElements.push('diceSection');
                    if (!resultSection) missingElements.push('resultSection');
                    if (!pathHistoryDiv) missingElements.push('pathHistoryDiv');
                    if (!stepNumber) missingElements.push('stepNumber');
                    if (!stepTitle) missingElements.push('stepTitle');
                    if (!conditionBox) missingElements.push('conditionBox');
                    if (!buttonGroup) missingElements.push('buttonGroup');
                    if (!progressFill) missingElements.push('progressFill');
                    console.error('Missing element IDs:', missingElements);
                    alert('페이지에 필요한 요소가 누락되었습니다. HTML을 확인해 주세요. 누락된 ID: ' + missingElements.join(', '));
                    return;
                }

                currentStep = 'start';
                stepCount = 0;
                pathHistory = [];
                evaluatedConditions = {};

                stepSection.classList.remove('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.add('hidden');
                pathHistoryDiv.classList.add('hidden');
                stepNumber.textContent = '1';
                stepTitle.textContent = '시작';
                conditionBox.innerHTML = 'PBM을 수행할 유닛을 결정합니다';
                buttonGroup.innerHTML = '<button class="btn btn-primary" onclick="startFlow()">시작하기</button>';
                progressFill.style.width = '0%';
            }

            function goBack() {
                if (pathHistory.length === 0) return;

                const lastStep = pathHistory.pop();
                stepCount--;

                if (lastStep.step !== 'DICE') {
                    delete evaluatedConditions[lastStep.step];
                }

                currentStep = pathHistory.length > 0 ? pathHistory[pathHistory.length - 1].step : 'start';

                const stepSection = document.getElementById('stepSection');
                const diceSection = document.getElementById('diceSection');
                const resultSection = document.getElementById('resultSection');
                if (!stepSection || !diceSection || !resultSection) {
                    console.error('Go back elements are missing:', { stepSection, diceSection, resultSection });
                    const missingElements = [];
                    if (!stepSection) missingElements.push('stepSection');
                    if (!diceSection) missingElements.push('diceSection');
                    if (!resultSection) missingElements.push('resultSection');
                    console.error('Missing element IDs:', missingElements);
                    alert('페이지에 필요한 요소가 누락되었습니다. HTML을 확인해 주세요. 누락된 ID: ' + missingElements.join(', '));
                    return;
                }

                stepSection.classList.remove('hidden');
                diceSection.classList.add('hidden');
                resultSection.classList.add('hidden');
                showStep(currentStep);
            }

            // DOM이 완전히 로드된 후 실행
            document.addEventListener('DOMContentLoaded', () => {
                window.onload = resetFlow;
            });
        </script>
  </template>

  <script>
    // 템플릿 내용을 각 iframe의 srcdoc으로 주입 (한 파일 내에 모두 포함)
    const map = {
      early: { frame: 'frame-early', tmpl: 'tmpl-early' },
      mid:   { frame: 'frame-mid',   tmpl: 'tmpl-mid' },
      late:  { frame: 'frame-late',  tmpl: 'tmpl-late' },
      card:  { frame: 'frame-card',  tmpl: 'tmpl-card' },
      task:  { frame: 'frame-task',  tmpl: 'tmpl-task' },
      resp:  { frame: 'frame-resp',  tmpl: 'tmpl-resp' },
      pbm:   { frame: 'frame-pbm',   tmpl: 'tmpl-pbm' },
    };

    // 최초 1회: 모든 페이지를 미리 로드(상태 유지 목적). 필요 없으면 첫 탭만 로드해도 됨.
    Object.keys(map).forEach(key => {
      const f = document.getElementById(map[key].frame);
      const t = document.getElementById(map[key].tmpl);
      if (f && t) f.srcdoc = t.innerHTML;
    });

    // 탭 전환
    const tabs = document.getElementById('tabs');
    tabs.addEventListener('click', (e) => {
      if (e.target.tagName !== 'BUTTON') return;
      const target = e.target.getAttribute('data-target');
      if (!target || !map[target]) return;

      // 버튼 active
      tabs.querySelectorAll('button').forEach(b => b.classList.remove('active'));
      e.target.classList.add('active');

      // 프레임 전환
      document.querySelectorAll('.frame').forEach(f => f.classList.remove('active'));
      document.getElementById(map[target].frame).classList.add('active');
    });
  </script>
</body>
</html>
