<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wargaming Oracle</title>
<style>
  :root{
    --bg:#071226; --card:#0b1622; --accent:#1f6feb; --muted:#9fb0c8;
    --glass: rgba(255,255,255,0.03); --ok:#10b981; --danger:#ef4444;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: "Noto Sans KR", Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: linear-gradient(180deg,#061027 0%, #071226 100%); color:#e8f0fb; padding:28px;
  }
  header{display:flex;justify-content:space-between;align-items:flex-start;gap:6px;margin-bottom:18px}
  h1{font-size:20px;margin:0}
  p.lead{margin:0;color:var(--muted);font-size:13px}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:16px}
  .card{background:var(--card); padding:14px; border-radius:12px; border:1px solid rgba(255,255,255,0.03); box-shadow: 0 8px 24px rgba(2,6,23,0.6)}
  .card h3{margin:0 0 8px 0;font-size:15px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{background:var(--accent);color:white;border:0;padding:8px 10px;border-radius:10px;cursor:pointer;font-weight:600}
  .btn.small{padding:6px 8px;font-size:13px}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
  .row{display:flex;align-items:center;justify-content:space-between;margin:8px 0;padding:6px;border-radius:8px;background:rgba(255,255,255,0.01)}
  .label{color:var(--muted);font-size:14px;flex:1}
  .value{min-width:180px;text-align:center;padding:6px 8px;border-radius:8px;background:var(--glass);font-weight:700}
  .value.val-0{color:var(--muted);font-weight:600}
  .value.good{color:var(--ok);background:rgba(16,185,129,0.06)}
  .value.bad{color:var(--danger);background:rgba(239,68,68,0.06)}
  .hint{font-size:12px;color:var(--muted);margin-top:8px}
  footer{margin-top:18px;color:var(--muted);font-size:13px}
  .flex{display:flex;gap:8px;align-items:center}
  .guideline-link{display:flex;gap:6px;align-items:center;color:var(--muted);font-size:14px;cursor:pointer}
  .guideline-link:hover{color:var(--accent)}
  .modal-content h3{font-size:20px;margin:0 0 12px;line-height:1.5;color:#e8f0fb}
  .modal-content ul{margin:12px 0;padding-left:24px}
  .modal-content li{font-size:15px;margin-bottom:8px;line-height:1.6;color:#e8f0fb}
  .modal-content ul ul{padding-left:32px}
  .modal-content ul ul li{font-size:14px;line-height:1.6}
  .modal-content strong{color:var(--accent);font-weight:700}
  .modal-close{position:absolute;top:12px;right:12px;color:var(--muted);font-size:18px;cursor:pointer;padding:8px}
  .modal-close:hover{color:var(--accent);transform:scale(1.2)}
  @media (max-width:560px){
    .value{min-width:120px}
    .modal-content h3{font-size:18px}
    .modal-content li{font-size:14px}
    .modal-content ul ul li{font-size:13px}
    #guideline-modal{padding:16px;max-width:95%}
  }
</style>
</head>
<body>
<header>
  <div>
    <h1>Wargaming Oracle</h1>
    <p class="lead">혼자서 워게임 2인플을 할 때 가상 플레이어(봇)의 성격과 행동을 정의하는데 도움을 주는 매트릭스입니다.</p>
    <p class="lead">우선 기본 성격 설정 버튼을 눌러 봇 플레이어의 기본 성격을 설정합니다.</p>
    <p class="lead">게임 중 봇 플레이어의 행동을 결정해야할 때마다, 전술 매트릭스를 참고하여 봇 행동을 결정합니다.</p>
    <p class="lead">성격을 뽑으면(또는 수동으로 바꾸면) 자동 규칙에 따라 상황·전술이 도출됩니다. 개별 클릭으로 재설정도 가능합니다。</p>
  </div>
  <div class="guideline-link" id="guideline-link">
    <span>?</span>
    <span>가이드라인</span>
  </div>
</header>

<section class="grid">
  <div class="card">
    <h3>기본 성격 매트릭스</h3>
    <div class="controls" style="justify-content:space-between;margin-bottom:10px">
      <div style="display:flex;gap:8px;align-items:center">
        <button id="seed-personality" class="btn small">기본 성격 설정</button>
        <button id="reset-personality" class="btn small ghost">초기화</button>
        <label style="display:flex;align-items:center;gap:6px;color:var(--muted);font-size:13px">
          <input type="checkbox" id="auto-select" checked /> 성격 기반 자동 선택
        </label>
      </div>
      <div style="font-size:13px;color:var(--muted)">7단계: 거의 확실 → 가능성 전무</div>
    </div>
    <div id="personality-list"></div>
  </div>

  <div class="card">
    <h3>상황 별 매트릭스</h3>
    <div class="controls" style="margin-bottom:8px;justify-content:space-between">
      <div>
        <button id="randomize-all-situations" class="btn small">상황 생성</button>
        <button id="reset-situations" class="btn small ghost">초기화</button>
      </div>
      <div style="color:var(--muted);font-size:13px">항목 클릭 = 해당 항목 재굴림</div>
    </div>
    <div id="situations-list"></div>
    <p class="hint">상황은 성격의 가중치 합산으로 결정됩니다。</p>
  </div>

  <div class="card">
    <h3>전술 매트릭스</h3>
    <div class="controls" style="margin-bottom:8px;justify-content:space-between">
      <div>
        <button id="randomize-all-tactics" class="btn small">전술 생성</button>
        <button id="reset-tactics" class="btn small ghost">초기화</button>
      </div>
      <div style="color:var(--muted);font-size:13px">전술 항목 클릭 = 해당 항목 재굴림</div>
    </div>
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
      <label style="color:var(--muted);font-size:13px">가중치 강도: </label>
      <input type="range" id="weight-scale" min="0" max="2" step="0.1" value="1" style="width:150px">
      <span id="weight-scale-value" style="color:var(--muted);font-size:13px">1.0</span>
    </div>
    <div id="tactics-list"></div>
    <p class="hint">전술 자동화는 상황 + 성격에 기반한 가중치 규칙을 따릅니다. 가중치 강도를 조절하여 영향을 제어할 수 있습니다。</p>
    <p class="hint">전술 판단이 필요할 때마다, 전술 생성 버튼을 눌러 전술을 선택합니다。</p>
    <p class="hint">25%의 확률로 상황이 바뀌어 오라클의 성격/상황/전술이 바뀔 수 있습니다！</p>
  </div>
</section>

<div class="card" style="margin-top:16px">
  <h3>기본 질문 매트릭스</h3>
  <div style="display:flex;gap:8px;align-items:center">
    <button id="custom-question" class="btn small">커스텀 질문</button>
    <div id="custom-result" class="value val-0">-</div>
    <div style="color:var(--muted);font-size:13px">(1/7 × 1/6 확률)</div>
  </div>
</div>

<footer>
  테이블에 포함되지 않은 판단이 필요한 경우, 커스텀 질문으로 Y/N을 판단할 수 있습니다。
</footer>

<div id="guideline-modal" style="
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(15, 30, 50, 0.98);
  color: #e8f0fb;
  padding: 24px;
  border-radius: 12px;
  border: 1px solid #1f6feb33;
  box-shadow: 0 0 20px #1f6feb99;
  font-weight: 700;
  font-size: 16px;
  display: none;
  z-index: 1000;
  text-align: left;
  max-width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  white-space: normal;
">
  <span class="modal-close" id="guideline-close">✕</span>
  <div class="modal-content">
    <h3>기본 가이드라인</h3>
    <ul>
      <li>목표 선정
        <ul>
          <li>봇은 자신보다 <strong>전력이 약하거나 승산이 있는 상대</strong>를 우선적으로 공격한다.</li>
          <li>압도적으로 강한 상대에게는 불필요한 공격을 하지 않는다.</li>
          <li>인접하거나 공격 가능 범위 내 적이 없다면 적과 인접하는 방향으로 이동한다.</li>
        </ul>
      </li>
      <li>공격 병력 결정
        <ul>
          <li>투입할 유닛(스텝) 수는 <strong>전술 매트릭스의 집중 데이터</strong>를 참고하여 결정한다.</li>
        </ul>
      </li>
    </ul>
    <h3>공격 전술 행동 지침</h3>
    <ul>
      <li><strong>자살 공격:</strong> 전멸을 각오하고 공격을 수행한다(대상: 인접하거나 공격 범위 내 있는 가장 강한 적 병력)</li>
      <li><strong>모든 방향:</strong> 가능한 모든 방향으로 공격을 수행한다(예시: 인접한 모든 헥스로 공격 수행)</li>
      <li><strong>여러 방향/단일 방향:</strong> 여러 방향을 공격하거나 한쪽 방향으로 공격을 수행</li>
      <li><strong>국지전:</strong> 적 전선 밖에 있는 단일 유닛을 대상으로 공격을 수행</li>
      <li><strong>소규모 정찰:</strong> 정찰 목적으로 이동 후, 소규모 교전을 수행</li>
      <li><strong>공격 포기:</strong> 공격을 포기한다.</li>
    </ul>
    <h3>방어 전술 행동 지침</h3>
    <ul>
      <li><strong>결사항전:</strong> 후퇴하지 않고 해당 지점을 무조건 사수.</li>
      <li><strong>광범위 방어:</strong> 형성된 전선 전체를 모두 방어</li>
      <li><strong>핵심 요충지만:</strong> 주요 도시 또는 목 지점을 방어</li>
      <li><strong>선별적 방어:</strong> 일부 지점만 방어</li>
      <li><strong>필요한 경우만:</strong> 필요 없다고 판단되는 경우 방어 포기 가능</li>
      <li><strong>시간 벌기:</strong> 일부 병력을 남겨 놓고 주 병력은 후퇴 가능</li>
      <li><strong>후퇴:</strong> 후퇴</li>
    </ul>
  </div>
</div>

<div id="plot-twist-modal" style="
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(15, 30, 50, 0.95);
  color: white;
  padding: 16px 24px;
  border-radius: 12px;
  box-shadow: 0 0 15px #1f6febcc;
  font-weight: 700;
  font-size: 16px;
  display: none;
  z-index: 1000;
  text-align: center;
  max-width: 80%;
  white-space: pre-line;
">
  <div id="plot-twist-title" style="font-size: 24px; font-weight: 900; margin-bottom: 8px;">상황이 바뀌었습니다!</div>
  <div id="plot-twist-message" style="font-size: 18px; margin-bottom: 6px;"></div>
  <div id="plot-twist-flavor" style="font-size: 14px; font-style: italic; color: #a0b9e9;"></div>
</div>

<footer style="
  text-align: center;
  padding: 12px 0;
  font-size: 14px;
  color: #666;
  border-top: 1px solid #ccc;
  margin-top: 40px;
  font-family: Arial, sans-serif;
">
  Based on Daniel's Wargaming Oracle
</footer>

<script>
/* 상수 & 데이터 */
const COMMON_7 = [
  "거의 확실","매우 가능성 높음","가능성 높음","50/50","가능성 낮음","매우 가능성 낮음","가능성 전무"
];

const situationScale = {
  "거의 확실": 7,
  "매우 가능성 높음": 6,
  "가능성 높음": 5,
  "50/50": 4,
  "가능성 낮음": 3,
  "매우 가능성 낮음": 2,
  "가능성 전무": 1
};

const personalityKeys = [
  "인내심","용기","공격성","유연성","손실 감내력","임무 확대"
];

const situationKeys = [
  "시간이 내 편인가?",
  "본부 병력을 보호해야 하는가?",
  "방어보다 공격이 더 나은가?",
  "화력보다 기동이 더 나은가?",
  "병력 보호를 우선해야 하는가?",
  "간접적인 전략을 선호하는가?",
  "승리할 수 있는 방법이 하나 이상인가?"
];

const plotTwistOptions = [
  "모든 성격을 재설정합니다",
  "성격 2개를 재설정합니다",
  "상황 또는 성격 1개를 재설정합니다",
  "상황 1개를 재설정합니다",
  "상황 2개를 재설정합니다",
  "모든 상황을 재설정합니다",
  "전술 하나를 예상 밖으로 변경합니다"
];

const plotTwistFlavorTexts = {
  "모든 성격을 재설정합니다": [
    "적 지휘관이 경질되었습니다. 적의 작전 계획에 큰 변화가 있을 것으로 보입니다。",
    "정찰 결과 적의 동향이 심상치 않습니다… 새로운 지휘부가 나타난 듯합니다。",
    "예상치 못한 내부 혼란이 발생했습니다. 전술적 불확실성이 커졌습니다。",
    "적군의 핵심 지휘관이 교체되었습니다. 전력 재편성 중일 가능성이 높습니다。",
    "전선 전체에 걸쳐 적군의 태도가 급변했습니다. 대처가 필요합니다。",
    "외부 요인으로 적군 성격이 전면 재조정되었습니다. 대비를 서두르십시오。",
    "새로운 정보에 따르면 적군이 작전 방향을 전면 재검토 중입니다。",
    "예상 밖의 지도부 교체로 적의 대응 양상이 바뀌고 있습니다。",
    "지휘 체계가 흔들리는 중입니다. 적군의 행동이 불규칙해질 수 있습니다。",
    "내부 소요와 혼란으로 적의 전술 성향이 일시적으로 리셋되었습니다"
  ],
  "성격 2개를 재설정합니다": [
    "적의 두 핵심 성향이 갑작스럽게 변화했습니다。",
    "적 지휘부 내 두 주요 지표가 불안정해졌습니다。",
    "적군 핵심 기조 중, 두가지 요소가 새롭게 재조정되었습니다。",
    "두 가지 핵심 성향이 예기치 않게 바뀌어 대응이 필요합니다。",
    "내부 갈등으로 적의 2가지 성격이 바뀌었습니다. 전술 재검토를 권장합니다。",
    "적의 두 주요 전술적 성향이 흔들리고 있습니다。",
    "중요한 두가지 성격 요소가 변동하여 적 대응에 혼란이 예상됩니다。",
    "예상 외 두 핵심 성향의 변화가 포착되었습니다。",
    "적군의 작전 특성이 두 곳에서 급격히 변하고 있습니다。",
    "성격 재설정으로 적군 전술이 부분적으로 리셋되었습니다"
  ],
  "상황 또는 성격 1개를 재설정합니다": [
    "적의 한 가지 전술적 상황이 변동되었습니다。",
    "전선 상황 중 한 요소가 갑자기 바뀌었습니다。",
    "적군 한 가지 성격 지표가 재설정되었습니다。",
    "상황 또는 성격 한 축의 변화가 감지되었습니다。",
    "작은 변화지만 작전 전개에 영향을 줄 수 있습니다。",
    "전술 불확실성을 높이는 단기 변동이 발생했습니다。",
    "적의 한 부분에서 예기치 않은 변화가 일어났습니다。",
    "전략적 한 축의 변화가 현장에 전달되고 있습니다。",
    "전술 요소 하나가 리셋되어 대응이 필요합니다。",
    "상황 혹은 성격의 작은 변화가 전황에 영향을 미칠 수 있습니다"
  ],
  "상황 1개를 재설정합니다": [
    "전선의 한 상황 지표가 급변했습니다。",
    "중요한 전술 상황 중 하나가 재설정되었습니다。",
    "전투 환경이 갑자기 바뀌어 혼란이 예상됩니다。",
    "한 가지 상황 변화가 전황에 영향을 줍니다。",
    "적의 대응 전략 일부가 바뀌었습니다。",
    "국지적 상황 변동이 포착되었습니다。",
    "전술적 환경 중 한 요소가 새롭게 형성되고 있습니다。",
    "주요 상황 하나가 리셋되어 대응이 요구됩니다。",
    "전선 상황 중 한 축에 급격한 변화가 일어났습니다。",
    "현장 상황이 부분적으로 재조정되고 있습니다"
  ],
  "상황 2개를 재설정합니다": [
    "전선 두 상황 지표가 동시에 변화했습니다。",
    "중대한 국지 상황 두 곳이 재설정되었습니다。",
    "전술 환경에 큰 변화가 동시에 발생하고 있습니다。",
    "두 개 상황의 변동으로 전황이 요동치고 있습니다。",
    "국지적 혼란이 두 지역에서 동시 발생했습니다。",
    "두 가지 전술적 상황이 동시 재설정되어 긴장이 고조됩니다。",
    "적의 두 주요 상황 지표가 흔들리고 있습니다。",
    "두 전술 축이 예기치 않게 변경되었습니다。",
    "전투 환경이 두 부분에서 급격히 변했습니다。",
    "다중 상황 변화로 대응 방안 재수립이 필요합니다"
  ],
  "모든 상황을 재설정합니다": [
    "전선 전반의 상황이 전면 재조정되었습니다。",
    "적의 작전 환경이 완전히 변동되어 혼란이 가중되고 있습니다。",
    "전술적 상황 전체가 다시 평가되고 있습니다。",
    "전선 상황 전반에 걸쳐 큰 변화가 발생했습니다。",
    "적군 전술 상황이 리셋되어 대처가 어렵습니다。",
    "상황 재설정으로 전투 흐름에 급격한 변화가 일어났습니다。",
    "국지적 상황들이 전면 재편성되고 있습니다。",
    "모든 상황 지표가 불확실성 상태로 바뀌었습니다。",
    "전술 환경 전반에 걸쳐 새로운 국면이 열렸습니다。",
    "전선 상황 전체가 다시 수립되고 있습니다"
  ],
  "전술 하나를 예상 밖으로 변경합니다": [
    "적의 전술이 예기치 않게 변경되었습니다!",
    "전선에서 예상 밖의 전술적 변동이 발생했습니다。",
    "적군이 예상치 못한 전술을 채택했습니다。"
  ]
};

const tacticsMeta = {
  "공격": ["자살 공격","모든 방향","여러 방향","단일 방향","국지전","소규모 정찰","공격 포기"],
  "방어": ["결사항전","광범위 방어","핵심 요충지만","선별적 방어","필요한 경우만","시간 벌기","후퇴"],
  "방법": ["기습 승리","돌파","포위","측면","전방","제파 공격","방향 전환"],
  "강도": ["거의 없음 (0%)","최소 (10%)","부족 (30%)","평균 (50%)","풍부 (70%)","최대 (90%)","전부 (100%)"],
  "방향": ["모든 방향","좌측 측면","우측 측면","중앙/전방","후방","측면/중앙","매우 좁음"],
  "집중": ["거대 스택","큰 스택","가능한 많은 스택","중간 스택","얇은 스택","거의 없는 스택","스택 없음"]
};

const questionMatrix = [
  ["아니야","맞아. 하지만...","맞아","맞아. 그리고...","맞아. 그리고...","맞아. 그리고..."],
  ["아니야. 하지만...","맞아. 하지만...","맞아. 하지만...","맞아","맞아. 하지만...","맞아. 하지만..."],
  ["아니야. 그리고...","아니야. 하지만...","맞아","맞아. 하지만...","맞아. 하지만...","맞아"],
  ["아니야. 그리고...","아니야","맞아. 하지만...","맞아","맞아 아니야.","하지만..."],
  ["아니야. 그리고...","아니야. 그리고...","아니야","아니야. 하지만...","맞아","아니야. 하지만..."],
  ["아니야. 그리고...","아니야. 그리고...","아니야. 그리고...","아니야","아니야. 하지만...","아니야"],
  ["아니야. 그리고...","아니야. 그리고...","아니야. 그리고...","아니야. 그리고...","아니야. 하지만...","아니야. 하지만..."]
];

const stageScore = {
  "거의 확실": 3,
  "매우 가능성 높음": 2,
  "가능성 높음": 1,
  "50/50": 0,
  "가능성 낮음": -1,
  "매우 가능성 낮음": -2,
  "가능성 전무": -3
};

const personalityToSituations = {
  "인내심": ["시간이 내 편인가?", "병력 보호를 우선해야 하는가?", "간접적인 전략을 선호하는가?"],
  "용기": ["방어보다 공격이 더 나은가?", "승리할 수 있는 방법이 하나 이상인가?"],
  "공격성": ["방어보다 공격이 더 나은가?", "화력보다 기동이 더 나은가?"],
  "유연성": ["간접적인 전략을 선호하는가?", "승리할 수 있는 방법이 하나 이상인가?"],
  "손실 감내력": ["병력 보호를 우선해야 하는가?", "화력보다 기동이 더 나은가?", "본부 병력을 보호해야 하는가?"],
  "임무 확대": ["시간이 내 편인가?", "승리할 수 있는 방법이 하나 이상인가?"]
};

const tacticInfluence = {
  "공격": [
    {type: 'situation', key: "방어보다 공격이 더 나은가?", highWeight: 3, lowWeight: -3},
    {type: 'situation', key: "병력 보호를 우선해야 하는가?", highWeight: -4, lowWeight: 2},
    {type: 'personality', key: "공격성", weight: 3},
    {type: 'personality', key: "용기", weight: 2}
  ],
  "방어": [
    {type: 'situation', key: "방어보다 공격이 더 나은가?", highWeight: -3, lowWeight: 3},
    {type: 'situation', key: "병력 보호를 우선해야 하는가?", highWeight: 3, lowWeight: -2},
    {type: 'situation', key: "본부 병력을 보호해야 하는가?", highWeight: 2, lowWeight: -1},
    {type: 'personality', key: "손실 감내력", weight: 2}
  ],
  "방법": [
    {type: 'situation', key: "간접적인 전략을 선호하는가?", highWeight: 3, lowWeight: -2},
    {type: 'personality', key: "유연성", weight: 2},
    {type: 'situation', key: "시간이 내 편인가?", highWeight: 1, lowWeight: -1}
  ],
  "강도": [
    {type: 'personality', key: "용기", weight: 3},
    {type: 'situation', key: "시간이 내 편인가?", highWeight: 2, lowWeight: -2},
    {type: 'situation', key: "병력 보호를 우선해야 하는가?", highWeight: -2, lowWeight: 1}
  ],
  "방향": [
    {type: 'situation', key: "화력보다 기동이 더 나은가?", highWeight: 3, lowWeight: -2},
    {type: 'personality', key: "유연성", weight: 2},
    {type: 'personality', key: "임무 확대", weight: 2}
  ],
  "집중": [
    {type: 'situation', key: "병력 보호를 우선해야 하는가?", highWeight: 3, lowWeight: -2},
    {type: 'personality', key: "손실 감내력", weight: 2},
    {type: 'personality', key: "공격성", weight: -2}
  ]
};

let personState = {};
let situationState = {};
let tacticState = {};

function randIndex(n) { return Math.floor(Math.random() * n); }
function randChoice(arr) { return arr[randIndex(arr.length)]; }
function stageToScore(stage) { return stageScore[stage] ?? 0; }

function makeRow(label, valueText = "-", container, onClick) {
  const row = document.createElement('div');
  row.className = 'row';
  const lbl = document.createElement('div'); lbl.className = 'label'; lbl.textContent = label;
  const val = document.createElement('div'); val.className = 'value val-0'; val.textContent = valueText;
  row.appendChild(lbl); row.appendChild(val);
  if (onClick) {
    val.style.cursor = 'pointer';
    val.addEventListener('click', onClick);
  }
  container.appendChild(row);
  return {row, val};
}

const pContainer = document.getElementById('personality-list');
const sContainer = document.getElementById('situations-list');
const tContainer = document.getElementById('tactics-list');

function initUI() {
  pContainer.innerHTML = ''; sContainer.innerHTML = ''; tContainer.innerHTML = '';
  personalityKeys.forEach(k => {
    const {val} = makeRow(k, "-", pContainer, () => {
      const stage = randChoice(COMMON_7);
      personState[k] = stage;
      updatePersonUI(k);
      if (document.getElementById('auto-select').checked) { autoGenerateAll(); }
    });
    val.dataset.key = k;
  });
  situationKeys.forEach(k => {
    const {val} = makeRow(k, "-", sContainer, () => {
      const stage = randChoice(COMMON_7);
      situationState[k] = stage;
      updateSituationUI(k);
    });
    val.dataset.key = k;
  });
  Object.keys(tacticsMeta).forEach(k => {
    const {val} = makeRow(k, "-", tContainer, () => {
      pickTactic(k);
    });
    val.dataset.key = k;
  });
}
initUI();

function updatePersonUI(key) {
  const selector = `[data-key="${CSS.escape(key)}"]`;
  const el = document.querySelector(selector);
  const stage = personState[key] ?? "-";
  el.textContent = stage;
  el.className = "value " + (stage === "-" ? "val-0" : (stageScore[stage] >= 2 ? "good" : (stageScore[stage] <= -2 ? "bad" : "")));
}

function updateSituationUI(key) {
  const selector = `[data-key="${CSS.escape(key)}"]`;
  const el = document.querySelector(selector);
  const stage = situationState[key] ?? "-";
  el.textContent = stage;
  el.className = "value " + (stage === "-" ? "val-0" : (stageScore[stage] >= 2 ? "good" : (stageScore[stage] <= -2 ? "bad" : "")));
}

function updateTacticUI(key) {
  const selector = `[data-key="${CSS.escape(key)}"]`;
  const el = document.querySelector(selector);
  const val = tacticState[key] ?? "-";
  el.textContent = val;
  el.className = "value " + (val === "-" ? "val-0" : "");
}

function randomizePersonalityAll() {
  personalityKeys.forEach(k => {
    personState[k] = randChoice(COMMON_7);
    updatePersonUI(k);
  });
}

function randomizeSituationsAll() {
  situationKeys.forEach(k => {
    situationState[k] = randChoice(COMMON_7);
    updateSituationUI(k);
  });
}

function randomizeTacticsAll() {
  Object.keys(tacticsMeta).forEach(tac => {
    let choice;
    const scale = Number(document.getElementById('weight-scale').value);
    if (scale === 0) {
      const idx = Math.floor(Math.random() * tacticsMeta[tac].length);
      choice = tacticsMeta[tac][idx];
      console.log(`randomizeTacticsAll: tac=${tac}, scale=${scale}, idx=${idx}, choice=${choice}`);
    } else {
      const infl = tacticInfluence[tac];
      const score = scoreForInfluenceList(infl);
      const invert = tac === "방법";
      let idx = pickIndexFromScore(score, invert);
      idx = Math.max(0, Math.min(tacticsMeta[tac].length - 1, idx));
      choice = tacticsMeta[tac][idx];
      console.log(`randomizeTacticsAll: tac=${tac}, scale=${scale}, score=${score}, idx=${idx}, choice=${choice}`);
    }
    tacticState[tac] = choice;
    updateTacticUI(tac);
  });
  if (Math.random() < 0.1) {
    const twist = randChoice(plotTwistOptions);
    const flavorList = plotTwistFlavorTexts[twist] || [""];
    const flavorText = randChoice(flavorList);
    console.log(`PlotTwist: twist=${twist}, flavorText=${flavorText}`);
    showPlotTwistModal(twist, flavorText);
    handlePlotTwist(twist);
    Object.keys(tacticsMeta).forEach(k => updateTacticUI(k));
  }
}

function scoreForInfluenceList(influenceList) {
  if (!influenceList || !Array.isArray(influenceList)) return 0;
  const scale = Number(document.getElementById('weight-scale').value);
  if (scale === 0) return 0;
  let score = 0;
  influenceList.forEach(infl => {
    if (infl.type === 'situation') {
      const label = situationState[infl.key] || "50/50";
      const val = stageScore[label] || 0;
      if (val >= 0) {
        score += (infl.highWeight || 0) * val * scale;
      } else {
        score += (infl.lowWeight || 0) * val * scale;
      }
    } else if (infl.type === 'personality') {
      const label = personState[infl.key] || "50/50";
      const val = stageScore[label] || 0;
      score += (infl.weight || 0) * val * scale;
    }
  });
  return score;
}

function pickIndexFromScore(score, invert = false) {
  let baseIdx;
  if (score >= 9) baseIdx = invert ? 6 : 0;
  else if (score >= 6) baseIdx = invert ? 5 : 1;
  else if (score >= 3) baseIdx = invert ? 4 : 2;
  else if (score >= 0) baseIdx = 3;
  else if (score >= -3) baseIdx = invert ? 2 : 4;
  else if (score >= -6) baseIdx = invert ? 1 : 5;
  else baseIdx = invert ? 0 : 6;
  let candidates = [baseIdx];
  if (baseIdx > 0) candidates.unshift(baseIdx - 1);
  if (baseIdx < 6) candidates.push(baseIdx + 1);
  return randChoice(candidates);
}

function autoGenerateSituations() {
  situationKeys.forEach(sit => {
    let sum = 0;
    for (const p of personalityKeys) {
      const affects = personalityToSituations[p] || [];
      if (affects.includes(sit)) {
        const st = personState[p] ?? "50/50";
        sum += stageToScore(st);
      }
    }
    let candidates;
    if (sum >= 5) candidates = [0, 1];
    else if (sum >= 3) candidates = [1, 2];
    else if (sum >= 1) candidates = [2, 3];
    else if (sum >= -1) candidates = [2, 3];
    else if (sum >= -3) candidates = [4, 5];
    else if (sum >= -5) candidates = [4, 5];
    else candidates = [5, 6];
    const choiceIdx = candidates[Math.floor(Math.random() * candidates.length)];
    const stage = COMMON_7[choiceIdx];
    situationState[sit] = stage;
    updateSituationUI(sit);
  });
}

function autoGenerateTactics() {
  Object.keys(tacticsMeta).forEach(tac => {
    let choice;
    const scale = Number(document.getElementById('weight-scale').value);
    if (scale === 0) {
      const idx = Math.floor(Math.random() * tacticsMeta[tac].length);
      choice = tacticsMeta[tac][idx];
      console.log(`autoGenerateTactics: tac=${tac}, scale=${scale}, idx=${idx}, choice=${choice}`);
    } else {
      const infl = tacticInfluence[tac];
      const score = scoreForInfluenceList(infl);
      const invert = tac === "방법";
      let idx = pickIndexFromScore(score, invert);
      idx = Math.max(0, Math.min(tacticsMeta[tac].length - 1, idx));
      choice = tacticsMeta[tac][idx];
      console.log(`autoGenerateTactics: tac=${tac}, scale=${scale}, score=${score}, idx=${idx}, choice=${choice}`);
    }
    tacticState[tac] = choice;
    updateTacticUI(tac);
  });
}

function pickTactic(tac) {
  const opts = tacticsMeta[tac];
  if (!opts || !opts.length) return;
  let choice;
  const scale = Number(document.getElementById('weight-scale').value);
  if (scale === 0) {
    const idx = Math.floor(Math.random() * opts.length);
    choice = opts[idx];
    console.log(`pickTactic: tac=${tac}, scale=${scale}, idx=${idx}, choice=${choice}`);
  } else {
    const infl = tacticInfluence[tac];
    const score = scoreForInfluenceList(infl);
    const invert = tac === "방법";
    let idx = pickIndexFromScore(score, invert);
    idx = Math.max(0, Math.min(opts.length - 1, idx));
    choice = opts[idx];
    console.log(`pickTactic: tac=${tac}, scale=${scale}, score=${score}, idx=${idx}, choice=${choice}`);
  }
  tacticState[tac] = choice;
  updateTacticUI(tac);
  if (Math.random() < 0.25) {
    const twist = randChoice(plotTwistOptions);
    const flavorList = plotTwistFlavorTexts[twist] || [""];
    const flavorText = randChoice(flavorList);
    console.log(`PlotTwist: twist=${twist}, flavorText=${flavorText}`);
    showPlotTwistModal(twist, flavorText);
    handlePlotTwist(twist);
    Object.keys(tacticsMeta).forEach(k => updateTacticUI(k));
  }
}

function handlePlotTwist(choice) {
  switch (choice) {
    case "모든 성격을 재설정합니다":
      randomizePersonalityAll();
      if (document.getElementById('auto-select').checked) autoGenerateAll();
      break;
    case "성격 2개를 재설정합니다":
      for (let i = 0; i < 2; i++) {
        const p = randChoice(personalityKeys);
        personState[p] = randChoice(COMMON_7);
        updatePersonUI(p);
      }
      if (document.getElementById('auto-select').checked) autoGenerateAll();
      break;
    case "상황 또는 성격 1개를 재설정합니다":
      if (Math.random() < 0.5) {
        const s = randChoice(situationKeys);
        situationState[s] = randChoice(COMMON_7);
        updateSituationUI(s);
      } else {
        const p = randChoice(personalityKeys);
        personState[p] = randChoice(COMMON_7);
        updatePersonUI(p);
      }
      if (document.getElementById('auto-select').checked) autoGenerateAll();
      break;
    case "상황 1개를 재설정합니다":
      const s = randChoice(situationKeys);
      situationState[s] = randChoice(COMMON_7);
      updateSituationUI(s);
      if (document.getElementById('auto-select').checked) autoGenerateTactics();
      break;
    case "상황 2개를 재설정합니다":
      for (let i = 0; i < 2; i++) {
        const s = randChoice(situationKeys);
        situationState[s] = randChoice(COMMON_7);
        updateSituationUI(s);
      }
      if (document.getElementById('auto-select').checked) autoGenerateTactics();
      break;
    case "모든 상황을 재설정합니다":
      randomizeSituationsAll();
      if (document.getElementById('auto-select').checked) autoGenerateTactics();
      break;
    case "전술 하나를 예상 밖으로 변경합니다":
      const tac = randChoice(Object.keys(tacticsMeta));
      tacticState[tac] = randChoice(tacticsMeta[tac]);
      updateTacticUI(tac);
      break;
  }
}

function autoGenerateAll() {
  autoGenerateSituations();
  autoGenerateTactics();
}

function showPlotTwistModal(message, flavorText) {
  const modal = document.getElementById('plot-twist-modal');
  const titleEl = document.getElementById('plot-twist-title');
  const messageEl = document.getElementById('plot-twist-message');
  const flavorEl = document.getElementById('plot-twist-flavor');
  titleEl.textContent = "상황이 바뀌었습니다!";
  messageEl.textContent = message;
  flavorEl.textContent = flavorText;
  modal.style.display = 'block';
  const closeModalOnClick = () => {
    modal.style.display = 'none';
    document.removeEventListener('click', closeModalOnClick);
  };
  setTimeout(() => {
    document.addEventListener('click', closeModalOnClick);
  }, 0);
  setTimeout(() => {
    modal.style.display = 'none';
    document.removeEventListener('click', closeModalOnClick);
  }, 5000);
}

function showGuidelineModal() {
  const modal = document.getElementById('guideline-modal');
  modal.style.display = 'block';
  const closeModalOnClick = () => {
    modal.style.display = 'none';
    document.removeEventListener('click', closeModalOnClick);
  };
  setTimeout(() => {
    document.addEventListener('click', closeModalOnClick);
  }, 0);
  setTimeout(() => {
    modal.style.display = 'none';
    document.removeEventListener('click', closeModalOnClick);
  }, 10000);
}

document.getElementById('seed-personality').addEventListener('click', () => {
  randomizePersonalityAll();
  if (document.getElementById('auto-select').checked) {
    autoGenerateAll();
  }
});
document.getElementById('reset-personality').addEventListener('click', () => {
  personState = {};
  document.querySelectorAll('#personality-list .value').forEach(v => { v.textContent = "-"; v.className = "value val-0"; });
});
document.getElementById('randomize-all-situations').addEventListener('click', () => {
  randomizeSituationsAll();
});
document.getElementById('reset-situations').addEventListener('click', () => {
  situationState = {};
  document.querySelectorAll('#situations-list .value').forEach(v => { v.textContent = "-"; v.className = "value val-0"; });
});
document.getElementById('randomize-all-tactics').addEventListener('click', () => {
  randomizeTacticsAll();
});
document.getElementById('reset-tactics').addEventListener('click', () => {
  tacticState = {};
  document.querySelectorAll('#tactics-list .value').forEach(v => { v.textContent = "-"; v.className = "value val-0"; });
});
document.getElementById('custom-question').addEventListener('click', () => {
  const stageIdx = randIndex(7);
  const optIdx = randIndex(6);
  const ans = questionMatrix[stageIdx][optIdx];
  const el = document.getElementById('custom-result');
  el.textContent = ans;
  el.className = "value " + (stageIdx <= 1 ? "good" : (stageIdx >= 5 ? "bad" : ""));
});
document.getElementById('guideline-link').addEventListener('click', showGuidelineModal);
document.getElementById('guideline-close').addEventListener('click', () => {
  document.getElementById('guideline-modal').style.display = 'none';
});

function attachInitialValues() {
  personalityKeys.forEach(k => personState[k] = undefined);
  situationKeys.forEach(k => situationState[k] = undefined);
  Object.keys(tacticsMeta).forEach(k => tacticState[k] = undefined);
}
attachInitialValues();

(function setDataKeys() {
  const pvals = pContainer.querySelectorAll('.value');
  pvals.forEach((el, i) => el.dataset.key = personalityKeys[i]);
  const svals = sContainer.querySelectorAll('.value');
  svals.forEach((el, i) => el.dataset.key = situationKeys[i]);
  const tvals = tContainer.querySelectorAll('.value');
  Object.keys(tacticsMeta).forEach((k, i) => tvals[i] && (tvals[i].dataset.key = k));
})();

document.getElementById('weight-scale').addEventListener('input', (e) => {
  document.getElementById('weight-scale-value').textContent = e.target.value;
});
</script>
</body>
</html>